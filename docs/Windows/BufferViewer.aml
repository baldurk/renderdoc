<?xml version="1.0" encoding="utf-8"?>
<topic id="C48DED3E-3303-4A82-8F58-3D39766C48E7" revisionNumber="1">
  <developerConceptualDocument xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5" xmlns:xlink="http://www.w3.org/1999/xlink">
    <introduction>
      <para>The buffer viewer has two reasonably distinct modes - the first rather
      specialised to show meshes and mesh data as it passes through the pipeline.
      The other shows a raw arbitrary buffer with a custom (and arbitrary) formatting.</para>
    </introduction>
    <section address="mesh">
      <title>Mesh Viewer</title>
      <content>
        <para>The Mesh Viewer shows both the mesh data as well as a visual representation
        of the mesh at different stages - pre VS, post VS, etc. For instanced drawcalls you
        can choose which instance to view in the toolbar at the top.</para>
        <para>Each distinct point has a display that shows the mesh data, the format of which
        is pulled from the relevant stage of the pipeline - shader input or output, or input
        layout. You can choose to sync these views <mediaLinkInline><image xlink:href="arrow_join"/></mediaLinkInline>
        as well as specify an offset which will stay consistent, so that you can see the same
        row as you move between different events.</para>
        <para>Below this is a 3D view which will show one stage at any given time, and can be
        switched with the tabs above it. There are two control schemes for viewing the 3D mesh -
        Arcball which is the default for pre-transform (VS in), and WASD controls which is the
        default for post-transform (VS out). You can switch between these at any time with
        the dropdown on the toolbar above the mesh view.</para>
        
<alert class="note">
  <para>When tessellation is active, VS out behaves similarly to VS in as they are both
  considered input data (rather than post-transform data).</para>
</alert>

        <para>You can reset the camera to its default location with the reset button
        <mediaLinkInline><image xlink:href="arrow_undo"/></mediaLinkInline>. For VS Input this
        resets to an arcball at some radius from the object. For VS Output this resets to a view
        from the projected eye.</para>
        <para>You can also auto-fit the camera to the mesh for the VS Input mesh. The auto-fit
        button <mediaLinkInline><image xlink:href="wand"/></mediaLinkInline> will fit the
        camera to the axis-aligned bounding box of the mesh.</para>
        <para>To be able to view the post-transform mesh in view-space, RenderDoc attempts to
        guess the projection matrix and unprojects the output data.</para>
        <para>By default the projection matrix is guessed as a standard perspective matrix.
        Using the post-projection w and z values and the aspect ratio of the output targets
        a reasonable approximation can be estimated. The FOV must be specified though - the
        default is 90 but this can be refined by opening the options.</para>
        <para>Opening the options <mediaLinkInline><image xlink:href="cog"/></mediaLinkInline>
        you can specify the FOV used in the projection matrix. If you used an orthographic
        matrix instead you can specify this - although this requires manual tuning of the
        matrix parameters.</para>
        <mediaLink>
<caption placement="after" lead="Options">The options pop-out of the buffer viewer.</caption>
<image xlink:href="BufferOptions"/>
</mediaLink>
        <para>Also available in the options is a simple speed multiplier for the WASD controls,
        to fine-tune how fast it moves to the dimensions of the mesh.</para>
      </content>
    </section>
    <section address="secondary">
      <title>Mesh Preview</title>
      <content>
        <para>In the 3D Mesh preview, you have the option to display the mesh with some solid
        shading modes, not just as a wireframe mesh. When solid shading you can toggle the wireframe
        on and off.</para>
        
<list class="bullet">
  <listItem><para>Solid Colour simply displays a solid colour for each triangle.</para></listItem>
  <listItem><para>Flat Shaded will perform basic flat lighting calculations based on triangle normals to give a better idea of the topology of the mesh.</para></listItem>
  <listItem><para>Secondary will display the selected secondary mesh element.</para></listItem>
</list>

        <para>To select which element will be displayed as secondary, simply right click on the column
        you would like to use. This can be done on the input and output separately, and 4-component
        columns have the option to either show RGB as colour, or alpha as greyscale.</para>
        <para>The selection will be remembered as long as the mesh format stays consistent between
        draws.</para>
        <para>You can also use this if the position data isn't detected in your inputs and you'd like
        to choose which element contains the positions, or if you'd like to visualise some other data
        such as UV co-ordinates as positional (in effect rendering the mesh in uv-space).</para>
        
        <mediaLink>
<caption placement="after" lead="Preview">Previewing the uv co-ordinates as colour on the mesh.</caption>
<image xlink:href="SolidPreview"/>
</mediaLink>
      </content>
    </section>
    <section address="buff">
      <title>Raw Buffer Viewer</title>
      <content>
        <para>When opening a buffer as a raw display, sometimes a default layout will be specified
        e.g. if available from shader reflection data. If not, the layout will default to 4
        32bit unsigned integers.</para>
        <para>This format can be refined and customised by entering a structure-like definition
        into the text box at the bottom of the window. The given types are listed below, and
        can be combined in hlsl- or glsl-like fashion specifying n-wide vector elements.</para>
        <para>In addition to this, you can specify a row offset which is useful in remaining
        at the same row while watching the change in a buffer between different events, as well
        as a byte offset to shift the data along from the start of the buffer (e.g. if what you
        are interested in starts only part-way through the buffer but is not aligned along the
        data stride you enter).</para>
        
        <mediaLink>
<caption placement="after" lead="Buffer specification">Specifying a custom buffer format.</caption>
<image xlink:href="RawBuffer"/>
</mediaLink>

		<para>Below are listed the basic types. You can append a number to each of these to make an N-wide
		vector (e.g. ushort4 or float3, or uvec4/vec3). You can also specify matrices as float3x4 or mat3x4.
		By default matrices
		are column major, but you can change this by prepending row_major as you would in hlsl.</para>
        
<list class="bullet">
  <listItem><para>uint - unsigned 32bit integer</para></listItem>
  <listItem><para>bool - unsigned 32bit integer (this is the format for hlsl bools)</para></listItem>
  <listItem><para>int - signed 32bit integer</para></listItem>
  <listItem><para>ushort - unsigned 16bit integer</para></listItem>
  <listItem><para>short - signed 16bit integer</para></listItem>
  <listItem><para>ubyte - unsigned 8bit integer</para></listItem>
  <listItem><para>byte - signed 8bit integer</para></listItem>
  <listItem><para>double - 64bit floating point</para></listItem>
  <listItem><para>float - 32bit floating point</para></listItem>
  <listItem><para>half - 16bit floating point</para></listItem>
</list>

		<para>There are also some non-hlsl types for displaying other formats which don't have a corresponding native
		hlsl type</para>

<list class="bullet">
  <listItem><para>unormb - 8bit unsigned normalised value</para></listItem>
  <listItem><para>unormh - 16bit unsigned normalised value</para></listItem>
  <listItem><para>unormf - 32bit unsigned normalised value</para></listItem>
  <listItem><para>snormb - 8bit signed normalised value</para></listItem>
  <listItem><para>snormh - 16bit signed normalised value</para></listItem>
  <listItem><para>snormf - 32bit signed normalised value</para></listItem>
  <listItem><para>uintten - 4 component unsigned integer format, packed as 10:10:10:2</para></listItem>
  <listItem><para>unormten - 4 component unsigned normalised format, packed as 10:10:10:2</para></listItem>
  <listItem><para>xuint - hex-formatted 32bit integer</para></listItem>
  <listItem><para>xshort - hex-formatted 16bit integer</para></listItem>
  <listItem><para>xbyte - hex-formatted 8bit integer</para></listItem>
</list>

      </content>
    </section>
  </developerConceptualDocument>
</topic>
