<?xml version="1.0"?>
<doc>
    <assembly>
        <name>IronPython.Modules</name>
    </assembly>
    <members>
        <member name="M:IronPython.Modules.Bz2.Bz2Module.ToArrayNoCopy(System.Collections.Generic.IList{System.Byte})">
            <summary>
            Try to convert IList(Of byte) to byte[] without copying, if possible.
            </summary>
            <param name="bytes"></param>
            <returns></returns>
        </member>
        <member name="M:IronPython.Modules.Bz2.Bz2Module.BZ2Compressor.GetLatestData">
            <summary>
            Copy the latest data from the memory buffer.
            
            This won't always contain data, because comrpessed data is only written after a block is filled.
            </summary>
            <returns></returns>
        </member>
        <member name="M:IronPython.Modules.Bz2.Bz2Module.BZ2Decompressor.AddData(System.Byte[])">
            <summary>
            Add data to the input buffer. This manipulates the position of the stream
            to make it appear to the BZip2 stream that nothing has actually changed.
            </summary>
            <param name="bytes">The data to append to the buffer.</param>
        </member>
        <member name="M:Ionic.BZip2.BitWriter.Reset">
            <summary>
              Reset the BitWriter.
            </summary>
            <remarks>
              <para>
                This is useful when the BitWriter writes into a MemoryStream, and
                is used by a BZip2Compressor, which itself is re-used for multiple
                distinct data blocks.
              </para>
            </remarks>
        </member>
        <member name="M:Ionic.BZip2.BitWriter.WriteBits(System.Int32,System.UInt32)">
            <summary>
              Write some number of bits from the given value, into the output.
            </summary>
            <remarks>
              <para>
                The nbits value should be a max of 25, for safety. For performance
                reasons, this method does not check!
              </para>
            </remarks>
        </member>
        <member name="M:Ionic.BZip2.BitWriter.WriteByte(System.Byte)">
            <summary>
              Write a full 8-bit byte into the output.
            </summary>
        </member>
        <member name="M:Ionic.BZip2.BitWriter.WriteInt(System.UInt32)">
            <summary>
              Write four 8-bit bytes into the output.
            </summary>
        </member>
        <member name="M:Ionic.BZip2.BitWriter.Flush">
            <summary>
              Write all available byte-aligned bytes.
            </summary>
            <remarks>
              <para>
                This method writes no new output, but flushes any accumulated
                bits. At completion, the accumulator may contain up to 7
                bits.
              </para>
              <para>
                This is necessary when re-assembling output from N independent
                compressors, one for each of N blocks. The output of any
                particular compressor will in general have some fragment of a byte
                remaining. This fragment needs to be accumulated into the
                parent BZip2OutputStream.
              </para>
            </remarks>
        </member>
        <member name="M:Ionic.BZip2.BitWriter.FinishAndPad">
            <summary>
              Writes all available bytes, and emits padding for the final byte as
              necessary. This must be the last method invoked on an instance of
              BitWriter.
            </summary>
        </member>
        <member name="P:Ionic.BZip2.BitWriter.RemainingBits">
            <summary>
              Delivers the remaining bits, left-aligned, in a byte.
            </summary>
            <remarks>
              <para>
                This is valid only if NumRemainingBits is less than 8;
                in other words it is valid only after a call to Flush().
              </para>
            </remarks>
        </member>
        <member name="F:Ionic.BZip2.BZip2Compressor.increments">
            Knuth's increments seem to work better than Incerpi-Sedgewick here.
            Possibly because the number of elems to sort is usually small, typically
            &lt;= 20.
        </member>
        <member name="M:Ionic.BZip2.BZip2Compressor.#ctor(Ionic.BZip2.BitWriter)">
            <summary>
              BZip2Compressor writes its compressed data out via a BitWriter. This
              is necessary because BZip2 does byte shredding.
            </summary>
        </member>
        <member name="M:Ionic.BZip2.BZip2Compressor.Fill(System.Byte[],System.Int32,System.Int32)">
            <summary>
              Accept new bytes into the compressor data buffer
            </summary>
            <remarks>
              <para>
                This method does the first-level (cheap) run-length encoding, and
                stores the encoded data into the rle block.
              </para>
            </remarks>
        </member>
        <member name="M:Ionic.BZip2.BZip2Compressor.write0(System.Byte)">
             <summary>
               Process one input byte into the block.
             </summary>
            
             <remarks>
               <para>
                 To "process" the byte means to do the run-length encoding.
                 There are 3 possible return values:
            
                    0 - the byte was not written, in other words, not
                        encoded into the block. This happens when the
                        byte b would require the start of a new run, and
                        the block has no more room for new runs.
            
                    1 - the byte was written, and the block is not full.
            
                    2 - the byte was written, and the block is full.
            
               </para>
             </remarks>
             <returns>0 if the byte was not written, non-zero if written.</returns>
        </member>
        <member name="M:Ionic.BZip2.BZip2Compressor.AddRunToOutputBlock(System.Boolean)">
             <summary>
               Append one run to the output block.
             </summary>
            
             <remarks>
               <para>
                 This compressor does run-length-encoding before BWT and etc. This
                 method simply appends a run to the output block. The append always
                 succeeds. The return value indicates whether the block is full:
                 false (not full) implies that at least one additional run could be
                 processed.
               </para>
             </remarks>
             <returns>true if the block is now full; otherwise false.</returns>
        </member>
        <member name="M:Ionic.BZip2.BZip2Compressor.CompressAndWrite">
            <summary>
              Compress the data that has been placed (Run-length-encoded) into the
              block. The compressed data goes into the CompressedBytes array.
            </summary>
            <remarks>
              <para>
                Side effects: 1.  fills the CompressedBytes array.  2. sets the
                AvailableBytesOut property.
              </para>
            </remarks>
        </member>
        <member name="M:Ionic.BZip2.BZip2Compressor.mainSimpleSort(Ionic.BZip2.BZip2Compressor.CompressionState,System.Int32,System.Int32,System.Int32)">
             This is the most hammered method of this class.
            
             <p>
             This is the version using unrolled loops.
             </p>
        </member>
        <member name="M:Ionic.BZip2.BZip2Compressor.mainQSort3(Ionic.BZip2.BZip2Compressor.CompressionState,System.Int32,System.Int32,System.Int32)">
            Method "mainQSort3", file "blocksort.c", BZip2 1.0.2
        </member>
        <member name="P:Ionic.BZip2.BZip2Compressor.UncompressedBytes">
            <summary>
              The number of uncompressed bytes being held in the buffer.
            </summary>
            <remarks>
              <para>
                I am thinking this may be useful in a Stream that uses this
                compressor class. In the Close() method on the stream it could
                check this value to see if anything has been written at all.  You
                may think the stream could easily track the number of bytes it
                wrote, which would eliminate the need for this. But, there is the
                case where the stream writes a complete block, and it is full, and
                then writes no more. In that case the stream may want to check.
              </para>
            </remarks>
        </member>
        <member name="F:Ionic.BZip2.BZip2Compressor.CompressionState.quadrant">
            Array instance identical to sfmap, both are used only
            temporarily and independently, so we do not need to allocate
            additional memory.
        </member>
        <member name="T:Ionic.BZip2.BZip2InputStream">
            <summary>
              A read-only decorator stream that performs BZip2 decompression on Read.
            </summary>
        </member>
        <member name="M:Ionic.BZip2.BZip2InputStream.#ctor(System.IO.Stream)">
            <summary>
              Create a BZip2InputStream, wrapping it around the given input Stream.
            </summary>
            <remarks>
              <para>
                The input stream will be closed when the BZip2InputStream is closed.
              </para>
            </remarks>
            <param name='input'>The stream from which to read compressed data</param>
        </member>
        <member name="M:Ionic.BZip2.BZip2InputStream.#ctor(System.IO.Stream,System.Boolean)">
             <summary>
               Create a BZip2InputStream with the given stream, and
               specifying whether to leave the wrapped stream open when
               the BZip2InputStream is closed.
             </summary>
             <param name='input'>The stream from which to read compressed data</param>
             <param name='leaveOpen'>
               Whether to leave the input stream open, when the BZip2InputStream closes.
             </param>
            
             <example>
            
               This example reads a bzip2-compressed file, decompresses it,
               and writes the decompressed data into a newly created file.
            
               <code>
               var fname = "logfile.log.bz2";
               using (var fs = File.OpenRead(fname))
               {
                   using (var decompressor = new Ionic.BZip2.BZip2InputStream(fs))
                   {
                       var outFname = fname + ".decompressed";
                       using (var output = File.Create(outFname))
                       {
                           byte[] buffer = new byte[2048];
                           int n;
                           while ((n = decompressor.Read(buffer, 0, buffer.Length)) > 0)
                           {
                               output.Write(buffer, 0, n);
                           }
                       }
                   }
               }
               </code>
             </example>
        </member>
        <member name="M:Ionic.BZip2.BZip2InputStream.Read(System.Byte[],System.Int32,System.Int32)">
             <summary>
               Read data from the stream.
             </summary>
            
             <remarks>
               <para>
                 To decompress a BZip2 data stream, create a <c>BZip2InputStream</c>,
                 providing a stream that reads compressed data.  Then call Read() on
                 that <c>BZip2InputStream</c>, and the data read will be decompressed
                 as you read.
               </para>
            
               <para>
                 A <c>BZip2InputStream</c> can be used only for <c>Read()</c>, not for <c>Write()</c>.
               </para>
             </remarks>
            
             <param name="buffer">The buffer into which the read data should be placed.</param>
             <param name="offset">the offset within that data array to put the first byte read.</param>
             <param name="count">the number of bytes to read.</param>
             <returns>the number of bytes actually read</returns>
        </member>
        <member name="M:Ionic.BZip2.BZip2InputStream.ReadByte">
            <summary>
              Read a single byte from the stream.
            </summary>
            <returns>the byte read from the stream, or -1 if EOF</returns>
        </member>
        <member name="M:Ionic.BZip2.BZip2InputStream.Flush">
            <summary>
            Flush the stream.
            </summary>
        </member>
        <member name="M:Ionic.BZip2.BZip2InputStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>
            Calling this method always throws a <see cref="T:System.NotImplementedException"/>.
            </summary>
            <param name="offset">this is irrelevant, since it will always throw!</param>
            <param name="origin">this is irrelevant, since it will always throw!</param>
            <returns>irrelevant!</returns>
        </member>
        <member name="M:Ionic.BZip2.BZip2InputStream.SetLength(System.Int64)">
            <summary>
            Calling this method always throws a <see cref="T:System.NotImplementedException"/>.
            </summary>
            <param name="value">this is irrelevant, since it will always throw!</param>
        </member>
        <member name="M:Ionic.BZip2.BZip2InputStream.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
              Calling this method always throws a <see cref="T:System.NotImplementedException"/>.
            </summary>
            <param name="buffer">this parameter is never used</param>
            <param name="offset">this parameter is never used</param>
            <param name="count">this parameter is never used</param>
        </member>
        <member name="M:Ionic.BZip2.BZip2InputStream.Dispose(System.Boolean)">
            <summary>
              Dispose the stream.
            </summary>
            <param name="disposing">
              indicates whether the Dispose method was invoked by user code.
            </param>
        </member>
        <member name="M:Ionic.BZip2.BZip2InputStream.Close">
            <summary>
              Close the stream.
            </summary>
        </member>
        <member name="M:Ionic.BZip2.BZip2InputStream.GetBits(System.Int32)">
            <summary>
              Read n bits from input, right justifying the result.
            </summary>
            <remarks>
              <para>
                For example, if you read 1 bit, the result is either 0
                or 1.
              </para>
            </remarks>
            <param name ="n">
              The number of bits to read, always between 1 and 32.
            </param>
        </member>
        <member name="M:Ionic.BZip2.BZip2InputStream.hbCreateDecodeTables(System.Int32[],System.Int32[],System.Int32[],System.Char[],System.Int32,System.Int32,System.Int32)">
            Called by createHuffmanDecodingTables() exclusively.
        </member>
        <member name="M:Ionic.BZip2.BZip2InputStream.createHuffmanDecodingTables(System.Int32,System.Int32)">
            Called by recvDecodingTables() exclusively.
        </member>
        <member name="M:Ionic.BZip2.BZip2InputStream.DumpState">
            <summary>
            Dump the current state of the decompressor, to restore it in case of an error.
            This allows the decompressor to be essentially "rewound" and retried when more
            data arrives.
            
            This is only used by IronPython.
            </summary>
            <returns>The current state.</returns>
        </member>
        <member name="M:Ionic.BZip2.BZip2InputStream.RestoreState(System.Object)">
            <summary>
            Restore the internal compressor state if an error occurred.
            </summary>
            <param name="o">The old state.</param>
        </member>
        <member name="P:Ionic.BZip2.BZip2InputStream.CanRead">
            <summary>
            Indicates whether the stream can be read.
            </summary>
            <remarks>
            The return value depends on whether the captive stream supports reading.
            </remarks>
        </member>
        <member name="P:Ionic.BZip2.BZip2InputStream.CanSeek">
            <summary>
            Indicates whether the stream supports Seek operations.
            </summary>
            <remarks>
            Always returns false.
            </remarks>
        </member>
        <member name="P:Ionic.BZip2.BZip2InputStream.CanWrite">
            <summary>
            Indicates whether the stream can be written.
            </summary>
            <remarks>
            The return value depends on whether the captive stream supports writing.
            </remarks>
        </member>
        <member name="P:Ionic.BZip2.BZip2InputStream.Length">
            <summary>
            Reading this property always throws a <see cref="T:System.NotImplementedException"/>.
            </summary>
        </member>
        <member name="P:Ionic.BZip2.BZip2InputStream.Position">
             <summary>
             The position of the stream pointer.
             </summary>
            
             <remarks>
               Setting this property always throws a <see cref="T:System.NotImplementedException"/>. Reading will return the
               total number of uncompressed bytes read in.
             </remarks>
        </member>
        <member name="T:Ionic.BZip2.BZip2InputStream.CState">
            <summary>
              Compressor State
            </summary>
        </member>
        <member name="F:Ionic.BZip2.BZip2InputStream.DecompressionState.unzftab">
            Freq table collected to save a pass over the data during
            decompression.
        </member>
        <member name="M:Ionic.BZip2.BZip2InputStream.DecompressionState.initTT(System.Int32)">
             Initializes the tt array.
            
             This method is called when the required length of the array is known.
             I don't initialize it at construction time to avoid unneccessary
             memory allocation when compressing small files.
        </member>
        <member name="T:Ionic.BZip2.BZip2OutputStream">
            <summary>
              A write-only decorator stream that compresses data as it is
              written using the BZip2 algorithm.
            </summary>
        </member>
        <member name="M:Ionic.BZip2.BZip2OutputStream.#ctor(System.IO.Stream)">
             <summary>
               Constructs a new <c>BZip2OutputStream</c>, that sends its
               compressed output to the given output stream.
             </summary>
            
             <param name='output'>
               The destination stream, to which compressed output will be sent.
             </param>
            
             <example>
            
               This example reads a file, then compresses it with bzip2 file,
               and writes the compressed data into a newly created file.
            
               <code>
               var fname = "logfile.log";
               using (var fs = File.OpenRead(fname))
               {
                   var outFname = fname + ".bz2";
                   using (var output = File.Create(outFname))
                   {
                       using (var compressor = new Ionic.BZip2.BZip2OutputStream(output))
                       {
                           byte[] buffer = new byte[2048];
                           int n;
                           while ((n = fs.Read(buffer, 0, buffer.Length)) > 0)
                           {
                               compressor.Write(buffer, 0, n);
                           }
                       }
                   }
               }
               </code>
             </example>
        </member>
        <member name="M:Ionic.BZip2.BZip2OutputStream.#ctor(System.IO.Stream,System.Int32)">
            <summary>
              Constructs a new <c>BZip2OutputStream</c> with specified blocksize.
            </summary>
            <param name = "output">the destination stream.</param>
            <param name = "blockSize">
              The blockSize in units of 100000 bytes.
              The valid range is 1..9.
            </param>
        </member>
        <member name="M:Ionic.BZip2.BZip2OutputStream.#ctor(System.IO.Stream,System.Boolean)">
            <summary>
              Constructs a new <c>BZip2OutputStream</c>.
            </summary>
              <param name = "output">the destination stream.</param>
            <param name = "leaveOpen">
              whether to leave the captive stream open upon closing this stream.
            </param>
        </member>
        <member name="M:Ionic.BZip2.BZip2OutputStream.#ctor(System.IO.Stream,System.Int32,System.Boolean)">
             <summary>
               Constructs a new <c>BZip2OutputStream</c> with specified blocksize,
               and explicitly specifies whether to leave the wrapped stream open.
             </summary>
            
             <param name = "output">the destination stream.</param>
             <param name = "blockSize">
               The blockSize in units of 100000 bytes.
               The valid range is 1..9.
             </param>
             <param name = "leaveOpen">
               whether to leave the captive stream open upon closing this stream.
             </param>
        </member>
        <member name="M:Ionic.BZip2.BZip2OutputStream.Close">
            <summary>
              Close the stream.
            </summary>
            <remarks>
              <para>
                This may or may not close the underlying stream.  Check the
                constructors that accept a bool value.
              </para>
            </remarks>
        </member>
        <member name="M:Ionic.BZip2.BZip2OutputStream.Flush">
            <summary>
              Flush the stream.
            </summary>
        </member>
        <member name="M:Ionic.BZip2.BZip2OutputStream.Write(System.Byte[],System.Int32,System.Int32)">
             <summary>
               Write data to the stream.
             </summary>
             <remarks>
            
             <para>
               Use the <c>BZip2OutputStream</c> to compress data while writing:
               create a <c>BZip2OutputStream</c> with a writable output stream.
               Then call <c>Write()</c> on that <c>BZip2OutputStream</c>, providing
               uncompressed data as input.  The data sent to the output stream will
               be the compressed form of the input data.
             </para>
            
             <para>
               A <c>BZip2OutputStream</c> can be used only for <c>Write()</c> not for <c>Read()</c>.
             </para>
            
             </remarks>
            
             <param name="buffer">The buffer holding data to write to the stream.</param>
             <param name="offset">the offset within that data array to find the first byte to write.</param>
             <param name="count">the number of bytes to write.</param>
        </member>
        <member name="M:Ionic.BZip2.BZip2OutputStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>
            Calling this method always throws a <see cref="T:System.NotImplementedException"/>.
            </summary>
            <param name="offset">this is irrelevant, since it will always throw!</param>
            <param name="origin">this is irrelevant, since it will always throw!</param>
            <returns>irrelevant!</returns>
        </member>
        <member name="M:Ionic.BZip2.BZip2OutputStream.SetLength(System.Int64)">
            <summary>
            Calling this method always throws a <see cref="T:System.NotImplementedException"/>.
            </summary>
            <param name="value">this is irrelevant, since it will always throw!</param>
        </member>
        <member name="M:Ionic.BZip2.BZip2OutputStream.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
              Calling this method always throws a <see cref="T:System.NotImplementedException"/>.
            </summary>
            <param name="buffer">this parameter is never used</param>
            <param name="offset">this parameter is never used</param>
            <param name="count">this parameter is never used</param>
            <returns>never returns anything; always throws</returns>
        </member>
        <member name="P:Ionic.BZip2.BZip2OutputStream.BlockSize">
            <summary>
              The blocksize parameter specified at construction time.
            </summary>
        </member>
        <member name="P:Ionic.BZip2.BZip2OutputStream.CanRead">
            <summary>
            Indicates whether the stream can be read.
            </summary>
            <remarks>
            The return value is always false.
            </remarks>
        </member>
        <member name="P:Ionic.BZip2.BZip2OutputStream.CanSeek">
            <summary>
            Indicates whether the stream supports Seek operations.
            </summary>
            <remarks>
            Always returns false.
            </remarks>
        </member>
        <member name="P:Ionic.BZip2.BZip2OutputStream.CanWrite">
            <summary>
            Indicates whether the stream can be written.
            </summary>
            <remarks>
            The return value should always be true, unless and until the
            object is disposed and closed.
            </remarks>
        </member>
        <member name="P:Ionic.BZip2.BZip2OutputStream.Length">
            <summary>
            Reading this property always throws a <see cref="T:System.NotImplementedException"/>.
            </summary>
        </member>
        <member name="P:Ionic.BZip2.BZip2OutputStream.Position">
             <summary>
             The position of the stream pointer.
             </summary>
            
             <remarks>
               Setting this property always throws a <see cref="T:System.NotImplementedException"/>. Reading will return the
               total number of uncompressed bytes written through.
             </remarks>
        </member>
        <member name="T:Ionic.Crc.CRC32">
            <summary>
              Computes a CRC-32. The CRC-32 algorithm is parameterized - you
              can set the polynomial and enable or disable bit
              reversal. This can be used for GZIP, BZip2, or ZIP.
            </summary>
            <remarks>
              This type is used internally by DotNetZip; it is generally not used
              directly by applications wishing to create, read, or manipulate zip
              archive files.
            </remarks>
        </member>
        <member name="M:Ionic.Crc.CRC32.GetCrc32(System.IO.Stream)">
            <summary>
            Returns the CRC32 for the specified stream.
            </summary>
            <param name="input">The stream over which to calculate the CRC32</param>
            <returns>the CRC32 calculation</returns>
        </member>
        <member name="M:Ionic.Crc.CRC32.GetCrc32AndCopy(System.IO.Stream,System.IO.Stream)">
            <summary>
            Returns the CRC32 for the specified stream, and writes the input into the
            output stream.
            </summary>
            <param name="input">The stream over which to calculate the CRC32</param>
            <param name="output">The stream into which to deflate the input</param>
            <returns>the CRC32 calculation</returns>
        </member>
        <member name="M:Ionic.Crc.CRC32.ComputeCrc32(System.Int32,System.Byte)">
            <summary>
              Get the CRC32 for the given (word,byte) combo.  This is a
              computation defined by PKzip for PKZIP 2.0 (weak) encryption.
            </summary>
            <param name="W">The word to start with.</param>
            <param name="B">The byte to combine it with.</param>
            <returns>The CRC-ized result.</returns>
        </member>
        <member name="M:Ionic.Crc.CRC32.SlurpBlock(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Update the value for the running CRC32 using the given block of bytes.
            This is useful when using the CRC32() class in a Stream.
            </summary>
            <param name="block">block of bytes to slurp</param>
            <param name="offset">starting point in the block</param>
            <param name="count">how many bytes within the block to slurp</param>
        </member>
        <member name="M:Ionic.Crc.CRC32.UpdateCRC(System.Byte)">
            <summary>
              Process one byte in the CRC.
            </summary>
            <param name = "b">the byte to include into the CRC .  </param>
        </member>
        <member name="M:Ionic.Crc.CRC32.UpdateCRC(System.Byte,System.Int32)">
            <summary>
              Process a run of N identical bytes into the CRC.
            </summary>
            <remarks>
              <para>
                This method serves as an optimization for updating the CRC when a
                run of identical bytes is found. Rather than passing in a buffer of
                length n, containing all identical bytes b, this method accepts the
                byte value and the length of the (virtual) buffer - the length of
                the run.
              </para>
            </remarks>
            <param name = "b">the byte to include into the CRC.  </param>
            <param name = "n">the number of times that byte should be repeated. </param>
        </member>
        <member name="M:Ionic.Crc.CRC32.Combine(System.Int32,System.Int32)">
            <summary>
              Combines the given CRC32 value with the current running total.
            </summary>
            <remarks>
              This is useful when using a divide-and-conquer approach to
              calculating a CRC.  Multiple threads can each calculate a
              CRC32 on a segment of the data, and then combine the
              individual CRC32 values at the end.
            </remarks>
            <param name="crc">the crc value to be combined with this one</param>
            <param name="length">the length of data the CRC value was calculated on</param>
        </member>
        <member name="M:Ionic.Crc.CRC32.#ctor">
            <summary>
              Create an instance of the CRC32 class using the default settings: no
              bit reversal, and a polynomial of 0xEDB88320.
            </summary>
        </member>
        <member name="M:Ionic.Crc.CRC32.#ctor(System.Boolean)">
            <summary>
              Create an instance of the CRC32 class, specifying whether to reverse
              data bits or not.
            </summary>
            <param name='reverseBits'>
              specify true if the instance should reverse data bits.
            </param>
            <remarks>
              <para>
                In the CRC-32 used by BZip2, the bits are reversed. Therefore if you
                want a CRC32 with compatibility with BZip2, you should pass true
                here. In the CRC-32 used by GZIP and PKZIP, the bits are not
                reversed; Therefore if you want a CRC32 with compatibility with
                those, you should pass false.
              </para>
            </remarks>
        </member>
        <member name="M:Ionic.Crc.CRC32.#ctor(System.Int32,System.Boolean)">
             <summary>
               Create an instance of the CRC32 class, specifying the polynomial and
               whether to reverse data bits or not.
             </summary>
             <param name='polynomial'>
               The polynomial to use for the CRC, expressed in the reversed (LSB)
               format: the highest ordered bit in the polynomial value is the
               coefficient of the 0th power; the second-highest order bit is the
               coefficient of the 1 power, and so on. Expressed this way, the
               polynomial for the CRC-32C used in IEEE 802.3, is 0xEDB88320.
             </param>
             <param name='reverseBits'>
               specify true if the instance should reverse data bits.
             </param>
            
             <remarks>
               <para>
                 In the CRC-32 used by BZip2, the bits are reversed. Therefore if you
                 want a CRC32 with compatibility with BZip2, you should pass true
                 here for the <c>reverseBits</c> parameter. In the CRC-32 used by
                 GZIP and PKZIP, the bits are not reversed; Therefore if you want a
                 CRC32 with compatibility with those, you should pass false for the
                 <c>reverseBits</c> parameter.
               </para>
             </remarks>
        </member>
        <member name="M:Ionic.Crc.CRC32.Reset">
            <summary>
              Reset the CRC-32 class - clear the CRC "remainder register."
            </summary>
            <remarks>
              <para>
                Use this when employing a single instance of this class to compute
                multiple, distinct CRCs on multiple, distinct data blocks.
              </para>
            </remarks>
        </member>
        <member name="P:Ionic.Crc.CRC32.TotalBytesRead">
            <summary>
              Indicates the total number of bytes applied to the CRC.
            </summary>
        </member>
        <member name="P:Ionic.Crc.CRC32.Crc32Result">
            <summary>
            Indicates the current CRC for all blocks slurped in.
            </summary>
        </member>
        <member name="T:Ionic.Crc.CrcCalculatorStream">
             <summary>
             A Stream that calculates a CRC32 (a checksum) on all bytes read,
             or on all bytes written.
             </summary>
            
             <remarks>
             <para>
             This class can be used to verify the CRC of a ZipEntry when
             reading from a stream, or to calculate a CRC when writing to a
             stream.  The stream should be used to either read, or write, but
             not both.  If you intermix reads and writes, the results are not
             defined.
             </para>
            
             <para>
             This class is intended primarily for use internally by the
             DotNetZip library.
             </para>
             </remarks>
        </member>
        <member name="M:Ionic.Crc.CrcCalculatorStream.#ctor(System.IO.Stream)">
            <summary>
            The default constructor.
            </summary>
            <remarks>
              <para>
                Instances returned from this constructor will leave the underlying
                stream open upon Close().  The stream uses the default CRC32
                algorithm, which implies a polynomial of 0xEDB88320.
              </para>
            </remarks>
            <param name="stream">The underlying stream</param>
        </member>
        <member name="M:Ionic.Crc.CrcCalculatorStream.#ctor(System.IO.Stream,System.Boolean)">
            <summary>
              The constructor allows the caller to specify how to handle the
              underlying stream at close.
            </summary>
            <remarks>
              <para>
                The stream uses the default CRC32 algorithm, which implies a
                polynomial of 0xEDB88320.
              </para>
            </remarks>
            <param name="stream">The underlying stream</param>
            <param name="leaveOpen">true to leave the underlying stream
            open upon close of the <c>CrcCalculatorStream</c>; false otherwise.</param>
        </member>
        <member name="M:Ionic.Crc.CrcCalculatorStream.#ctor(System.IO.Stream,System.Int64)">
            <summary>
              A constructor allowing the specification of the length of the stream
              to read.
            </summary>
            <remarks>
              <para>
                The stream uses the default CRC32 algorithm, which implies a
                polynomial of 0xEDB88320.
              </para>
              <para>
                Instances returned from this constructor will leave the underlying
                stream open upon Close().
              </para>
            </remarks>
            <param name="stream">The underlying stream</param>
            <param name="length">The length of the stream to slurp</param>
        </member>
        <member name="M:Ionic.Crc.CrcCalculatorStream.#ctor(System.IO.Stream,System.Int64,System.Boolean)">
            <summary>
              A constructor allowing the specification of the length of the stream
              to read, as well as whether to keep the underlying stream open upon
              Close().
            </summary>
            <remarks>
              <para>
                The stream uses the default CRC32 algorithm, which implies a
                polynomial of 0xEDB88320.
              </para>
            </remarks>
            <param name="stream">The underlying stream</param>
            <param name="length">The length of the stream to slurp</param>
            <param name="leaveOpen">true to leave the underlying stream
            open upon close of the <c>CrcCalculatorStream</c>; false otherwise.</param>
        </member>
        <member name="M:Ionic.Crc.CrcCalculatorStream.#ctor(System.IO.Stream,System.Int64,System.Boolean,Ionic.Crc.CRC32)">
            <summary>
              A constructor allowing the specification of the length of the stream
              to read, as well as whether to keep the underlying stream open upon
              Close(), and the CRC32 instance to use.
            </summary>
            <remarks>
              <para>
                The stream uses the specified CRC32 instance, which allows the
                application to specify how the CRC gets calculated.
              </para>
            </remarks>
            <param name="stream">The underlying stream</param>
            <param name="length">The length of the stream to slurp</param>
            <param name="leaveOpen">true to leave the underlying stream
            open upon close of the <c>CrcCalculatorStream</c>; false otherwise.</param>
            <param name="crc32">the CRC32 instance to use to calculate the CRC32</param>
        </member>
        <member name="M:Ionic.Crc.CrcCalculatorStream.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Read from the stream
            </summary>
            <param name="buffer">the buffer to read</param>
            <param name="offset">the offset at which to start</param>
            <param name="count">the number of bytes to read</param>
            <returns>the number of bytes actually read</returns>
        </member>
        <member name="M:Ionic.Crc.CrcCalculatorStream.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Write to the stream.
            </summary>
            <param name="buffer">the buffer from which to write</param>
            <param name="offset">the offset at which to start writing</param>
            <param name="count">the number of bytes to write</param>
        </member>
        <member name="M:Ionic.Crc.CrcCalculatorStream.Flush">
            <summary>
            Flush the stream.
            </summary>
        </member>
        <member name="M:Ionic.Crc.CrcCalculatorStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>
            Seeking is not supported on this stream. This method always throws
            <see cref="T:System.NotSupportedException"/>
            </summary>
            <param name="offset">N/A</param>
            <param name="origin">N/A</param>
            <returns>N/A</returns>
        </member>
        <member name="M:Ionic.Crc.CrcCalculatorStream.SetLength(System.Int64)">
            <summary>
            This method always throws
            <see cref="T:System.NotSupportedException"/>
            </summary>
            <param name="value">N/A</param>
        </member>
        <member name="M:Ionic.Crc.CrcCalculatorStream.Close">
            <summary>
            Closes the stream.
            </summary>
        </member>
        <member name="P:Ionic.Crc.CrcCalculatorStream.TotalBytesSlurped">
             <summary>
               Gets the total number of bytes run through the CRC32 calculator.
             </summary>
            
             <remarks>
               This is either the total number of bytes read, or the total number of
               bytes written, depending on the direction of this stream.
             </remarks>
        </member>
        <member name="P:Ionic.Crc.CrcCalculatorStream.Crc">
            <summary>
              Provides the current CRC for all blocks slurped in.
            </summary>
            <remarks>
              <para>
                The running total of the CRC is kept as data is written or read
                through the stream.  read this property after all reads or writes to
                get an accurate CRC for the entire stream.
              </para>
            </remarks>
        </member>
        <member name="P:Ionic.Crc.CrcCalculatorStream.LeaveOpen">
            <summary>
              Indicates whether the underlying stream will be left open when the
              <c>CrcCalculatorStream</c> is Closed.
            </summary>
            <remarks>
              <para>
                Set this at any point before calling <see cref="M:Ionic.Crc.CrcCalculatorStream.Close"/>.
              </para>
            </remarks>
        </member>
        <member name="P:Ionic.Crc.CrcCalculatorStream.CanRead">
            <summary>
            Indicates whether the stream supports reading.
            </summary>
        </member>
        <member name="P:Ionic.Crc.CrcCalculatorStream.CanSeek">
            <summary>
              Indicates whether the stream supports seeking.
            </summary>
            <remarks>
              <para>
                Always returns false.
              </para>
            </remarks>
        </member>
        <member name="P:Ionic.Crc.CrcCalculatorStream.CanWrite">
            <summary>
            Indicates whether the stream supports writing.
            </summary>
        </member>
        <member name="P:Ionic.Crc.CrcCalculatorStream.Length">
            <summary>
              Returns the length of the underlying stream.
            </summary>
        </member>
        <member name="P:Ionic.Crc.CrcCalculatorStream.Position">
            <summary>
              The getter for this property returns the total bytes read.
              If you use the setter, it will throw
            <see cref="T:System.NotSupportedException"/>.
            </summary>
        </member>
        <member name="T:Ionic.BZip2.ParallelBZip2OutputStream">
             <summary>
               A write-only decorator stream that compresses data as it is
               written using the BZip2 algorithm. This stream compresses by
               block using multiple threads.
             </summary>
             <para>
               This class performs BZIP2 compression through writing.  For
               more information on the BZIP2 algorithm, see
               <see href="http://en.wikipedia.org/wiki/BZIP2"/>.
             </para>
            
             <para>
               This class is similar to <see cref="T:Ionic.BZip2.BZip2OutputStream"/>,
               except that this implementation uses an approach that employs multiple
               worker threads to perform the compression.  On a multi-cpu or multi-core
               computer, the performance of this class can be significantly higher than
               the single-threaded BZip2OutputStream, particularly for larger streams.
               How large?  Anything over 10mb is a good candidate for parallel
               compression.
             </para>
            
             <para>
               The tradeoff is that this class uses more memory and more CPU than the
               vanilla <c>BZip2OutputStream</c>. Also, for small files, the
               <c>ParallelBZip2OutputStream</c> can be much slower than the vanilla
               <c>BZip2OutputStream</c>, because of the overhead associated to using the
               thread pool.
             </para>
            
             <seealso cref="T:Ionic.BZip2.BZip2OutputStream"/>
        </member>
        <member name="M:Ionic.BZip2.ParallelBZip2OutputStream.#ctor(System.IO.Stream)">
             <summary>
               Constructs a new <c>ParallelBZip2OutputStream</c>, that sends its
               compressed output to the given output stream.
             </summary>
            
             <param name='output'>
               The destination stream, to which compressed output will be sent.
             </param>
            
             <example>
            
               This example reads a file, then compresses it with bzip2 file,
               and writes the compressed data into a newly created file.
            
               <code>
               var fname = "logfile.log";
               using (var fs = File.OpenRead(fname))
               {
                   var outFname = fname + ".bz2";
                   using (var output = File.Create(outFname))
                   {
                       using (var compressor = new Ionic.BZip2.ParallelBZip2OutputStream(output))
                       {
                           byte[] buffer = new byte[2048];
                           int n;
                           while ((n = fs.Read(buffer, 0, buffer.Length)) > 0)
                           {
                               compressor.Write(buffer, 0, n);
                           }
                       }
                   }
               }
               </code>
             </example>
        </member>
        <member name="M:Ionic.BZip2.ParallelBZip2OutputStream.#ctor(System.IO.Stream,System.Int32)">
            <summary>
              Constructs a new <c>ParallelBZip2OutputStream</c> with specified blocksize.
            </summary>
            <param name = "output">the destination stream.</param>
            <param name = "blockSize">
              The blockSize in units of 100000 bytes.
              The valid range is 1..9.
            </param>
        </member>
        <member name="M:Ionic.BZip2.ParallelBZip2OutputStream.#ctor(System.IO.Stream,System.Boolean)">
            <summary>
              Constructs a new <c>ParallelBZip2OutputStream</c>.
            </summary>
              <param name = "output">the destination stream.</param>
            <param name = "leaveOpen">
              whether to leave the captive stream open upon closing this stream.
            </param>
        </member>
        <member name="M:Ionic.BZip2.ParallelBZip2OutputStream.#ctor(System.IO.Stream,System.Int32,System.Boolean)">
             <summary>
               Constructs a new <c>ParallelBZip2OutputStream</c> with specified blocksize,
               and explicitly specifies whether to leave the wrapped stream open.
             </summary>
            
             <param name = "output">the destination stream.</param>
             <param name = "blockSize">
               The blockSize in units of 100000 bytes.
               The valid range is 1..9.
             </param>
             <param name = "leaveOpen">
               whether to leave the captive stream open upon closing this stream.
             </param>
        </member>
        <member name="M:Ionic.BZip2.ParallelBZip2OutputStream.Close">
            <summary>
              Close the stream.
            </summary>
            <remarks>
              <para>
                This may or may not close the underlying stream.  Check the
                constructors that accept a bool value.
              </para>
            </remarks>
        </member>
        <member name="M:Ionic.BZip2.ParallelBZip2OutputStream.Flush">
            <summary>
              Flush the stream.
            </summary>
        </member>
        <member name="M:Ionic.BZip2.ParallelBZip2OutputStream.Write(System.Byte[],System.Int32,System.Int32)">
             <summary>
               Write data to the stream.
             </summary>
             <remarks>
            
             <para>
               Use the <c>ParallelBZip2OutputStream</c> to compress data while
               writing: create a <c>ParallelBZip2OutputStream</c> with a writable
               output stream.  Then call <c>Write()</c> on that
               <c>ParallelBZip2OutputStream</c>, providing uncompressed data as
               input.  The data sent to the output stream will be the compressed
               form of the input data.
             </para>
            
             <para>
               A <c>ParallelBZip2OutputStream</c> can be used only for
               <c>Write()</c> not for <c>Read()</c>.
             </para>
            
             </remarks>
            
             <param name="buffer">The buffer holding data to write to the stream.</param>
             <param name="offset">the offset within that data array to find the first byte to write.</param>
             <param name="count">the number of bytes to write.</param>
        </member>
        <member name="M:Ionic.BZip2.ParallelBZip2OutputStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>
            Calling this method always throws a <see cref="T:System.NotImplementedException"/>.
            </summary>
            <param name="offset">this is irrelevant, since it will always throw!</param>
            <param name="origin">this is irrelevant, since it will always throw!</param>
            <returns>irrelevant!</returns>
        </member>
        <member name="M:Ionic.BZip2.ParallelBZip2OutputStream.SetLength(System.Int64)">
            <summary>
            Calling this method always throws a <see cref="T:System.NotImplementedException"/>.
            </summary>
            <param name="value">this is irrelevant, since it will always throw!</param>
        </member>
        <member name="M:Ionic.BZip2.ParallelBZip2OutputStream.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Calling this method always throws a <see cref="T:System.NotImplementedException"/>.
            </summary>
            <param name="buffer">this parameter is never used</param>
            <param name="offset">this parameter is never used</param>
            <param name="count">this parameter is never used</param>
            <returns>never returns anything; always throws</returns>
        </member>
        <member name="P:Ionic.BZip2.ParallelBZip2OutputStream.MaxWorkers">
             <summary>
               The maximum number of concurrent compression worker threads to use.
             </summary>
            
             <remarks>
             <para>
               This property sets an upper limit on the number of concurrent worker
               threads to employ for compression. The implementation of this stream
               employs multiple threads from the .NET thread pool, via 
               ThreadPool.QueueUserWorkItem(), to compress the incoming data by
               block.  As each block of data is compressed, this stream re-orders the
               compressed blocks and writes them to the output stream.
             </para>
            
             <para>
               A higher number of workers enables a higher degree of
               parallelism, which tends to increase the speed of compression on
               multi-cpu computers.  On the other hand, a higher number of buffer
               pairs also implies a larger memory consumption, more active worker
               threads, and a higher cpu utilization for any compression. This
               property enables the application to limit its memory consumption and
               CPU utilization behavior depending on requirements.
             </para>
            
             <para>
               By default, DotNetZip allocates 4 workers per CPU core, subject to the
               upper limit specified in this property. For example, suppose the
               application sets this property to 16.  Then, on a machine with 2
               cores, DotNetZip will use 8 workers; that number does not exceed the
               upper limit specified by this property, so the actual number of
               workers used will be 4 * 2 = 8.  On a machine with 4 cores, DotNetZip
               will use 16 workers; again, the limit does not apply. On a machine
               with 8 cores, DotNetZip will use 16 workers, because of the limit.
             </para>
            
             <para>
               For each compression "worker thread" that occurs in parallel, there is
               up to 2mb of memory allocated, for buffering and processing. The
               actual number depends on the <see cref="P:Ionic.BZip2.ParallelBZip2OutputStream.BlockSize"/> property.
             </para>
            
             <para>
               CPU utilization will also go up with additional workers, because a
               larger number of buffer pairs allows a larger number of background
               threads to compress in parallel. If you find that parallel
               compression is consuming too much memory or CPU, you can adjust this
               value downward.
             </para>
            
             <para>
               The default value is 16. Different values may deliver better or
               worse results, depending on your priorities and the dynamic
               performance characteristics of your storage and compute resources.
             </para>
            
             <para>
               The application can set this value at any time, but it is effective
               only before the first call to Write(), which is when the buffers are
               allocated.
             </para>
             </remarks>
        </member>
        <member name="P:Ionic.BZip2.ParallelBZip2OutputStream.BlockSize">
            <summary>
              The blocksize parameter specified at construction time.
            </summary>
        </member>
        <member name="P:Ionic.BZip2.ParallelBZip2OutputStream.CanRead">
            <summary>
            Indicates whether the stream can be read.
            </summary>
            <remarks>
            The return value is always false.
            </remarks>
        </member>
        <member name="P:Ionic.BZip2.ParallelBZip2OutputStream.CanSeek">
            <summary>
            Indicates whether the stream supports Seek operations.
            </summary>
            <remarks>
            Always returns false.
            </remarks>
        </member>
        <member name="P:Ionic.BZip2.ParallelBZip2OutputStream.CanWrite">
            <summary>
            Indicates whether the stream can be written.
            </summary>
            <remarks>
            The return value depends on whether the captive stream supports writing.
            </remarks>
        </member>
        <member name="P:Ionic.BZip2.ParallelBZip2OutputStream.Length">
            <summary>
            Reading this property always throws a <see cref="T:System.NotImplementedException"/>.
            </summary>
        </member>
        <member name="P:Ionic.BZip2.ParallelBZip2OutputStream.Position">
             <summary>
             The position of the stream pointer.
             </summary>
            
             <remarks>
               Setting this property always throws a <see cref="T:System.NotImplementedException"/>. Reading will return the
               total number of uncompressed bytes written through.
             </remarks>
        </member>
        <member name="P:Ionic.BZip2.ParallelBZip2OutputStream.BytesWrittenOut">
            <summary>
            The total number of bytes written out by the stream.
            </summary>
            <remarks>
            This value is meaningful only after a call to Close().
            </remarks>
        </member>
        <member name="M:Ionic.BZip2.Rand.Rnums(System.Int32)">
            <summary>
              Returns the "random" number at a specific index.
            </summary>
            <param name='i'>the index</param>
            <returns>the random number</returns>
        </member>
        <member name="T:IronPython.Modules.ResourceMetaPathImporter">
            <summary>
            Implementes a resource-based meta_path importer as described in PEP 302.
            </summary>
        </member>
        <member name="M:IronPython.Modules.ResourceMetaPathImporter.#ctor(System.Reflection.Assembly,System.String)">
            <summary>
            Instantiates a new meta_path importer using an embedded ZIP resource file.
            </summary>
            <param name="fromAssembly"></param>
            <param name="resourceName"></param>
        </member>
        <member name="F:IronPython.Runtime.ZipImportModule.zipimporter._search_order">
            <summary>
            zip_searchorder defines how we search for a module in the Zip
            archive: we first search for a package __init__, then for
            non-package .pyc, .pyo and .py entries. The .pyc and .pyo entries
            are swapped by initzipimport() if we run in optimized mode. Also,
            '/' is replaced by SEP there.
            </summary>
        </member>
        <member name="M:IronPython.Runtime.ZipImportModule.zipimporter.GetData(System.String,IronPython.Runtime.PythonTuple)">
            <summary>
            Given a path to a Zip file and a toc_entry, return the (uncompressed)
            data as a new reference.
            </summary>
            <param name="archive"></param>
            <param name="toc_entry"></param>
            <returns></returns>
        </member>
        <member name="M:IronPython.Runtime.ZipImportModule.zipimporter.GetCodeFromData(IronPython.Runtime.CodeContext,System.Boolean,System.Boolean,System.Int32,IronPython.Runtime.PythonTuple)">
            <summary>
            Return the code object for the module named by 'fullname' from the
            Zip archive as a new reference.
            </summary>
            <param name="context"></param>
            <param name="ispackage"></param>
            <param name="isbytecode"></param>
            <param name="mtime"></param>
            <param name="toc_entry"></param>
            <returns></returns>
        </member>
        <member name="M:IronPython.Runtime.ZipImportModule.zipimporter.ReadDirectory(System.String)">
            <summary>
            Given a path to a Zip archive, build a dict, mapping file names
            (local to the archive, using SEP as a separator) to toc entries.
            
            A toc_entry is a tuple:
            (__file__,      # value to use for __file__, available for all files
             compress,      # compression kind; 0 for uncompressed
             data_size,     # size of compressed data on disk
             file_size,     # size of decompressed data
             file_offset,   # offset of file header from start of archive
             time,          # mod time of file (in dos format)
             date,          # mod data of file (in dos format)
             crc,           # crc checksum of the data
             )
            Directories can be recognized by the trailing SEP in the name,
            data_size and file_offset are 0.
            </summary>
            <param name="archive"></param>
            <returns></returns>
        </member>
        <member name="M:IronPython.Runtime.ZipImportModule.zipimporter.MakeFilename(System.String,System.String)">
            <summary>
            Given a (sub)modulename, write the potential file path in the
            archive (without extension) to the path buffer. 
            </summary>
            <param name="prefix"></param>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:IronPython.Runtime.ZipImportModule.zipimporter.GetModuleInfo(IronPython.Runtime.CodeContext,System.String)">
            <summary>
            Determines the type of module we have (package or module, or not found).
            </summary>
            <param name="context"></param>
            <param name="fullname"></param>
            <returns></returns>
        </member>
        <member name="T:IronPython.Runtime.ZipImportModule.SourceStringContentProvider">
            <summary>
            Provides a StreamContentProvider for a stream of content backed by a file on disk.
            </summary>
        </member>
        <member name="T:ComponentAce.Compression.Libs.ZLib.Adler32">
            <summary>
            This class represents adler32 checksum algorithm
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.Adler32.GetAdler32Checksum(System.Int64,System.Byte[],System.Int32,System.Int32)">
            <summary>
            This static method returns adler32 checksum of the buffer data
            </summary>
        </member>
        <member name="T:ComponentAce.Compression.Libs.ZLib.Deflate">
            <summary>
            Implementation of the Deflate compression algorithm.
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.MAX_MEM_LEVEL">
            <summary>
            Maximum memory level
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.Z_DEFAULT_COMPRESSION">
            <summary>
            Defalult compression method
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.DEF_MEM_LEVEL">
            <summary>
            Default memory level
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.NeedMore">
            <summary>
            block not completed, need more input or more output
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.BlockDone">
            <summary>
            Block internalFlush performed
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.FinishStarted">
            <summary>
            Finish started, need only more output at next deflate
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.FinishDone">
            <summary>
            finish done, accept no more input or output
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.PRESET_DICT">
            <summary>
            preset dictionary flag in zlib header
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.Z_DEFLATED">
            <summary>
            The deflate compression method
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.Buf_size">
            <summary>
            The size of the buffer
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.REP_3_6">
            <summary>
            repeat previous bit length 3-6 times (2 bits of repeat count)
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.REPZ_3_10">
            <summary>
            repeat a zero length 3-10 times  (3 bits of repeat count)
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.REPZ_11_138">
            <summary>
            repeat a zero length 11-138 times  (7 bits of repeat count)
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.config_table">
            <summary>
            Deflate class congiration table
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.strm">
            <summary>
            Pointer back to this zlib stream
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.status">
            <summary>
            As the name implies
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.pending_buf">
            <summary>
            Output still pending
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.pending_buf_size">
            <summary>
            Size of Pending_buf
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.pending_out">
            <summary>
            Next pending byte to output to the stream
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.pending">
            <summary>
            Number of bytes in the pending buffer
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.noheader">
            <summary>
            suppress zlib header and adler32
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.data_type">
            <summary>
            UNKNOWN, BINARY or ASCII
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.method">
            <summary>
            STORED (for zip only) or DEFLATED
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.last_flush">
            <summary>
            Value of internalFlush parameter for previous deflate call
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.w_size">
            <summary>
            LZ77 Window size (32K by default)
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.w_bits">
            <summary>
            log2(w_size)  (8..16)
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.w_mask">
            <summary>
            w_size - 1
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.window">
            <summary>
            Sliding Window. Input bytes are ReadPos into the second half of the Window,
            and move to the first half later to keep a dictionary of at least wSize
            bytes. With this organization, matches are limited to a distance of
            wSize-MAX_MATCH bytes, but this ensures that IO is always
            performed with a length multiple of the block size. Also, it limits
            the Window size to 64K, which is quite useful on MSDOS.
            To do: use the user input buffer as sliding Window.
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.window_size">
            <summary>
            Actual size of Window: 2*wSize, except when the user input buffer is directly used as sliding Window.
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.prev">
            <summary>
            Link to older string with same hash index. To limit the size of this
            array to 64K, this link is maintained only for the last 32K strings.
            An index in this array is thus a Window index modulo 32K.
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.head">
            <summary>
            Heads of the hash chains or NIL.
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.ins_h">
            <summary>
            hash index of string to be inserted
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.hash_size">
            <summary>
            number of elements in hash table
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.hash_bits">
            <summary>
            log2(hash_size)
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.hash_mask">
            <summary>
            hash_size-1
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.hash_shift">
            <summary>
            Number of bits by which ins_h must be shifted at each input
            step. It must be such that after MIN_MATCH steps, the oldest
            byte no longer takes part in the hash key, that is:
            hash_shift * MIN_MATCH >= hash_bits
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.block_start">
            <summary>
            Window position at the beginning of the current output block. Gets negative when the Window is moved backwards.
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.match_length">
            <summary>
            length of best match
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.prev_match">
            <summary>
            previous match
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.match_available">
            <summary>
            set if previous match exists
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.strstart">
            <summary>
            start of string to insert
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.match_start">
            <summary>
            start of matching string
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.lookahead">
            <summary>
            number of valid bytes ahead in Window
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.prev_length">
            <summary>
            Length of the best match at previous step. Matches not greater than this
            are discarded. This is used in the lazy match evaluation.
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.max_chain_length">
            <summary>
            To speed up deflation, hash chains are never searched beyond this
            length.  A higher limit improves compression ratio but degrades the speed.
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.max_lazy_match">
            <summary>
            Attempt to find a better match only when the current match is strictly
            smaller than this value. This mechanism is used only for compression
            levels >= 4.
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate._level">
            <summary>
            compression level (1..9)
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.strategy">
            <summary>
            favor or force Huffman coding
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.good_match">
            <summary>
            Use a faster search when the previous match is longer than this
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.nice_match">
            <summary>
            Stop searching when current match exceeds this
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.dyn_ltree">
            <summary>
            literal and length tree
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.dyn_dtree">
            <summary>
            distance tree
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.bl_tree">
            <summary>
             Huffman tree for bit lengths
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.l_desc">
            <summary>
            Desc for literal tree
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.d_desc">
            <summary>
            desc for distance tree
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.bl_desc">
            <summary>
            desc for bit length tree
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.bl_count">
            <summary>
            number of codes at each bit length for an optimal tree
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.heap">
            <summary>
            heap used to build the Huffman trees
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.heap_len">
            <summary>
            number of elements in the heap
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.heap_max">
            <summary>
            element of largest frequency
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.depth">
            <summary>
            Depth of each subtree used as tie breaker for trees of equal frequency
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.l_buf">
            <summary>
            index for literals or lengths
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.lit_bufsize">
            <summary>
             Size of match buffer for literals/lengths.  There are 4 reasons for
             limiting lit_bufsize to 64K:
               - frequencies can be kept in 16 bit counters
               - if compression is not successful for the first block, all input
                 data is still in the Window so we can still emit a stored block even
                 when input comes from standard input.  (This can also be done for
                 all blocks if lit_bufsize is not greater than 32K.)
               - if compression is not successful for a file smaller than 64K, we can
                 even emit a stored file instead of a stored block (saving 5 bytes).
                 This is applicable only for zip (not gzip or zlib).
               - creating new Huffman trees less frequently may not provide fast
                 adaptation to changes in the input data statistics. (Take for
                 example a binary file with poorly compressible code followed by
                 a highly compressible string table.) Smaller buffer sizes give
                 fast adaptation but have of course the overhead of transmitting
                 trees more frequently.
               - I can't count above 4
            </summary> 
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.last_lit">
            <summary>
            running index in l_buf
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.d_buf">
            <summary>
            index of pendig_buf
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.opt_len">
            <summary>
            bit length of current block with optimal trees
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.static_len">
            <summary>
            bit length of current block with static trees
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.matches">
            <summary>
            number of string matches in current block
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.last_eob_len">
            <summary>
            bit length of EOB code for last block
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.bi_buf">
            <summary>
            Output buffer. bits are inserted starting at the bottom (least
            significant bits).
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.bi_valid">
            <summary>
            Number of valid bits in bi_buf.  All bits above the last valid bit
            are always zero.
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.Deflate.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.Deflate.lm_init">
            <summary>
            Initialization
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.Deflate.tr_init">
            <summary>
            Initialize the tree data structures for a new zlib stream.
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.Deflate.init_block">
            <summary>
            Initializes block
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.Deflate.pqdownheap(System.Int16[],System.Int32)">
            <summary>
             Restore the heap property by moving down the tree starting at node k,
             exchanging a node with the smallest of its two sons if necessary, stopping
             when the heap property is re-established (each father smaller than its
             two sons).
             </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.Deflate.scan_tree(System.Int16[],System.Int32)">
            <summary>
             Scan a literal or distance tree to determine the frequencies of the codes
             in the bit length tree.
             </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.Deflate.build_bl_tree">
            <summary>
             Construct the Huffman tree for the bit lengths and return the index in
             bl_order of the last bit length code to send.
             </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.Deflate.send_all_trees(System.Int32,System.Int32,System.Int32)">
            <summary>
             Send the header for a block using dynamic Huffman trees: the counts, the
             lengths of the bit length codes, the literal tree and the distance tree.
             IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.
             </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.Deflate.send_tree(System.Int16[],System.Int32)">
            <summary>
             Send a literal or distance tree in compressed form, using the codes in
             bl_tree.
             </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.Deflate.put_byte(System.Byte[],System.Int32,System.Int32)">
            <summary>
             Output a byte on the stream.
             IN assertion: there is enough room in Pending_buf.
             </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.Deflate.put_byte(System.Byte)">
            <summary>
            Adds a byte to the buffer
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.Deflate._tr_align">
            <summary>
             Send one empty static block to give enough lookahead for inflate.
             This takes 10 bits, of which 7 may remain in the bit buffer.
             The current inflate code requires 9 bits of lookahead. If the
             last two codes for the previous block (real code plus EOB) were coded
             on 5 bits or less, inflate may have only 5+3 bits of lookahead to decode
             the last real code. In this case we send two empty static blocks instead
             of one. (There are no problems if the previous block is stored or fixed.)
             To simplify the code, we assume the worst case of last real code encoded
             on one bit only.
             </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.Deflate._tr_tally(System.Int32,System.Int32)">
            <summary>
            Save the match info and tally the frequency counts. Return true if
            the current block must be flushed.
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.Deflate.compress_block(System.Int16[],System.Int16[])">
            <summary>
             Send the block data compressed using the given Huffman trees
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.Deflate.set_data_type">
            <summary>
            Set the data type to ASCII or BINARY, using a crude approximation:
            binary if more than 20% of the bytes are &lt;= 6 or &gt;= 128, ascii otherwise.
            IN assertion: the fields freq of dyn_ltree are set and the total of all
            frequencies does not exceed 64K (to fit in an int on 16 bit machines).
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.Deflate.bi_flush">
            <summary>
            Flush the bit buffer, keeping at most 7 bits in it.
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.Deflate.bi_windup">
            <summary>
            Flush the bit buffer and align the output on a byte boundary
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.Deflate.copy_block(System.Int32,System.Int32,System.Boolean)">
            <summary>
            Copy a stored block, storing first the length and its
            one's complement if requested.
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.Deflate.flush_block_only(System.Boolean)">
            <summary>
            Flushes block
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.Deflate.deflate_stored(System.Int32)">
            <summary>
            Copy without compression as much as possible from the input stream, return
            the current block state.
            This function does not insert new strings in the dictionary since
            uncompressible data is probably not useful. This function is used
            only for the level=0 compression option.
            NOTE: this function should be optimized to avoid extra copying from
            Window to Pending_buf.
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.Deflate._tr_stored_block(System.Int32,System.Int32,System.Boolean)">
            <summary>
            Send a stored block
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.Deflate._tr_flush_block(System.Int32,System.Int32,System.Boolean)">
            <summary>
            Determine the best encoding for the current block: dynamic trees, static
            trees or store, and output the encoded block to the zip file.
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.Deflate.fill_window">
            <summary>
             Fill the Window when the lookahead becomes insufficient.
             Updates strstart and lookahead.
            
             IN assertion: lookahead less than MIN_LOOKAHEAD
             OUT assertions: strstart less than or equal to window_size-MIN_LOOKAHEAD
                At least one byte has been ReadPos, or _avail_in == 0; reads are
                performed for at least two bytes (required for the zip translate_eol
                option -- not supported here).
             </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.Deflate.deflate_fast(System.Int32)">
            <summary>
             Compress as much as possible from the input stream, return the current
             block state.
             This function does not perform lazy evaluation of matches and inserts
             new strings in the dictionary only for unmatched strings or for short
             matches. It is used only for the fast compression options.
             </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.Deflate.deflate_slow(System.Int32)">
            <summary>
             Same as above, but achieves better compression. We use a lazy
             evaluation for matches: a match is finally adopted only if there is
             no better match at the next Window position.
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.Deflate.longest_match(System.Int32)">
            <summary>
            Finds the longest matching data part
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.Deflate.deflateInit(ComponentAce.Compression.Libs.ZLib.ZStream,System.Int32,System.Int32)">
            <summary>
            Deflate algorithm initialization
            </summary>
            <param name="strm">ZStream object</param>
            <param name="level">Compression level</param>
            <param name="bits">Window bits</param>
            <returns>A result code</returns>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.Deflate.deflateInit(ComponentAce.Compression.Libs.ZLib.ZStream,System.Int32)">
            <summary>
            Initializes deflate algorithm
            </summary>
            <param name="strm">ZStream object</param>
            <param name="level">Compression level</param>
            <returns>Operation result result code</returns>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.Deflate.deflateInit2(ComponentAce.Compression.Libs.ZLib.ZStream,System.Int32,System.Int32,System.Int32,System.Int32,ComponentAce.Compression.Libs.ZLib.CompressionStrategy)">
            <summary>
            Deflate algorithm initialization
            </summary>
            <param name="strm">ZStream object</param>
            <param name="level">Compression level</param>
            <param name="method">Compression method</param>
            <param name="windowBits">Window bits</param>
            <param name="memLevel">Memory level</param>
            <param name="strategy">Compression strategy</param>
            <returns>Operation result code</returns>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.Deflate.deflateReset(ComponentAce.Compression.Libs.ZLib.ZStream)">
            <summary>
            Resets the current state of deflate object
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.Deflate.deflateEnd">
            <summary>
            Finish compression with deflate algorithm
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.Deflate.deflateParams(ComponentAce.Compression.Libs.ZLib.ZStream,System.Int32,ComponentAce.Compression.Libs.ZLib.CompressionStrategy)">
            <summary>
            Sets deflate algorithm parameters
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.Deflate.deflateSetDictionary(ComponentAce.Compression.Libs.ZLib.ZStream,System.Byte[],System.Int32)">
            <summary>
            Sets deflate dictionary
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.Deflate.deflate(ComponentAce.Compression.Libs.ZLib.ZStream,ComponentAce.Compression.Libs.ZLib.FlushStrategy)">
            <summary>
            Performs data compression with the deflate algorithm
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.Deflate.#cctor">
            <summary>
            Static constructor initializes config_table
            </summary>
        </member>
        <member name="P:ComponentAce.Compression.Libs.ZLib.Deflate.level">
            <summary>
            Compression level
            </summary>
        </member>
        <member name="P:ComponentAce.Compression.Libs.ZLib.Deflate.Pending">
            <summary>
            Number of bytes in the pending buffer
            </summary>
        </member>
        <member name="P:ComponentAce.Compression.Libs.ZLib.Deflate.Pending_buf">
            <summary>
            Output still pending
            </summary>
        </member>
        <member name="P:ComponentAce.Compression.Libs.ZLib.Deflate.Pending_out">
            <summary>
            Next pending byte to output to the stream
            </summary>
        </member>
        <member name="P:ComponentAce.Compression.Libs.ZLib.Deflate.NoHeader">
            <summary>
            suppress zlib header and adler32
            </summary>
        </member>
        <member name="T:ComponentAce.Compression.Libs.ZLib.Deflate.Config">
            <summary>
            Deflate algorithm configuration parameters class
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.Config.good_length">
            <summary>
            reduce lazy search above this match length
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.Config.max_lazy">
            <summary>
            do not perform lazy search above this match length
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.Config.nice_length">
            <summary>
            quit search above this match length
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.Deflate.Config.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Constructor which initializes class inner fields
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.InfBlocks.mode">
            <summary>
            current inflate_block mode 
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.InfBlocks.left">
            <summary>
            if STORED, bytes left to copy 
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.InfBlocks.table">
            <summary>
            table lengths (14 bits) 
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.InfBlocks.index">
            <summary>
            index into blens (or border) 
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.InfBlocks.blens">
            <summary>
            bit lengths of codes 
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.InfBlocks.bb">
            <summary>
            bit length tree depth 
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.InfBlocks.tb">
            <summary>
            bit length decoding tree 
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.InfBlocks.codes">
            <summary>
            if CODES, current state 
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.InfBlocks.last">
            <summary>
            true if this block is the last block 
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.InfBlocks.bitk">
            <summary>
            bits in bit buffer 
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.InfBlocks.bitb">
            <summary>
            bit buffer 
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.InfBlocks.hufts">
            <summary>
            single malloc for tree space 
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.InfBlocks.window">
            <summary>
            sliding Window 
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.InfBlocks.end">
            <summary>
            one byte after sliding Window 
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.InfBlocks.read">
            <summary>
            Window ReadPos pointer 
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.InfBlocks.write">
            <summary>
            Window WritePos pointer 
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.InfBlocks.needCheck">
            <summary>
            need check
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.InfBlocks.check">
            <summary>
            check on output 
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.InfBlocks.reset(ComponentAce.Compression.Libs.ZLib.ZStream,System.Int64[])">
            <summary>
            Resets this InfBlocks class instance
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.InfBlocks.proc(ComponentAce.Compression.Libs.ZLib.ZStream,System.Int32)">
            <summary>
            Block processing functions
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.InfBlocks.free(ComponentAce.Compression.Libs.ZLib.ZStream)">
            <summary>
            Frees inner buffers
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.InfBlocks.set_dictionary(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Sets dictionary
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.InfBlocks.sync_point">
            <summary>
             Returns true if inflate is currently at the End of a block generated
             by Z_SYNC_FLUSH or Z_FULL_FLUSH. 
             </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.InfBlocks.inflate_flush(ComponentAce.Compression.Libs.ZLib.ZStream,System.Int32)">
            <summary>
            copy as much as possible from the sliding Window to the output area
            </summary>
        </member>
        <member name="P:ComponentAce.Compression.Libs.ZLib.InfBlocks.Window">
            <summary>
            sliding window 
            </summary>
        </member>
        <member name="P:ComponentAce.Compression.Libs.ZLib.InfBlocks.End">
            <summary>
            one byte after sliding Window 
            </summary>
        </member>
        <member name="P:ComponentAce.Compression.Libs.ZLib.InfBlocks.ReadPos">
            <summary>
            Window ReadPos pointer 
            </summary>
        </member>
        <member name="P:ComponentAce.Compression.Libs.ZLib.InfBlocks.WritePos">
            <summary>
            Window WritePos pointer 
            </summary>
        </member>
        <member name="P:ComponentAce.Compression.Libs.ZLib.InfBlocks.BitK">
            <summary>
            bits in bit buffer 
            </summary>
        </member>
        <member name="P:ComponentAce.Compression.Libs.ZLib.InfBlocks.BitB">
            <summary>
            bit buffer 
            </summary>
        </member>
        <member name="T:ComponentAce.Compression.Libs.ZLib.InflateCodesMode">
            <summary>
            Inflate codes mode
            </summary>
        </member>
        <member name="T:ComponentAce.Compression.Libs.ZLib.InfCodes">
            <summary>
            This class is used by the InfBlocks class
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.InfCodes.mode">
            <summary>
            current inflate_codes mode
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.InfCodes.count">
            <summary>
            length
            </summary>        
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.InfCodes.tree">
            <summary>
            pointer into tree
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.InfCodes.tree_index">
            <summary>
            current index of the tree
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.InfCodes.need">
            <summary>
            
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.InfCodes.lbits">
            <summary>
            ltree bits decoded per branch
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.InfCodes.dbits">
            <summary>
            dtree bits decoded per branch
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.InfCodes.ltree">
            <summary>
            literal/length/eob tree
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.InfCodes.ltree_index">
            <summary>
            literal/length/eob tree index
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.InfCodes.dtree">
            <summary>
            distance tree
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.InfCodes.dtree_index">
            <summary>
            distance tree index
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.InfCodes.#ctor(System.Int32,System.Int32,System.Int32[],System.Int32,System.Int32[],System.Int32,ComponentAce.Compression.Libs.ZLib.ZStream)">
            <summary>
            Constructor which takes literal, distance trees, corresponding bites decoded for branches, corresponding indexes and a ZStream object 
            </summary>        
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.InfCodes.#ctor(System.Int32,System.Int32,System.Int32[],System.Int32[],ComponentAce.Compression.Libs.ZLib.ZStream)">
            <summary>
            Constructor which takes literal, distance trees, corresponding bites decoded for branches and a ZStream object 
            </summary>   
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.InfCodes.proc(ComponentAce.Compression.Libs.ZLib.InfBlocks,ComponentAce.Compression.Libs.ZLib.ZStream,System.Int32)">
            <summary>
            Block processing method
            </summary>
            <param name="s">An instance of the InfBlocks class</param>
            <param name="z">A ZStream object</param>
            <param name="r">A result code</param>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.InfCodes.free(ComponentAce.Compression.Libs.ZLib.ZStream)">
            <summary>
            Frees allocated resources
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.InfCodes.inflate_fast(System.Int32,System.Int32,System.Int32[],System.Int32,System.Int32[],System.Int32,ComponentAce.Compression.Libs.ZLib.InfBlocks,ComponentAce.Compression.Libs.ZLib.ZStream)">
            <summary>
            Fast inflate procedure. Called with number of bytes left to WritePos in Window at least 258
            (the maximum string length) and number of input bytes available
            at least ten.  The ten bytes are six bytes for the longest length/
            distance pair plus four bytes for overloading the bit buffer.
            </summary>
        </member>
        <member name="T:ComponentAce.Compression.Libs.ZLib.InflateMode">
            <summary>
            This enumeration contains modes of inflate processing
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.InflateMode.METHOD">
            <summary>
            waiting for method byte
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.InflateMode.FLAG">
            <summary>
            waiting for flag byte
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.InflateMode.DICT4">
            <summary>
            four dictionary check bytes to go
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.InflateMode.DICT3">
            <summary>
            three dictionary check bytes to go
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.InflateMode.DICT2">
            <summary>
            two dictionary check bytes to go
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.InflateMode.DICT1">
            <summary>
            one dictionary check byte to go
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.InflateMode.DICT0">
            <summary>
            waiting for inflateSetDictionary
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.InflateMode.BLOCKS">
            <summary>
            decompressing blocks
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.InflateMode.CHECK4">
            <summary>
            four check bytes to go
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.InflateMode.CHECK3">
            <summary>
            three check bytes to go
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.InflateMode.CHECK2">
            <summary>
            two check bytes to go
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.InflateMode.CHECK1">
            <summary>
            one check byte to go
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.InflateMode.DONE">
            <summary>
            finished check, done
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.InflateMode.BAD">
            <summary>
            got an error--stay here
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Inflate.mode">
            <summary>
            current inflate mode
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Inflate.method">
            <summary>
            if FLAGS, method byte
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Inflate.was">
            <summary>
            computed check value
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Inflate.need">
            <summary>
            stream check value
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Inflate.marker">
            <summary>
            if BAD, inflateSync's marker bytes count
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Inflate.nowrap">
            <summary>
            flag for no wrapper
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Inflate.wbits">
            <summary>
            log2(Window size)  (8..15, defaults to 15)
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Inflate.blocks">
            <summary>
            current inflate_blocks state
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.Inflate.inflateReset(ComponentAce.Compression.Libs.ZLib.ZStream)">
            <summary>
            Resets the Inflate algorithm
            </summary>
            <param name="z">A ZStream object</param>
            <returns>A result code</returns>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.Inflate.inflateEnd(ComponentAce.Compression.Libs.ZLib.ZStream)">
            <summary>
            Finishes the inflate algorithm processing
            </summary>
            <param name="z">A ZStream object</param>
            <returns>Operation result code</returns>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.Inflate.inflateInit(ComponentAce.Compression.Libs.ZLib.ZStream,System.Int32)">
            <summary>
            Initializes the inflate algorithm
            </summary>
            <param name="z">A ZStream object</param>
            <param name="windowBits">Window size</param>
            <returns>Operation result code</returns>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.Inflate.inflate(ComponentAce.Compression.Libs.ZLib.ZStream,ComponentAce.Compression.Libs.ZLib.FlushStrategy)">
            <summary>
            Runs inflate algorithm
            </summary>
            <param name="z">A ZStream object</param>
            <param name="flush">Flush strategy</param>
            <returns>Operation result code</returns>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.Inflate.inflateSetDictionary(ComponentAce.Compression.Libs.ZLib.ZStream,System.Byte[],System.Int32)">
            <summary>
            Sets dictionary for the inflate operation
            </summary>
            <param name="z">A ZStream object</param>
            <param name="dictionary">An array of byte - dictionary</param>
            <param name="dictLength">Dictionary length</param>
            <returns>Operation result code</returns>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.Inflate.inflateSync(ComponentAce.Compression.Libs.ZLib.ZStream)">
            <summary>
            Inflate synchronization
            </summary>
            <param name="z">A ZStream object</param>
            <returns>Operation result code</returns>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.Inflate.inflateSyncPoint(ComponentAce.Compression.Libs.ZLib.ZStream)">
            <summary>
             Returns true if inflate is currently at the End of a block generated
             by Z_SYNC_FLUSH or Z_FULL_FLUSH. This function is used by one PPP
             implementation to provide an additional safety check. PPP uses Z_SYNC_FLUSH
             but removes the length bytes of the resulting empty stored block. When
             decompressing, PPP checks that at the End of input packet, inflate is
             waiting for these length bytes.
             </summary>
        </member>
        <member name="T:ComponentAce.Compression.Libs.ZLib.InfTreeUtil">
            <summary>
            Contains utility information for the InfTree class
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.InfTree.huft_build(System.Int32[],System.Int32,System.Int32,System.Int32,System.Int32[],System.Int32[],System.Int32[],System.Int32[],System.Int32[],System.Int32[],System.Int32[])">
            <summary>
            Given a list of code lengths and a maximum table size, make a set of
            tables to decode that set of codes.  
            </summary>
            <returns>Return (int)ZLibResultCode.Z_OK on success, (int)ZLibResultCode.Z_DATA_ERROR if the given code set is incomplete (the tables are still built in this case), (int)ZLibResultCode.Z_DATA_ERROR if the input is invalid (an over-subscribed set of lengths), or (int)ZLibResultCode.Z_DATA_ERROR if not enough memory.
            </returns>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.InfTree.inflate_trees_bits(System.Int32[],System.Int32[],System.Int32[],System.Int32[],ComponentAce.Compression.Libs.ZLib.ZStream)">
            <summary>
            Build trees
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.InfTree.inflate_trees_dynamic(System.Int32,System.Int32,System.Int32[],System.Int32[],System.Int32[],System.Int32[],System.Int32[],System.Int32[],ComponentAce.Compression.Libs.ZLib.ZStream)">
            <summary>
            Builds dynamic trees
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.InfTree.inflate_trees_fixed(System.Int32[],System.Int32[],System.Int32[][],System.Int32[][],ComponentAce.Compression.Libs.ZLib.ZStream)">
            <summary>
            Build fixed trees
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.StaticTree.MAX_BL_BITS">
            <summary>
             Bit length codes must not exceed MAX_BL_BITS bits
            </summary>
        </member>
        <member name="T:ComponentAce.Compression.Libs.ZLib.Tree">
            <summary>
            This class represents a tree and is used in the Deflate class
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Tree.dyn_tree">
            <summary>
            The dynamic tree
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Tree.max_code">
            <summary>
            Largest code with non zero frequency
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Tree.stat_desc">
            <summary>
            the corresponding static tree
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.Tree.d_code(System.Int32)">
            <summary>
            Mapping from a distance to a distance code. dist is the distance - 1 and
            must not have side effects. _dist_code[256] and _dist_code[257] are never
            used.
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.Tree.gen_bitlen(ComponentAce.Compression.Libs.ZLib.Deflate)">
            <summary>
             Compute the optimal bit lengths for a tree and update the total bit length
             for the current block.
             IN assertion: the fields freq and dad are set, heap[heap_max] and
                above are the tree nodes sorted by increasing frequency.
             OUT assertions: the field count is set to the optimal bit length, the
                 array bl_count contains the frequencies for each bit length.
                 The length opt_len is updated; static_len is also updated if stree is
                 not null.
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.Tree.build_tree(ComponentAce.Compression.Libs.ZLib.Deflate)">
            <summary>
             Construct one Huffman tree and assigns the code bit strings and lengths.
             Update the total bit length for the current block.
             IN assertion: the field freq is set for all tree elements.
             OUT assertions: the fields count and code are set to the optimal bit length
                 and corresponding code. The length opt_len is updated; static_len is
                 also updated if stree is not null. The field max_code is set.
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.Tree.gen_codes(System.Int16[],System.Int32,System.Int16[])">
            <summary>
             Generate the codes for a given tree and bit counts (which need not be
             optimal).
             IN assertion: the array bl_count contains the bit length statistics for
             the given tree and the field count is set for all tree elements.
             OUT assertion: the field code is set for all tree elements of non
                 zero code length.
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.Tree.bi_reverse(System.Int32,System.Int32)">
            <summary>
             Reverse the first count bits of a code, using straightforward code (a faster
             method would use a table)
            </summary>
        </member>
        <member name="P:ComponentAce.Compression.Libs.ZLib.Tree.DynTree">
            <summary>
            The dynamic tree
            </summary>
        </member>
        <member name="P:ComponentAce.Compression.Libs.ZLib.Tree.MaxCode">
            <summary>
            Largest code with non zero frequency
            </summary>
        </member>
        <member name="P:ComponentAce.Compression.Libs.ZLib.Tree.StatDesc">
            <summary>
            the corresponding static tree
            </summary>
        </member>
        <member name="T:ComponentAce.Compression.Libs.ZLib.ZLibCompressionLevel">
            <summary>
            Some constants for specifying compression levels. Methods which takes a compression level as a parameter expects an integer value from 0 to 9. You can either specify an integer value or use constants for some most widely used compression levels.
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.ZLibCompressionLevel.Z_NO_COMPRESSION">
            <summary>
             No compression should be used at all.
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.ZLibCompressionLevel.Z_BEST_SPEED">
            <summary>
            Minimal compression, but greatest speed.
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.ZLibCompressionLevel.Z_BEST_COMPRESSION">
            <summary>
            Maximum compression, but slowest.
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.ZLibCompressionLevel.Z_DEFAULT_COMPRESSION">
            <summary>
            Select default compression level (good compression, good speed).
            </summary>
        </member>
        <member name="T:ComponentAce.Compression.Libs.ZLib.CompressionStrategy">
            <summary>
            Compression strategies. The strategy parameter is used to tune the compression algorithm. The strategy parameter only affects the compression ratio but not the correctness of the compressed output even if it is not set appropriately.
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.CompressionStrategy.Z_FILTERED">
            <summary>
            This strategy is designed for filtered data. Data which consists of mostly small values, with random distribution should use Z_FILTERED. With this strategy, less string matching is performed.
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.CompressionStrategy.Z_HUFFMAN_ONLY">
            <summary>
            Z_HUFFMAN_ONLY forces Huffman encoding only (no string match)
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.CompressionStrategy.Z_DEFAULT_STRATEGY">
            <summary>
            The default strategy is the most commonly used. With this strategy, string matching and huffman compression are balanced.
            </summary>
        </member>
        <member name="T:ComponentAce.Compression.Libs.ZLib.FlushStrategy">
            <summary>
            Flush strategies
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.FlushStrategy.Z_NO_FLUSH">
            <summary>
              Do not internalFlush data, but just write data as normal to the output buffer. This is the normal way in which data is written to the output buffer.
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.FlushStrategy.Z_PARTIAL_FLUSH">
            <summary>
            Obsolete. You should use Z_SYNC_FLUSH instead.
            </summary>        
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.FlushStrategy.Z_SYNC_FLUSH">
            <summary>
            All pending output is flushed to the output buffer and the output is aligned on a byte boundary, so that the decompressor can get all input data available so far.
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.FlushStrategy.Z_FULL_FLUSH">
            <summary>
            All output is flushed as with Z_SYNC_FLUSH, and the compression state is reset so that decompression can restart from this point if previous compressed data has been damaged or if random access is desired. Using Z_FULL_FLUSH too often can seriously degrade the compression. ZLib_InflateSync will locate points in the compression string where a full has been performed.
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.FlushStrategy.Z_FINISH">
            <summary>
            Notifies the module that the input has now been exhausted. Pending input is processed, pending output is flushed and calls return with Z_STREAM_END if there was enough output space.
            </summary>
        </member>
        <member name="T:ComponentAce.Compression.Libs.ZLib.ZLibResultCode">
            <summary>
            Results of operations in ZLib library
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.ZLibResultCode.Z_OK">
            <summary>
             No failure was encountered, the operation completed without problem.
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.ZLibResultCode.Z_STREAM_END">
            <summary>
            No failure was encountered, and the input has been exhausted.
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.ZLibResultCode.Z_NEED_DICT">
            <summary>
            A preset dictionary is required for decompression of the data.
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.ZLibResultCode.Z_ERRNO">
            <summary>
            An internal error occurred
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.ZLibResultCode.Z_STREAM_ERROR">
            <summary>
            The stream structure was inconsistent
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.ZLibResultCode.Z_DATA_ERROR">
            <summary>
            Input data has been corrupted (for decompression).
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.ZLibResultCode.Z_MEM_ERROR">
            <summary>
            Memory allocation failed.
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.ZLibResultCode.Z_BUF_ERROR">
            <summary>
            There was not enough space in the output buffer.
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.ZLibResultCode.Z_VERSION_ERROR">
            <summary>
            The version supplied does not match that supported by the ZLib module.
            </summary>
        </member>
        <member name="T:ComponentAce.Compression.Libs.ZLib.DeflateState">
            <summary>
            States of deflate operation
            </summary>
        </member>
        <member name="T:ComponentAce.Compression.Libs.ZLib.BlockType">
            <summary>
            Data block types, i.e. binary or ascii text
            </summary>
        </member>
        <member name="T:ComponentAce.Compression.Libs.ZLib.ZLibUtil">
            <summary>
            Helper class
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.ZLibUtil.MAX_WBITS">
            <summary>
            Max Window size
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.ZLibUtil.PRESET_DICT">
            <summary>
            preset dictionary flag in zlib header
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.ZLibUtil.zLibBufSize">
            <summary>
            The size of the buffer
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.ZLibUtil.Z_DEFLATED">
            <summary>
            Deflate compression method index
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.ZLibUtil.DIST_CODE_LEN">
            <summary>
            see definition of array dist_code below
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.ZLibUtil.Identity(System.Int64)">
            <summary>
            This method returns the literal value received
            </summary>
            <param name="literal">The literal to return</param>
            <returns>The received value</returns>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.ZLibUtil.Identity(System.UInt64)">
            <summary>
            This method returns the literal value received
            </summary>
            <param name="literal">The literal to return</param>
            <returns>The received value</returns>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.ZLibUtil.Identity(System.Single)">
            <summary>
            This method returns the literal value received
            </summary>
            <param name="literal">The literal to return</param>
            <returns>The received value</returns>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.ZLibUtil.Identity(System.Double)">
            <summary>
            This method returns the literal value received
            </summary>
            <param name="literal">The literal to return</param>
            <returns>The received value</returns>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.ZLibUtil.URShift(System.Int32,System.Int32)">
            <summary>
            Performs an unsigned bitwise right shift with the specified number
            </summary>
            <param name="number">Number to operate on</param>
            <param name="bits">Ammount of bits to shift</param>
            <returns>The resulting number from the shift operation</returns>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.ZLibUtil.URShift(System.Int32,System.Int64)">
            <summary>
            Performs an unsigned bitwise right shift with the specified number
            </summary>
            <param name="number">Number to operate on</param>
            <param name="bits">Ammount of bits to shift</param>
            <returns>The resulting number from the shift operation</returns>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.ZLibUtil.URShift(System.Int64,System.Int32)">
            <summary>
            Performs an unsigned bitwise right shift with the specified number
            </summary>
            <param name="number">Number to operate on</param>
            <param name="bits">Ammount of bits to shift</param>
            <returns>The resulting number from the shift operation</returns>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.ZLibUtil.URShift(System.Int64,System.Int64)">
            <summary>
            Performs an unsigned bitwise right shift with the specified number
            </summary>
            <param name="number">Number to operate on</param>
            <param name="bits">Ammount of bits to shift</param>
            <returns>The resulting number from the shift operation</returns>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.ZLibUtil.ReadInput(System.IO.Stream,System.Byte[],System.Int32,System.Int32)">
            <summary>Reads a number of characters from the current source Stream and writes the data to the target array at the specified index.</summary>
            <param name="sourceStream">The source Stream to ReadPos from.</param>
            <param name="target">Contains the array of characters ReadPos from the source Stream.</param>
            <param name="start">The starting index of the target array.</param>
            <param name="count">The maximum number of characters to ReadPos from the source Stream.</param>
            <returns>The number of characters ReadPos. The number will be less than or equal to count depending on the data available in the source Stream. Returns -1 if the End of the stream is reached.</returns>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.ZLibUtil.ReadInput(System.IO.TextReader,System.Byte[],System.Int32,System.Int32)">
            <summary>Reads a number of characters from the current source TextReader and writes the data to the target array at the specified index.</summary>
            <param name="sourceTextReader">The source TextReader to ReadPos from</param>
            <param name="target">Contains the array of characteres ReadPos from the source TextReader.</param>
            <param name="start">The starting index of the target array.</param>
            <param name="count">The maximum number of characters to ReadPos from the source TextReader.</param>
            <returns>The number of characters ReadPos. The number will be less than or equal to count depending on the data available in the source TextReader. Returns -1 if the End of the stream is reached.</returns>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.ZLibUtil.ToByteArray(System.String)">
            <summary>
            Converts a string to an array of bytes
            </summary>
            <param name="sourceString">The string to be converted</param>
            <returns>The new array of bytes</returns>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.ZLibUtil.ToCharArray(System.Byte[])">
            <summary>
            Converts an array of bytes to an array of chars
            </summary>
            <param name="byteArray">The array of bytes to convert</param>
            <returns>The new array of chars</returns>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.ZLibUtil.CopyLargeArrayToSmall.CopyData">
            <summary>
            Copies large array which was passed as srcBuf to the Initialize method into the destination array which were passes as destBuff
            </summary>
            <returns>The number of bytes copied</returns>
        </member>
        <member name="T:ComponentAce.Compression.Libs.ZLib.ZStream">
            <summary>
            ZStream is used to store user data to compress/decompress.
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.ZStream.MAX_MEM_LEVEL">
            <summary>
            Maximum memory level
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.ZStream._next_in">
            <summary>
            Next input byte array
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.ZStream._next_in_index">
            <summary>
            Index of the first byte in the <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.next_in">input array</see>.
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.ZStream._avail_in">
            <summary>
            Number of bytes available at _next_in
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.ZStream._total_in">
            <summary>
            total nb of input bytes ReadPos so far
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.ZStream._next_out">
            <summary>
            Byte array for the next output block
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.ZStream._next_out_index">
            <summary>
            Index of the first byte in the _next_out array
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.ZStream._avail_out">
            <summary>
            Remaining free space at _next_out
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.ZStream._total_out">
            <summary>
            Total number of bytes in output array
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.ZStream._msg">
            <summary>
            A string to store operation result message (corresponding to result codes)
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.ZStream._dstate">
            <summary>
            A deflate object to perform data compression
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.ZStream._istate">
            <summary>
            Inflate object to perform data decompression
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.ZStream.data_type">
            <summary>
            Best guess about the data type: ascii or binary
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.ZStream._adler">
            <summary>
            A checksum computed with Adler algorithm
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.ZStream.inflateInit">
            <summary>
            Initializes the internal stream state for decompression. The fields <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.next_in"/>, <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.avail_in"/> must be 
            initialized before by the caller. If <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.next_in"/> is not <c>null</c> and <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.avail_in"/> is large 
            enough (the exact value depends on the compression method), <see cref="M:ComponentAce.Compression.Libs.ZLib.ZStream.inflateInit"/> determines the compression 
            method from the ZLib header and allocates all data structures accordingly; otherwise the allocation will be deferred 
            to the first call of <see cref="M:ComponentAce.Compression.Libs.ZLib.ZStream.inflate(ComponentAce.Compression.Libs.ZLib.FlushStrategy)"/>. 
            </summary>
            <returns>
            inflateInit returns <see cref="F:ComponentAce.Compression.Libs.ZLib.ZLibResultCode.Z_OK"/> if success, <see cref="F:ComponentAce.Compression.Libs.ZLib.ZLibResultCode.Z_MEM_ERROR"/> if there was not enough memory,  
            <see cref="F:ComponentAce.Compression.Libs.ZLib.ZLibResultCode.Z_VERSION_ERROR"/> if the ZLib library version is incompatible with the version assumed by the caller. 
            <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.msg"/> is set to <c>null</c> if there is no error message. <see cref="M:ComponentAce.Compression.Libs.ZLib.ZStream.inflateInit"/> does not perform any decompression 
            apart from reading the ZLib header if present: this will be done by <see cref="M:ComponentAce.Compression.Libs.ZLib.ZStream.inflate(ComponentAce.Compression.Libs.ZLib.FlushStrategy)"/>. (So <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.next_in"/> and <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.avail_in"/> 
            may be modified, but <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.next_out"/> and <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.avail_out"/> are unchanged.)
            </returns>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.ZStream.inflateInit(System.Int32)">
            <summary>
            This is another version of <see cref="M:ComponentAce.Compression.Libs.ZLib.ZStream.inflateInit"/> with an extra parameter. The fields <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.next_in"/>, <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.avail_in"/> must be 
            initialized before by the caller. If <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.next_in"/> is not <c>null</c> and <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.avail_in"/> is large enough 
            (the exact value depends on the compression method), <see cref="M:ComponentAce.Compression.Libs.ZLib.ZStream.inflateInit(System.Int32)"/> determines the compression method from 
            the ZLib header and allocates all data structures accordingly; otherwise the allocation will be deferred to the first 
            call of <see cref="M:ComponentAce.Compression.Libs.ZLib.ZStream.inflate(ComponentAce.Compression.Libs.ZLib.FlushStrategy)"/>. 
            </summary>
            <param name="windowBits">The <c>windowBits</c> parameter is the base two logarithm of the maximum window size (the size of the history buffer). 
            It should be in the range <c>8..15</c> for this version of the library. The default value is 15 if <see cref="M:ComponentAce.Compression.Libs.ZLib.ZStream.inflateInit(System.Int32)"/> is used instead.
            If a compressed stream with a larger window size is given as input, <see cref="M:ComponentAce.Compression.Libs.ZLib.ZStream.inflate(ComponentAce.Compression.Libs.ZLib.FlushStrategy)"/> will return with the error code 
            <see cref="F:ComponentAce.Compression.Libs.ZLib.ZLibResultCode.Z_DATA_ERROR"/> instead of trying to allocate a larger window.</param>
            <returns>
            inflateInit returns <see cref="F:ComponentAce.Compression.Libs.ZLib.ZLibResultCode.Z_OK"/> if success, <see cref="F:ComponentAce.Compression.Libs.ZLib.ZLibResultCode.Z_MEM_ERROR"/> if there was not enough memory,
            <see cref="F:ComponentAce.Compression.Libs.ZLib.ZLibResultCode.Z_STREAM_ERROR"/> if a parameter is invalid (such as a negative memLevel). <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.msg"/> is set to null 
            if there is no error message. <see cref="M:ComponentAce.Compression.Libs.ZLib.ZStream.inflateInit(System.Int32)"/> does not perform any decompression apart from reading the ZLib header 
            if present: this will be done by <see cref="M:ComponentAce.Compression.Libs.ZLib.ZStream.inflate(ComponentAce.Compression.Libs.ZLib.FlushStrategy)"/>. (So <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.next_in"/> and <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.avail_in"/> may be modified, 
            but <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.next_out"/> and <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.avail_out"/> are unchanged.)
            </returns>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.ZStream.inflate(ComponentAce.Compression.Libs.ZLib.FlushStrategy)">
            <summary>
            <para>This method decompresses as much data as possible, and stops when the input buffer (<see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.next_in"/>) becomes empty or 
            the output buffer (<see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.next_out"/>) becomes full. It may some introduce some output latency (reading input without producing any output) 
            except when forced to flush. </para>
            <para>The detailed semantics are as follows. <see cref="M:ComponentAce.Compression.Libs.ZLib.ZStream.inflate(ComponentAce.Compression.Libs.ZLib.FlushStrategy)"/> performs one or both of the following actions: </para>
            <para>
            <list type="bullet">
            <item>Decompress more input starting at <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.next_in"/> and update <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.next_in"/> and <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.avail_in"/> 
            accordingly. If not all input can be processed (because there is not enough room in the output buffer), <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.next_in"/> is updated and 
            processing will resume at this point for the next call of <see cref="M:ComponentAce.Compression.Libs.ZLib.ZStream.inflate(ComponentAce.Compression.Libs.ZLib.FlushStrategy)"/>. </item>
            <item>Provide more output starting at <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.next_out"/> and update <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.next_out"/> and <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.avail_out"/> 
            accordingly. <see cref="M:ComponentAce.Compression.Libs.ZLib.ZStream.inflate(ComponentAce.Compression.Libs.ZLib.FlushStrategy)"/> provides as much output as possible, until there is no more input data or no more space in 
            the output buffer (see below about the <paramref name="flush"/> parameter).</item>
            </list>
            </para>
            </summary>
            <param name="flush"><see cref="T:ComponentAce.Compression.Libs.ZLib.FlushStrategy">Flush strategy</see> to use.</param>
            <remarks>
            <para>Before the call of <see cref="M:ComponentAce.Compression.Libs.ZLib.ZStream.inflate(ComponentAce.Compression.Libs.ZLib.FlushStrategy)"/>, the application should ensure that at least one of the actions is possible, by providing 
            more input and/or consuming more output, and updating the next_* and avail_* values accordingly. The application can consume the uncompressed 
            output when it wants, for example when the output buffer is full (<c>avail_out == 0</c>), or after each call of <see cref="M:ComponentAce.Compression.Libs.ZLib.ZStream.inflate(ComponentAce.Compression.Libs.ZLib.FlushStrategy)"/>. 
            If <see cref="M:ComponentAce.Compression.Libs.ZLib.ZStream.inflate(ComponentAce.Compression.Libs.ZLib.FlushStrategy)"/> returns <see cref="F:ComponentAce.Compression.Libs.ZLib.ZLibResultCode.Z_OK"/> and with zero <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.avail_out"/>, it must be called again 
            after making room in the <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.next_out">output buffer</see> because there might be more output pending. </para>
            <para>If the parameter <paramref name="flush"/> is set to <see cref="F:ComponentAce.Compression.Libs.ZLib.FlushStrategy.Z_SYNC_FLUSH"/>, <see cref="M:ComponentAce.Compression.Libs.ZLib.ZStream.inflate(ComponentAce.Compression.Libs.ZLib.FlushStrategy)"/> flushes 
            as much output as possible to the output buffer. The flushing behavior of <see cref="M:ComponentAce.Compression.Libs.ZLib.ZStream.inflate(ComponentAce.Compression.Libs.ZLib.FlushStrategy)"/> is not specified for values of 
            the <paramref name="flush"/> parameter other than <see cref="F:ComponentAce.Compression.Libs.ZLib.FlushStrategy.Z_SYNC_FLUSH"/> and <see cref="F:ComponentAce.Compression.Libs.ZLib.FlushStrategy.Z_FINISH"/>, 
            but the current implementation actually flushes as much output as possible anyway. </para>
            <para><see cref="M:ComponentAce.Compression.Libs.ZLib.ZStream.inflate(ComponentAce.Compression.Libs.ZLib.FlushStrategy)"/> should normally be called until it returns <see cref="F:ComponentAce.Compression.Libs.ZLib.ZLibResultCode.Z_STREAM_END"/> or an error. 
            However if all decompression is to be performed in a single step (a single call of inflate), the parameter <paramref name="flush"/> 
            should be set to <see cref="F:ComponentAce.Compression.Libs.ZLib.FlushStrategy.Z_FINISH"/>. In this case all pending input is processed and all pending output is flushed; 
            <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.avail_out"/> must be large enough to hold all the uncompressed data. (The size of the uncompressed data may have been 
            saved by the compressor for this purpose.) The next operation on this stream must be <see cref="M:ComponentAce.Compression.Libs.ZLib.ZStream.inflateEnd"/> to deallocate the decompression 
            state. The use of <see cref="F:ComponentAce.Compression.Libs.ZLib.FlushStrategy.Z_FINISH"/> is never required, but can be used to inform <see cref="M:ComponentAce.Compression.Libs.ZLib.ZStream.inflate(ComponentAce.Compression.Libs.ZLib.FlushStrategy)"/> that a faster 
            routine may be used for the single <see cref="M:ComponentAce.Compression.Libs.ZLib.ZStream.inflate(ComponentAce.Compression.Libs.ZLib.FlushStrategy)"/> call. </para>
            <para>If a preset dictionary is needed at this point (see <see cref="M:ComponentAce.Compression.Libs.ZLib.ZStream.inflateSetDictionary(System.Byte[],System.Int32)"/>), <see cref="M:ComponentAce.Compression.Libs.ZLib.ZStream.inflate(ComponentAce.Compression.Libs.ZLib.FlushStrategy)"/> sets strm-adler 
            to the adler32 checksum of the dictionary chosen by the compressor and returns <see cref="F:ComponentAce.Compression.Libs.ZLib.ZLibResultCode.Z_NEED_DICT"/>; otherwise it 
            sets strm-&gt;adler to the adler32 checksum of all output produced so far (that is, <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.total_out"/> bytes) and returns
            <see cref="F:ComponentAce.Compression.Libs.ZLib.ZLibResultCode.Z_OK"/>, <see cref="F:ComponentAce.Compression.Libs.ZLib.ZLibResultCode.Z_STREAM_END"/> or an error code as described below. At the end of the stream, 
            <see cref="M:ComponentAce.Compression.Libs.ZLib.ZStream.inflate(ComponentAce.Compression.Libs.ZLib.FlushStrategy)"/>) checks that its computed adler32 checksum is equal to that saved by the compressor and returns
            <see cref="F:ComponentAce.Compression.Libs.ZLib.ZLibResultCode.Z_STREAM_END"/> only if the checksum is correct.</para>
            </remarks>
            <returns>
            <see cref="M:ComponentAce.Compression.Libs.ZLib.ZStream.inflate(ComponentAce.Compression.Libs.ZLib.FlushStrategy)"/> returns <see cref="F:ComponentAce.Compression.Libs.ZLib.ZLibResultCode.Z_OK"/> if some progress has been made (more input processed or more output produced), 
            <see cref="F:ComponentAce.Compression.Libs.ZLib.ZLibResultCode.Z_STREAM_END"/> if the end of the compressed data has been reached and all uncompressed output has been produced, 
            <see cref="F:ComponentAce.Compression.Libs.ZLib.ZLibResultCode.Z_NEED_DICT"/> if a preset dictionary is needed at this point, <see cref="F:ComponentAce.Compression.Libs.ZLib.ZLibResultCode.Z_DATA_ERROR"/> if 
            the input data was corrupted (input stream not conforming to the ZLib format or incorrect adler32 checksum), 
            <see cref="F:ComponentAce.Compression.Libs.ZLib.ZLibResultCode.Z_STREAM_ERROR"/> if the stream structure was inconsistent (for example if <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.next_in"/> or 
            <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.next_out"/> was <c>null</c>), <see cref="F:ComponentAce.Compression.Libs.ZLib.ZLibResultCode.Z_MEM_ERROR"/> if there was not enough memory, 
            <see cref="F:ComponentAce.Compression.Libs.ZLib.ZLibResultCode.Z_BUF_ERROR"/> if no progress is possible or if there was not enough room in the output buffer 
            when <see cref="F:ComponentAce.Compression.Libs.ZLib.FlushStrategy.Z_FINISH"/> is used. In the <see cref="F:ComponentAce.Compression.Libs.ZLib.ZLibResultCode.Z_DATA_ERROR"/> case, the application 
            may then call <see cref="M:ComponentAce.Compression.Libs.ZLib.ZStream.inflateSync"/> to look for a good compression block.
            </returns>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.ZStream.inflateEnd">
            <summary>
            All dynamically allocated data structures for this stream are freed. This function discards any unprocessed input and does not flush any 
            pending output.
            </summary>
            <returns>
            inflateEnd returns <see cref="F:ComponentAce.Compression.Libs.ZLib.ZLibResultCode.Z_OK"/> if success, <see cref="F:ComponentAce.Compression.Libs.ZLib.ZLibResultCode.Z_STREAM_ERROR"/> 
            if the stream state was inconsistent. In the error case, msg may be set but then points to a static string (which must not be deallocated).
            </returns>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.ZStream.inflateSync">
            <summary>
            Skips invalid compressed data until a full flush point (see the description of <see cref="M:ComponentAce.Compression.Libs.ZLib.ZStream.deflate(ComponentAce.Compression.Libs.ZLib.FlushStrategy)">deflate with Z_FULL_FLUSH</see>) can be found, 
            or until all available input is skipped. No output is provided.
            </summary>
            <returns>
            <see cref="M:ComponentAce.Compression.Libs.ZLib.ZStream.inflateSync"/> returns <seec ref="ZLibResultCode.Z_OK"/> if a full flush point has been found, <see cref="F:ComponentAce.Compression.Libs.ZLib.ZLibResultCode.Z_BUF_ERROR"/>
            if no more input was provided, <see cref="F:ComponentAce.Compression.Libs.ZLib.ZLibResultCode.Z_DATA_ERROR"/> if no flush point has been found, or 
            <see cref="F:ComponentAce.Compression.Libs.ZLib.ZLibResultCode.Z_STREAM_ERROR"/> if the stream structure was inconsistent. In the success case, the application may save the current 
            current value of <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.total_in"/> which indicates where valid compressed data was found. In the error case, the application may repeatedly 
            call <see cref="M:ComponentAce.Compression.Libs.ZLib.ZStream.inflateSync"/>, providing more input each time, until success or end of the input data.
            </returns>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.ZStream.inflateSetDictionary(System.Byte[],System.Int32)">
            <summary>
            Initializes the decompression dictionary from the given uncompressed byte sequence. This function must be called immediately after a call of <see cref="M:ComponentAce.Compression.Libs.ZLib.ZStream.inflate(ComponentAce.Compression.Libs.ZLib.FlushStrategy)"/> if this call returned <see cref="F:ComponentAce.Compression.Libs.ZLib.ZLibResultCode.Z_NEED_DICT"/>. The dictionary chosen by the compressor can be determined from the Adler32 value returned by this call of <see cref="M:ComponentAce.Compression.Libs.ZLib.ZStream.inflate(ComponentAce.Compression.Libs.ZLib.FlushStrategy)"/>. The compressor and decompresser must use exactly the same dictionary.
            </summary>
            <param name="dictionary">A byte array - a dictionary.</param>
            <param name="dictLength">The length of the dictionary.</param>
            <returns>
            inflateSetDictionary returns <see cref="F:ComponentAce.Compression.Libs.ZLib.ZLibResultCode.Z_OK"/> if success, <see cref="F:ComponentAce.Compression.Libs.ZLib.ZLibResultCode.Z_STREAM_ERROR"/> if a parameter is invalid (such as <c>null</c> dictionary) or the stream state is inconsistent, <see cref="F:ComponentAce.Compression.Libs.ZLib.ZLibResultCode.Z_DATA_ERROR"/> if the given dictionary doesn't match the expected one (incorrect Adler32 value). inflateSetDictionary does not perform any decompression: this will be done by subsequent calls of <see cref="M:ComponentAce.Compression.Libs.ZLib.ZStream.inflate(ComponentAce.Compression.Libs.ZLib.FlushStrategy)"/>.
            </returns>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.ZStream.deflateInit(System.Int32)">
            <summary>
            Initializes the internal stream state for compression. 
            </summary>
            <param name="level">An integer value from 0 to 9 indicating the desired compression level.</param>
            <returns>
            deflateInit returns <see cref="F:ComponentAce.Compression.Libs.ZLib.ZLibResultCode.Z_OK"/> if success, <see cref="F:ComponentAce.Compression.Libs.ZLib.ZLibResultCode.Z_MEM_ERROR"/> if there was not enough memory, 
            <see cref="F:ComponentAce.Compression.Libs.ZLib.ZLibResultCode.Z_STREAM_ERROR"/> if level is not a valid compression level. <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.msg"/> is set to <c>null</c> if there is 
            no error message. <see cref="M:ComponentAce.Compression.Libs.ZLib.ZStream.deflateInit(System.Int32)"/> does not perform any compression: this will be done by <see cref="M:ComponentAce.Compression.Libs.ZLib.ZStream.deflate(ComponentAce.Compression.Libs.ZLib.FlushStrategy)"/>.
            </returns>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.ZStream.deflateInit(System.Int32,System.Int32)">
            <summary>
            Initializes the internal stream state for compression. 
            </summary>
            <param name="level">An integer value from 0 to 9 indicating the desired compression level.</param>
            <param name="bits"> The windowBits parameter is the base two logarithm of the window size (the size of the history buffer). It should be in the 
            range 8..15 for this version of the library. Larger values of this parameter result in better compression at the expense of memory usage. 
            The default value is 15 if deflateInit is used instead.</param>
            <returns>
            deflateInit returns <see cref="F:ComponentAce.Compression.Libs.ZLib.ZLibResultCode.Z_OK"/> if success, <see cref="F:ComponentAce.Compression.Libs.ZLib.ZLibResultCode.Z_MEM_ERROR"/> if there was not enough memory,
            <see cref="F:ComponentAce.Compression.Libs.ZLib.ZLibResultCode.Z_STREAM_ERROR"/> if level is not a valid compression level. <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.msg"/> is set to <c>null</c> if there 
            is no error message. <see cref="M:ComponentAce.Compression.Libs.ZLib.ZStream.deflateInit(System.Int32,System.Int32)"/> does not perform any compression: this will be done by <see cref="M:ComponentAce.Compression.Libs.ZLib.ZStream.deflate(ComponentAce.Compression.Libs.ZLib.FlushStrategy)"/>.
            </returns>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.ZStream.deflate(ComponentAce.Compression.Libs.ZLib.FlushStrategy)">
            <summary>
            <para>Deflate compresses as much data as possible, and stops when the <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.next_in">input buffer</see> becomes empty or the 
            <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.next_out">output buffer</see> becomes full. It may introduce some output latency (reading input without producing any output) 
            except when forced to flush.</para>
            <para>The detailed semantics are as follows. deflate performs one or both of the following actions:
            <list type="bullet">
            <item>Compress more input starting at <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.next_in"/> and update <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.next_in"/> and <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.avail_in"/> accordingly. 
            If not all input can be processed (because there is not enough room in the output buffer), <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.next_in"/> and <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.avail_in"/> 
            are updated and processing will resume at this point for the next call of <see cref="M:ComponentAce.Compression.Libs.ZLib.ZStream.deflate(ComponentAce.Compression.Libs.ZLib.FlushStrategy)"/>. </item>
            <item>Provide more output starting at <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.next_out"/> and update <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.next_out"/> and <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.avail_out"/> accordingly. 
            This action is forced if the parameter flush is non zero. Forcing flush frequently degrades the compression ratio, so this parameter should 
            be set only when necessary (in interactive applications). Some output may be provided even if flush is not set.</item>
            </list>
            </para>
            </summary>
            <param name="flush">The <see cref="T:ComponentAce.Compression.Libs.ZLib.FlushStrategy">flush strategy</see> to use.</param>
            <remarks>
            <para>
            Before the call of <seec ref="deflate"/>, the application should ensure that at least one of the actions is possible, by providing 
            more input and/or consuming more output, and updating <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.avail_in"/> or <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.avail_out"/> accordingly ; <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.avail_out"/> 
            should never be zero before the call. The application can consume the compressed output when it wants, for example when the output buffer is full
            (<c>avail_out == 0</c>), or after each call of <see cref="M:ComponentAce.Compression.Libs.ZLib.ZStream.deflate(ComponentAce.Compression.Libs.ZLib.FlushStrategy)"/>. If <see cref="M:ComponentAce.Compression.Libs.ZLib.ZStream.deflate(ComponentAce.Compression.Libs.ZLib.FlushStrategy)"/> returns <see cref="F:ComponentAce.Compression.Libs.ZLib.ZLibResultCode.Z_OK"/> 
            and with zero <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.avail_out"/>, it must be called again after making room in the output buffer because there might be more output pending. 
            </para>
            <para>
            If the parameter <paramref name="flush"/> is set to <see cref="F:ComponentAce.Compression.Libs.ZLib.FlushStrategy.Z_SYNC_FLUSH"/>, all pending output is flushed to the 
            <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.next_out">output buffer</see> and the output is aligned on a byte boundary, so that the decompressor can get all input 
            data available so far. (In particular <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.avail_in"/> is zero after the call if enough output space has been provided before the call.) 
            Flushing may degrade compression for some compression algorithms and so it should be used only when necessary. 
            </para>
            <para>
            If flush is set to <see cref="F:ComponentAce.Compression.Libs.ZLib.FlushStrategy.Z_FULL_FLUSH"/>, all output is flushed as with <see cref="F:ComponentAce.Compression.Libs.ZLib.FlushStrategy.Z_SYNC_FLUSH"/>, 
            and the compression state is reset so that decompression can restart from this point if previous compressed data has been damaged or if 
            random access is desired. Using <see cref="F:ComponentAce.Compression.Libs.ZLib.FlushStrategy.Z_FULL_FLUSH"/> too often can seriously degrade the compression.
            </para>
            </remarks>
            <returns>
            <para>
            If deflate returns with <c><see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.avail_out"/> == 0</c>, this function must be called again with the same value of the flush
            parameter and more output space (updated <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.avail_out"/>), until the flush is complete (<see cref="M:ComponentAce.Compression.Libs.ZLib.ZStream.deflate(ComponentAce.Compression.Libs.ZLib.FlushStrategy)"/> returns with
            non-zero <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.avail_out"/>). 
            </para>
            <para>
            If the parameter <paramref name="flush"/> is set to <see cref="F:ComponentAce.Compression.Libs.ZLib.FlushStrategy.Z_FINISH"/>, pending input is processed, pending 
            output is flushed and deflate returns with <see cref="F:ComponentAce.Compression.Libs.ZLib.ZLibResultCode.Z_STREAM_END"/> if there was enough output space ; 
            if deflate returns with <see cref="F:ComponentAce.Compression.Libs.ZLib.ZLibResultCode.Z_OK"/>, this function must be called again with <see cref="F:ComponentAce.Compression.Libs.ZLib.FlushStrategy.Z_FINISH"/> 
            and more output space (updated <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.avail_out"/>) but no more input data, until it returns with <see cref="F:ComponentAce.Compression.Libs.ZLib.ZLibResultCode.Z_STREAM_END"/> 
            or an error. After deflate has returned <see cref="F:ComponentAce.Compression.Libs.ZLib.ZLibResultCode.Z_STREAM_END"/>, the only possible operation on the stream is
            <see cref="M:ComponentAce.Compression.Libs.ZLib.ZStream.deflateEnd"/>. </para>
            <para>
            <see cref="F:ComponentAce.Compression.Libs.ZLib.FlushStrategy.Z_FINISH"/> can be used immediately after <see cref="M:ComponentAce.Compression.Libs.ZLib.ZStream.deflateInit(System.Int32)"/> if all the compression is to be 
            done in a single step. In this case, avail_out must be at least 0.1% larger than avail_in plus 12 bytes. If deflate does not return 
            Z_STREAM_END, then it must be called again as described above. 
            </para>
            <para>
            <see cref="M:ComponentAce.Compression.Libs.ZLib.ZStream.deflate(ComponentAce.Compression.Libs.ZLib.FlushStrategy)"/> sets strm-&gt; adler to the adler32 checksum of all input read so far (that is, <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.total_in"/> bytes). 
            </para>
            <para>
            <see cref="M:ComponentAce.Compression.Libs.ZLib.ZStream.deflate(ComponentAce.Compression.Libs.ZLib.FlushStrategy)"/> may update data_type if it can make a good guess about the input data type (<see cref="T:ComponentAce.Compression.Libs.ZLib.BlockType">Z_ASCII or Z_BINARY</see>).
            In doubt, the data is considered binary. This field is only for information purposes and does not affect the compression algorithm in any manner. 
            </para>
            <para>
            <see cref="M:ComponentAce.Compression.Libs.ZLib.ZStream.deflate(ComponentAce.Compression.Libs.ZLib.FlushStrategy)"/> returns <see cref="F:ComponentAce.Compression.Libs.ZLib.ZLibResultCode.Z_OK"/> if some progress has been made (more input processed or more output produced), 
            <see cref="F:ComponentAce.Compression.Libs.ZLib.ZLibResultCode.Z_STREAM_END"/> if all input has been consumed and all output has been produced (only when flush is set to
            <see cref="F:ComponentAce.Compression.Libs.ZLib.FlushStrategy.Z_FINISH"/>), <see cref="F:ComponentAce.Compression.Libs.ZLib.ZLibResultCode.Z_STREAM_ERROR"/> if the stream state was inconsistent (for example if 
            <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.next_in"/> or <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.next_out"/> was <c>null</c>), <see cref="F:ComponentAce.Compression.Libs.ZLib.ZLibResultCode.Z_BUF_ERROR"/> if no progress is possible
            (for example <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.avail_in"/> or <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.avail_out"/> was zero).
            </para>
            </returns>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.ZStream.deflateEnd">
            <summary>
            All dynamically allocated data structures for this stream are freed. This function discards any unprocessed input and does not flush any pending 
            output.
            </summary>
            <returns>
            deflateEnd returns <see cref="F:ComponentAce.Compression.Libs.ZLib.ZLibResultCode.Z_OK"/> if success, <see cref="F:ComponentAce.Compression.Libs.ZLib.ZLibResultCode.Z_STREAM_ERROR"/> if the stream state was inconsistent, 
            <see cref="F:ComponentAce.Compression.Libs.ZLib.ZLibResultCode.Z_DATA_ERROR"/> if the stream was freed prematurely (some input or output was discarded). In the error case, 
            <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.msg"/> may be set but then points to a static string (which must not be deallocated).
            </returns>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.ZStream.deflateParams(System.Int32,ComponentAce.Compression.Libs.ZLib.CompressionStrategy)">
            <summary>
            Dynamically update the compression level and compression strategy. The interpretation of level is as in <see cref="M:ComponentAce.Compression.Libs.ZLib.ZStream.deflateInit(System.Int32)"/>. 
            This can be used to switch between compression and straight copy of the input data, or to switch to a different kind of input data 
            requiring a different strategy. If the compression level is changed, the input available so far is compressed with the old level 
            (and may be flushed); the new level will take effect only at the next call of <see cref="M:ComponentAce.Compression.Libs.ZLib.ZStream.deflate(ComponentAce.Compression.Libs.ZLib.FlushStrategy)"/>
            </summary>
            <param name="level">An integer value indicating the desired compression level.</param>
            <param name="strategy">A <see cref="T:ComponentAce.Compression.Libs.ZLib.FlushStrategy">flush strategy</see> to use.</param>
            <remarks>
            Before the call of <see cref="M:ComponentAce.Compression.Libs.ZLib.ZStream.deflateParams(System.Int32,ComponentAce.Compression.Libs.ZLib.CompressionStrategy)"/>, the stream state must be set as for a call of <see cref="M:ComponentAce.Compression.Libs.ZLib.ZStream.deflate(ComponentAce.Compression.Libs.ZLib.FlushStrategy)"/>, since the 
            currently available input may have to be compressed and flushed. In particular, <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.avail_out"/> must be non-zero.
            </remarks>
            <returns>
            deflateParams returns <see cref="F:ComponentAce.Compression.Libs.ZLib.ZLibResultCode.Z_OK"/> if success, <see cref="F:ComponentAce.Compression.Libs.ZLib.ZLibResultCode.Z_STREAM_ERROR"/> if the source stream 
            state was inconsistent or if a parameter was invalid, <see cref="F:ComponentAce.Compression.Libs.ZLib.ZLibResultCode.Z_BUF_ERROR"/> if <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.avail_out"/> was zero.
            </returns>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.ZStream.deflateSetDictionary(System.Byte[],System.Int32)">
            <summary>
            Initializes the compression dictionary from the given byte sequence without producing any compressed output. This function must be called 
            immediately after <see cref="M:ComponentAce.Compression.Libs.ZLib.ZStream.deflateInit(System.Int32)"/>, before any call of <see cref="M:ComponentAce.Compression.Libs.ZLib.ZStream.deflate(ComponentAce.Compression.Libs.ZLib.FlushStrategy)"/>. The compressor and decompressor must use 
            exactly the same dictionary (see <see cref="M:ComponentAce.Compression.Libs.ZLib.ZStream.inflateSetDictionary(System.Byte[],System.Int32)"/>).
            </summary>
            <param name="dictionary">A byte array - a dictionary.</param>
            <param name="dictLength">The length of the dictionary byte array</param>
            <remarks>
            <para>
            The dictionary should consist of strings (byte sequences) that are likely to be encountered later in the data to be compressed, 
            with the most commonly used strings preferably put towards the end of the dictionary. Using a dictionary is most useful when the data 
            to be compressed is short and can be predicted with good accuracy; the data can then be compressed better than with the default empty dictionary.
            </para>
            <para>Depending on the size of the compression data structures selected by <see cref="M:ComponentAce.Compression.Libs.ZLib.ZStream.deflateInit(System.Int32)"/>, a part of the dictionary may 
            in effect be discarded, for example if the dictionary is larger than the window size in <see cref="M:ComponentAce.Compression.Libs.ZLib.ZStream.deflate(ComponentAce.Compression.Libs.ZLib.FlushStrategy)"/>. Thus the strings most likely 
            to be useful should be put at the end of the dictionary, not at the front.</para>
            <para>Upon return of this function, adler is set to the Adler32 value of the dictionary; the decompresser may later use this value to determine 
            which dictionary has been used by the compressor. (The Adler32 value applies to the whole dictionary even if only a subset of the dictionary 
            is actually used by the compressor.)</para>
            </remarks>
            <returns>
            deflateSetDictionary returns <see cref="F:ComponentAce.Compression.Libs.ZLib.ZLibResultCode.Z_OK"/> if success, or <see cref="F:ComponentAce.Compression.Libs.ZLib.ZLibResultCode.Z_STREAM_ERROR"/> if a parameter 
            is invalid (such as <c>null</c> dictionary) or the stream state is inconsistent (for example if <see cref="M:ComponentAce.Compression.Libs.ZLib.ZStream.deflate(ComponentAce.Compression.Libs.ZLib.FlushStrategy)"/> has already been 
            called for this stream or if the compression method is bsort). <see cref="M:ComponentAce.Compression.Libs.ZLib.ZStream.deflateSetDictionary(System.Byte[],System.Int32)"/> does not perform any compression: 
            this will be done by <see cref="M:ComponentAce.Compression.Libs.ZLib.ZStream.deflate(ComponentAce.Compression.Libs.ZLib.FlushStrategy)"/>.
            </returns>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.ZStream.flush_pending">
            <summary>
            Flush as much pending output as possible. All <see cref="M:ComponentAce.Compression.Libs.ZLib.ZStream.deflate(ComponentAce.Compression.Libs.ZLib.FlushStrategy)"/> output goes through this function so some applications may wish to 
            modify it to avoid allocating a large <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.next_out"/> buffer and copying into it.
            </summary>
            <seealso cref="M:ComponentAce.Compression.Libs.ZLib.ZStream.read_buf(System.Byte[],System.Int32,System.Int32)"/>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.ZStream.read_buf(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Read a new buffer from the current input stream, update the adler32 and total number of bytes read.  All <see cref="M:ComponentAce.Compression.Libs.ZLib.ZStream.deflate(ComponentAce.Compression.Libs.ZLib.FlushStrategy)"/> input goes 
            through this function so some applications may wish to modify it to avoid allocating a large <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.next_in"/> buffer and copying from it.
            </summary>
            <seealso cref="M:ComponentAce.Compression.Libs.ZLib.ZStream.flush_pending"/>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.ZStream.free">
            <summary>
            Frees all inner <see cref="T:ComponentAce.Compression.Libs.ZLib.ZStream"/> buffers.
            </summary>
        </member>
        <member name="P:ComponentAce.Compression.Libs.ZLib.ZStream.adler">
            <summary>
            Adler-32 value for uncompressed data processed so far.
            </summary>
        </member>
        <member name="P:ComponentAce.Compression.Libs.ZLib.ZStream.Data_type">
            <summary>
            Best guess about the data type: ascii or binary
            </summary>
        </member>
        <member name="P:ComponentAce.Compression.Libs.ZLib.ZStream.next_in">
            <summary>
            Gets/Sets the next input byte array.
            </summary>
        </member>
        <member name="P:ComponentAce.Compression.Libs.ZLib.ZStream.next_in_index">
            <summary>
            Index of the first byte in the <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.next_in">input array</see>.
            </summary>
        </member>
        <member name="P:ComponentAce.Compression.Libs.ZLib.ZStream.avail_in">
            <summary>
            Gets/Sets the number of bytes available in the <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.next_in">input buffer</see>.
            </summary>
        </member>
        <member name="P:ComponentAce.Compression.Libs.ZLib.ZStream.total_in">
            <summary>
            Gets/Sets the total number of bytes in the <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.next_in">input buffer</see>.
            </summary>
        </member>
        <member name="P:ComponentAce.Compression.Libs.ZLib.ZStream.next_out">
            <summary>
            Gets/Sets the buffer for the next output data.
            </summary>
        </member>
        <member name="P:ComponentAce.Compression.Libs.ZLib.ZStream.next_out_index">
            <summary>
            Gets/Sets the index of the first byte in the <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.next_out"/> byte array to write to.
            </summary>
        </member>
        <member name="P:ComponentAce.Compression.Libs.ZLib.ZStream.avail_out">
            <summary>
            Gets/Sets the remaining free space in the <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.next_out"/> buffer.
            </summary>
        </member>
        <member name="P:ComponentAce.Compression.Libs.ZLib.ZStream.total_out">
            <summary>
            Gets/Sets the total number of bytes in the <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.next_out">output array</see>.
            </summary>
        </member>
        <member name="P:ComponentAce.Compression.Libs.ZLib.ZStream.msg">
            <summary>
            Gets sets the last error message occurred during class operations.
            </summary>
        </member>
        <member name="P:ComponentAce.Compression.Libs.ZLib.ZStream.dstate">
            <summary>
            A deflate object to perform data compression
            </summary>
        </member>
        <member name="P:ComponentAce.Compression.Libs.ZLib.ZStream.istate">
            <summary>
            Inflate object to perform data decompression
            </summary>
        </member>
        <member name="T:ComponentAce.Compression.Libs.ZLib.ZStreamException">
            <summary>
            Exceptions that occur in ZStream
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.ZStreamException.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.ZStreamException.#ctor(System.String)">
            <summary>
            Constructor which takes one parameter - an error message
            </summary>
        </member>
        <member name="M:IronPython.Modules.PythonCodecs.charmap_build(System.String)">
            <summary>
            Creates an optimized encoding mapping that can be consumed by an optimized version of charmap_encode.
            </summary>
        </member>
        <member name="M:IronPython.Modules.PythonCodecs.charmap_decode(System.String,System.String,System.String)">
            <summary>
            Decodes the input string using the provided string mapping.
            </summary>
        </member>
        <member name="M:IronPython.Modules.PythonCodecs.charmap_encode(System.String,System.String,IronPython.Modules.PythonCodecs.EncodingMap)">
            <summary>
            Encodes the input string with the specified optimized encoding map.
            </summary>
        </member>
        <member name="T:IronPython.Modules.PythonCodecs.EncodingMap">
            <summary>
            Optimied encoding mapping that can be consumed by charmap_encode.
            </summary>
        </member>
        <member name="T:IronPython.Modules.ModuleOps">
            <summary>
            Provides helper functions which need to be called from generated code to implement various 
            portions of modules.
            </summary>
        </member>
        <member name="M:IronPython.Modules.PythonIOModule.GetBytes(System.Object,System.String)">
            <summary>
            Convert string or bytes into bytes
            </summary>
        </member>
        <member name="M:IronPython.Modules.PythonIOModule.GetBytes(System.Object)">
            <summary>
            Convert most bytearray-like objects into IList of byte
            </summary>
        </member>
        <member name="T:IronPython.Modules.PythonIOModule.BytesIO">
            <summary>
            BytesIO([initializer]) -> object
            
            Create a buffered I/O implementation using an in-memory bytes
            buffer, ready for reading and writing.
            </summary>
        </member>
        <member name="M:IronPython.Modules.PythonIOModule.BytesIO.close(IronPython.Runtime.CodeContext)">
            <summary>
            close() -> None.  Disable all I/O operations.
            </summary>
        </member>
        <member name="M:IronPython.Modules.PythonIOModule.BytesIO.getvalue">
            <summary>
            getvalue() -> bytes.
            
            Retrieve the entire contents of the BytesIO object.
            </summary>
        </member>
        <member name="P:IronPython.Modules.PythonIOModule.BytesIO.closed">
            <summary>
            True if the file is closed.
            </summary>
        </member>
        <member name="M:IronPython.Modules.PythonIOModule.TextIOWrapper.ReadChunk(IronPython.Runtime.CodeContext)">
            <summary>
            Read and decode the next chunk from the buffered reader. Returns true if EOF was
            not reached. Places decoded string in _decodedChars.
            </summary>
        </member>
        <member name="M:IronPython.Modules.PythonIOModule.FileIO.StandardizeMode(System.String)">
            <summary>
            Remove all 'b's from mode string to simplify parsing
            </summary>
        </member>
        <member name="M:IronPython.Modules.PythonCollections.deque.WalkDeque(IronPython.Modules.PythonCollections.deque.DequeWalker)">
            <summary>
            Walks the queue calling back to the specified delegate for
            each populated index in the queue.
            </summary>
        </member>
        <member name="M:IronPython.Modules.PythonCopyReg.EnsureCallable(IronPython.Runtime.CodeContext,System.Object,System.String)">
            <summary>
            Throw TypeError with a specified message if object isn't callable.
            </summary>
        </member>
        <member name="M:IronPython.Modules.PythonCopyReg.GetCode(IronPython.Runtime.CodeContext,System.Object)">
            <summary>
            Convert object to ushort, throwing ValueError on overflow.
            </summary>
        </member>
        <member name="T:IronPython.Modules.PythonPickle.FileInput">
            <summary>
            Interface for "file-like objects" that implement the protocol needed by load() and friends.
            This enables the creation of thin wrappers that make fast .NET types and slow Python types look the same.
            </summary>
        </member>
        <member name="T:IronPython.Modules.PythonPickle.FileOutput">
            <summary>
            Interface for "file-like objects" that implement the protocol needed by dump() and friends.
            This enables the creation of thin wrappers that make fast .NET types and slow Python types look the same.
            </summary>
        </member>
        <member name="M:IronPython.Modules.PythonPickle.PicklerObject.SaveObject(IronPython.Modules.PythonPickle.PicklerObject,IronPython.Runtime.CodeContext,System.Object)">
            <summary>
            Call the appropriate reduce method for obj and pickle the object using
            the resulting data. Use the first available of
            copy_reg.dispatch_table[type(obj)], obj.__reduce_ex__, and obj.__reduce__.
            </summary>
        </member>
        <member name="M:IronPython.Modules.PythonPickle.PicklerObject.SaveReduce(IronPython.Runtime.CodeContext,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object)">
            <summary>
            Pickle the result of a reduce function.
            
            Only context, obj, func, and reduceCallable are required; all other arguments may be null.
            </summary>
        </member>
        <member name="M:IronPython.Modules.PythonPickle.PicklerObject.WriteFloatAsString(IronPython.Runtime.CodeContext,System.Object)">
            <summary>
            Write value in pickle decimalnl_short format.
            </summary>
        </member>
        <member name="M:IronPython.Modules.PythonPickle.PicklerObject.WriteFloat64(IronPython.Runtime.CodeContext,System.Object)">
            <summary>
            Write value in pickle float8 format.
            </summary>
        </member>
        <member name="M:IronPython.Modules.PythonPickle.PicklerObject.WriteUInt8(IronPython.Runtime.CodeContext,System.Object)">
            <summary>
            Write value in pickle uint1 format.
            </summary>
        </member>
        <member name="M:IronPython.Modules.PythonPickle.PicklerObject.WriteUInt16(IronPython.Runtime.CodeContext,System.Object)">
            <summary>
            Write value in pickle uint2 format.
            </summary>
        </member>
        <member name="M:IronPython.Modules.PythonPickle.PicklerObject.WriteInt32(IronPython.Runtime.CodeContext,System.Object)">
            <summary>
            Write value in pickle int4 format.
            </summary>
        </member>
        <member name="M:IronPython.Modules.PythonPickle.PicklerObject.WriteIntAsString(IronPython.Runtime.CodeContext,System.Object)">
            <summary>
            Write value in pickle decimalnl_short format.
            </summary>
        </member>
        <member name="M:IronPython.Modules.PythonPickle.PicklerObject.WriteIntAsString(IronPython.Runtime.CodeContext,System.Int32)">
            <summary>
            Write value in pickle decimalnl_short format.
            </summary>
        </member>
        <member name="M:IronPython.Modules.PythonPickle.PicklerObject.WriteLongAsString(IronPython.Runtime.CodeContext,System.Object)">
            <summary>
            Write value in pickle decimalnl_long format.
            </summary>
        </member>
        <member name="M:IronPython.Modules.PythonPickle.PicklerObject.WriteUnicodeStringRaw(IronPython.Runtime.CodeContext,System.Object)">
            <summary>
            Write value in pickle unicodestringnl format.
            </summary>
        </member>
        <member name="M:IronPython.Modules.PythonPickle.PicklerObject.WriteUnicodeStringUtf8(IronPython.Runtime.CodeContext,System.Object)">
            <summary>
            Write value in pickle unicodestring4 format.
            </summary>
        </member>
        <member name="M:IronPython.Modules.PythonPickle.PicklerObject.WriteStringPair(IronPython.Runtime.CodeContext,System.Object,System.Object)">
            <summary>
            Write value in pickle stringnl_noescape_pair format.
            </summary>
        </member>
        <member name="M:IronPython.Modules.PythonPickle.PicklerObject.IsUInt8(IronPython.Runtime.CodeContext,System.Object)">
            <summary>
            Return true if value is appropriate for formatting in pickle uint1 format.
            </summary>
        </member>
        <member name="M:IronPython.Modules.PythonPickle.PicklerObject.IsUInt16(IronPython.Runtime.CodeContext,System.Object)">
            <summary>
            Return true if value is appropriate for formatting in pickle uint2 format.
            </summary>
        </member>
        <member name="M:IronPython.Modules.PythonPickle.PicklerObject.IsInt32(IronPython.Runtime.CodeContext,System.Object)">
            <summary>
            Return true if value is appropriate for formatting in pickle int4 format.
            </summary>
        </member>
        <member name="M:IronPython.Modules.PythonPickle.PicklerObject.BatchAppends(IronPython.Runtime.CodeContext,System.Collections.IEnumerator)">
            <summary>
            Emit a series of opcodes that will set append all items indexed by iter
            to the object at the top of the stack. Use APPENDS if possible, but
            append no more than BatchSize items at a time.
            </summary>
        </member>
        <member name="M:IronPython.Modules.PythonPickle.PicklerObject.BatchSetItems(IronPython.Runtime.CodeContext,IronPython.Runtime.PythonDictionary)">
            <summary>
            Emit a series of opcodes that will set all (key, value) pairs indexed by
            iter in the object at the top of the stack. Use SETITEMS if possible,
            but append no more than BatchSize items at a time.
            </summary>
        </member>
        <member name="M:IronPython.Modules.PythonPickle.PicklerObject.BatchSetItems(IronPython.Runtime.CodeContext,System.Collections.IEnumerator)">
            <summary>
            Emit a series of opcodes that will set all (key, value) pairs indexed by
            iter in the object at the top of the stack. Use SETITEMS if possible,
            but append no more than BatchSize items at a time.
            </summary>
        </member>
        <member name="M:IronPython.Modules.PythonPickle.PicklerObject.FindModuleForGlobal(IronPython.Runtime.CodeContext,System.Object,System.Object)">
            <summary>
            Find the module for obj and ensure that obj is reachable in that module by the given name.
            
            Throw PicklingError if any of the following are true:
             - The module couldn't be determined.
             - The module couldn't be loaded.
             - The given name doesn't exist in the module.
             - The given name is a different object than obj.
            
            Otherwise, return the name of the module.
            
            To determine which module obj lives in, obj.__module__ is used if available. The
            module named by obj.__module__ is loaded if needed. If obj has no __module__
            attribute, then each loaded module is searched. If a loaded module has an
            attribute with the given name, and that attribute is the same object as obj,
            then that module is used.
            </summary>
        </member>
        <member name="M:IronPython.Modules.PythonPickle.UnpicklerObject.SetItems(IronPython.Runtime.PythonDictionary,System.Int32)">
            <summary>
            Interpret everything from markIndex to the top of the stack as a sequence
            of key, value, key, value, etc. Set dict[key] = value for each. Pop
            everything from markIndex up when done.
            </summary>
        </member>
        <member name="M:IronPython.Modules.PythonDateTime.date.CheckType(System.Object,System.Boolean)">
            <summary>
            Used to check the type to see if we can do a comparison.  Returns true if we can
            or false if we should return NotImplemented.  May throw if the type's really wrong.
            </summary>
        </member>
        <member name="M:IronPython.Modules.PythonDateTime.time.CompareTo(System.Object)">
            <summary>
            Helper function for doing the comparisons.  time has no __cmp__ method
            </summary>
        </member>
        <member name="T:IronPython.Modules.PythonIterTools.IterBase">
            <summary>
            Base class used for iterator wrappers.
            </summary>
        </member>
        <member name="M:IronPython.Modules.PythonCsvModule.GetDialects(IronPython.Runtime.CodeContext)">
            <summary>
            Returns the dialects from the code context.
            </summary>
            <param name="context"></param>
            <returns></returns>
        </member>
        <member name="M:IronPython.Modules.PythonLocale.LocaleInfo.CreateConventionsDict">
            <summary>
            Populates the given directory w/ the locale information from the given
            CultureInfo.
            </summary>
        </member>
        <member name="M:IronPython.Modules.PythonMath.erf(System.Double)">
            <summary>
            Error function on real values
            </summary>
        </member>
        <member name="M:IronPython.Modules.PythonMath.erfc(System.Double)">
            <summary>
            Complementary error function on real values: erfc(x) =  1 - erf(x)
            </summary>
        </member>
        <member name="M:IronPython.Modules.PythonMath.gamma(System.Double)">
            <summary>
            Gamma function on real values
            </summary>
        </member>
        <member name="M:IronPython.Modules.PythonMath.lgamma(System.Double)">
            <summary>
            Natural log of absolute value of Gamma function
            </summary>
        </member>
        <member name="M:IronPython.Modules.PythonNT.access(IronPython.Runtime.CodeContext,System.String,System.Int32)">
            <summary>
            Checks for the specific permissions, provided by the mode parameter, are available for the provided path.  Permissions can be:
            
            F_OK: Check to see if the file exists
            R_OK | W_OK | X_OK: Check for the specific permissions.  Only W_OK is respected.
            </summary>
        </member>
        <member name="F:IronPython.Modules.PythonNT.environ">
            <summary>
            single instance of environment dictionary is shared between multiple runtimes because the environment
            is shared by multiple runtimes.
            </summary>
        </member>
        <member name="M:IronPython.Modules.PythonNT.lstat(System.String)">
            <summary>
            lstat(path) -> stat result 
            Like stat(path), but do not follow symbolic links.
            </summary>
        </member>
        <member name="M:IronPython.Modules.PythonNT.spawnl(IronPython.Runtime.CodeContext,System.Int32,System.String,System.Object[])">
            <summary>
            spawns a new process.
            
            If mode is nt.P_WAIT then then the call blocks until the process exits and the return value
            is the exit code.
            
            Otherwise the call returns a handle to the process.  The caller must then call nt.waitpid(pid, options)
            to free the handle and get the exit code of the process.  Failure to call nt.waitpid will result
            in a handle leak.
            </summary>
        </member>
        <member name="M:IronPython.Modules.PythonNT.spawnle(IronPython.Runtime.CodeContext,System.Int32,System.String,System.Object[])">
            <summary>
            spawns a new process.
            
            If mode is nt.P_WAIT then then the call blocks until the process exits and the return value
            is the exit code.
            
            Otherwise the call returns a handle to the process.  The caller must then call nt.waitpid(pid, options)
            to free the handle and get the exit code of the process.  Failure to call nt.waitpid will result
            in a handle leak.
            </summary>
        </member>
        <member name="M:IronPython.Modules.PythonNT.spawnv(IronPython.Runtime.CodeContext,System.Int32,System.String,System.Object)">
            <summary>
            spawns a new process.
            
            If mode is nt.P_WAIT then then the call blocks until the process exits and the return value
            is the exit code.
            
            Otherwise the call returns a handle to the process.  The caller must then call nt.waitpid(pid, options)
            to free the handle and get the exit code of the process.  Failure to call nt.waitpid will result
            in a handle leak.
            </summary>
        </member>
        <member name="M:IronPython.Modules.PythonNT.spawnve(IronPython.Runtime.CodeContext,System.Int32,System.String,System.Object,System.Object)">
            <summary>
            spawns a new process.
            
            If mode is nt.P_WAIT then then the call blocks until the process exits and the return value
            is the exit code.
            
            Otherwise the call returns a handle to the process.  The caller must then call nt.waitpid(pid, options)
            to free the handle and get the exit code of the process.  Failure to call nt.waitpid will result
            in a handle leak.
            </summary>
        </member>
        <member name="M:IronPython.Modules.PythonNT.SetEnvironment(System.Collections.Specialized.StringDictionary,System.Object)">
            <summary>
            Copy elements from a Python mapping of dict environment variables to a StringDictionary.
            </summary>
        </member>
        <member name="M:IronPython.Modules.PythonNT.ArgumentsToString(IronPython.Runtime.CodeContext,System.Object)">
            <summary>
            Convert a sequence of args to a string suitable for using to spawn a process.
            </summary>
        </member>
        <member name="T:IronPython.Modules.PythonRegex">
            <summary>
            Python regular expression module.
            </summary>
        </member>
        <member name="M:IronPython.Modules.PythonRegex.PreParseRegex(IronPython.Runtime.CodeContext,System.String)">
            <summary>
            Preparses a regular expression text returning a ParsedRegex class
            that can be used for further regular expressions.
            </summary>
        </member>
        <member name="T:IronPython.Modules.PythonRegex.RE_Pattern">
            <summary>
            Compiled reg-ex pattern
            </summary>
        </member>
        <member name="M:IronPython.Modules.PythonSelect.ProcessSocketSequence(IronPython.Runtime.CodeContext,System.Object,IronPython.Runtime.List@,System.Collections.Generic.Dictionary{System.Net.Sockets.Socket,System.Object}@)">
            <summary>
            Process a sequence of objects that are compatible with ObjectToSocket(). Return two
            things as out params: an in-order List of sockets that correspond to the original
            objects in the passed-in sequence, and a mapping of these socket objects to their
            original objects.
            
            The socketToOriginal mapping is generated because the CPython select module supports
            passing to select either file descriptor numbers or an object with a fileno() method.
            We try to be faithful to what was originally requested when we return.
            </summary>
        </member>
        <member name="M:IronPython.Modules.PythonSelect.ObjectToSocket(IronPython.Runtime.CodeContext,System.Object)">
            <summary>
            Return the System.Net.Sockets.Socket object that corresponds to the passed-in
            object. obj can be a System.Net.Sockets.Socket, a PythonSocket.SocketObj, a
            long integer (representing a socket handle), or a Python object with a fileno()
            method (whose result is used to look up an existing PythonSocket.SocketObj,
            which is in turn converted to a Socket.
            </summary>
        </member>
        <member name="M:IronPython.Modules.PythonSocket.SignInsensitiveToInt32(System.Object)">
            <summary>
            Convert an object to a 32-bit integer. This adds two features to Converter.ToInt32:
              1. Sign is ignored. For example, 0xffff0000 converts to 4294901760, where Convert.ToInt32
                 would throw because 0xffff0000 is less than zero.
              2. Overflow exceptions are thrown. Converter.ToInt32 throws TypeError if x is
                 an integer, but is bigger than 32 bits. Instead, we throw OverflowException.
            </summary>
        </member>
        <member name="M:IronPython.Modules.PythonSocket.SignInsensitiveToInt16(System.Object)">
            <summary>
            Convert an object to a 16-bit integer. This adds two features to Converter.ToInt16:
              1. Sign is ignored. For example, 0xff00 converts to 65280, where Convert.ToInt16
                 would throw because signed 0xff00 is -256.
              2. Overflow exceptions are thrown. Converter.ToInt16 throws TypeError if x is
                 an integer, but is bigger than 16 bits. Instead, we throw OverflowException.
            </summary>
        </member>
        <member name="M:IronPython.Modules.PythonSocket.MakeException(IronPython.Runtime.CodeContext,System.Exception)">
            <summary>
            Return a standard socket exception (socket.error) whose message and error code come from a SocketException
            This will eventually be enhanced to generate the correct error type (error, herror, gaierror) based on the error code.
            </summary>
        </member>
        <member name="M:IronPython.Modules.PythonSocket.IPv6BytesToColonHex(System.Byte[])">
            <summary>
            Convert an IPv6 address byte array to a string in standard colon-hex notation.
            The .NET IPAddress.ToString() method uses dotted-quad for the last 32 bits,
            which differs from the normal Python implementation (but is allowed by the IETF);
            this method returns the standard (no dotted-quad) colon-hex form.
            </summary>
        </member>
        <member name="M:IronPython.Modules.PythonSocket.ConvertSpecialAddresses(System.String)">
            <summary>
            Handle conversion of "" to INADDR_ANY and "&lt;broadcast&gt;" to INADDR_BROADCAST.
            Otherwise returns host unchanged.
            </summary>
        </member>
        <member name="M:IronPython.Modules.PythonSocket.HostToAddress(IronPython.Runtime.CodeContext,System.String,System.Net.Sockets.AddressFamily)">
            <summary>
            Return the IP address associated with host, with optional address family checking.
            host may be either a name or an IP address (in string form).
            
            If family is non-null, a gaierror will be thrown if the host's address family is
            not the same as the specified family. gaierror is also raised if the hostname cannot be
            converted to an IP address (e.g. through a name lookup failure).
            </summary>
        </member>
        <member name="M:IronPython.Modules.PythonSocket.HostToAddresses(IronPython.Runtime.CodeContext,System.String,System.Net.Sockets.AddressFamily)">
            <summary>
            Return the IP address associated with host, with optional address family checking.
            host may be either a name or an IP address (in string form).
            
            If family is non-null, a gaierror will be thrown if the host's address family is
            not the same as the specified family. gaierror is also raised if the hostname cannot be
            converted to an IP address (e.g. through a name lookup failure).
            </summary>
        </member>
        <member name="M:IronPython.Modules.PythonSocket.RemoveLocalDomain(System.String)">
            <summary>
            Return fqdn, but with its domain removed if it's on the same domain as the local machine.
            </summary>
        </member>
        <member name="M:IronPython.Modules.PythonSocket.TupleToEndPoint(IronPython.Runtime.CodeContext,IronPython.Runtime.PythonTuple,System.Net.Sockets.AddressFamily,System.String@)">
            <summary>
            Convert a (host, port) tuple [IPv4] (host, port, flowinfo, scopeid) tuple [IPv6]
            to its corresponding IPEndPoint.
            
            Throws gaierror if host is not a valid address.
            Throws ArgumentTypeException if any of the following are true:
             - address does not have exactly two elements
             - address[0] is not a string
             - address[1] is not an int
            </summary>
        </member>
        <member name="M:IronPython.Modules.PythonSocket.EndPointToTuple(System.Net.IPEndPoint)">
            <summary>
            Convert an IPEndPoint to its corresponding (host, port) [IPv4] or (host, port, flowinfo, scopeid) [IPv6] tuple.
            Throws SocketException if the address family is other than IPv4 or IPv6.
            </summary>
        </member>
        <member name="F:IronPython.Modules.PythonSocket.socket._handleToSocket">
            <summary>
            handleToSocket allows us to translate from Python's idea of a socket resource (file
            descriptor numbers) to .NET's idea of a socket resource (System.Net.Socket objects).
            In particular, this allows the select module to convert file numbers (as returned by
            fileno()) and convert them to Socket objects so that it can do something useful with them.
            </summary>
        </member>
        <member name="M:IronPython.Modules.PythonSocket.socket.HandleToSocket(System.Int64)">
            <summary>
            Return the internal System.Net.Sockets.Socket socket object associated with the given
            handle (as returned by GetHandle()), or null if no corresponding socket exists. This is
            primarily intended to be used by other modules (such as select) that implement
            networking primitives. User code should not normally need to call this function.
            </summary>
        </member>
        <member name="M:IronPython.Modules.PythonSocket.socket.#ctor(IronPython.Runtime.CodeContext,System.Net.Sockets.Socket)">
            <summary>
            Create a Python socket object from an existing .NET socket object
            (like one returned from Socket.Accept())
            </summary>
        </member>
        <member name="M:IronPython.Modules.PythonSocket.socket.Initialize(IronPython.Runtime.CodeContext,System.Net.Sockets.Socket)">
            <summary>
            Perform initialization common to all constructors
            </summary>
        </member>
        <member name="T:IronPython.Modules.LocalOrArg">
            <summary>
            Wrapper class for emitting locals/variables during marshalling code gen.
            </summary>
        </member>
        <member name="T:IronPython.Modules.MemoryHolder">
            <summary>
            A wrapper around allocated memory to ensure it gets released and isn't accessed
            when it could be finalized.
            </summary>
        </member>
        <member name="M:IronPython.Modules.MemoryHolder.#ctor(System.Int32)">
            <summary>
            Creates a new MemoryHolder and allocates a buffer of the specified size.
            </summary>
        </member>
        <member name="M:IronPython.Modules.MemoryHolder.#ctor(System.IntPtr,System.Int32)">
            <summary>
            Creates a new MemoryHolder at the specified address which is not tracked
            by us and we will never free.
            </summary>
        </member>
        <member name="M:IronPython.Modules.MemoryHolder.#ctor(System.IntPtr,System.Int32,IronPython.Modules.MemoryHolder)">
            <summary>
            Creates a new MemoryHolder at the specified address which will keep alive the 
            parent memory holder.
            </summary>
        </member>
        <member name="M:IronPython.Modules.MemoryHolder.AddObject(System.Object,System.Object)">
            <summary>
            Used to track the lifetime of objects when one memory region depends upon
            another memory region.  For example if you have an array of objects that
            each have an element which has it's own lifetime the array needs to keep
            the individual elements alive.
            
            The keys used here match CPython's keys as tested by CPython's test_ctypes. 
            Typically they are a string which is the array index, "ffffffff" when
            from_buffer is used, or when it's a simple type there's just a string
            instead of the full dictionary - we store that under the key "str".
            </summary>
        </member>
        <member name="M:IronPython.Modules.MemoryHolder.CopyFrom(System.IntPtr,System.IntPtr)">
            <summary>
            Copies the data in data into this MemoryHolder.
            </summary>
        </member>
        <member name="M:IronPython.Modules.MemoryHolder.CopyTo(IronPython.Modules.MemoryHolder,System.Int32,System.Int32)">
            <summary>
            Copies memory from one location to another keeping the associated memory holders alive during the
            operation.
            </summary>
        </member>
        <member name="P:IronPython.Modules.MemoryHolder.UnsafeAddress">
            <summary>
            Gets the address of the held memory.  The caller should ensure the MemoryHolder
            is always alive as long as the address will continue to be accessed.
            </summary>
        </member>
        <member name="P:IronPython.Modules.MemoryHolder.Objects">
            <summary>
            Gets a list of objects which need to be kept alive for this MemoryHolder to be 
            remain valid.
            </summary>
        </member>
        <member name="T:IronPython.Modules.NativeFunctions">
            <summary>
            Native functions used for exposing ctypes functionality.
            </summary>
        </member>
        <member name="M:IronPython.Modules.NativeFunctions.Calloc(System.IntPtr)">
            <summary>
            Allocates memory that's zero-filled
            </summary>
        </member>
        <member name="M:IronPython.Modules.NativeFunctions.MemSet(System.IntPtr,System.Byte,System.IntPtr)">
            <summary>
            Helper function for implementing memset.  Could be more efficient if we 
            could P/Invoke or call some otherwise native code to do this.
            </summary>
        </member>
        <member name="T:IronPython.Modules.CTypes">
            <summary>
            Provides support for interop with native code from Python code.
            </summary>
            <summary>
            Provides support for interop with native code from Python code.
            </summary>
            <summary>
            Provides support for interop with native code from Python code.
            </summary>
            <summary>
            Provides support for interop with native code from Python code.
            </summary>
            <summary>
            Provides support for interop with native code from Python code.
            </summary>
            <summary>
            Provides support for interop with native code from Python code.
            </summary>
            <summary>
            Provides support for interop with native code from Python code.
            </summary>
            <summary>
            Provides support for interop with native code from Python code.
            </summary>
            <summary>
            Provides support for interop with native code from Python code.
            </summary>
            <summary>
            Provides support for interop with native code from Python code.
            </summary>
            <summary>
            Provides support for interop with native code from Python code.
            </summary>
            <summary>
            Provides support for interop with native code from Python code.
            </summary>
            <summary>
            Provides support for interop with native code from Python code.
            </summary>
            <summary>
            Provides support for interop with native code from Python code.
            </summary>
            <summary>
            Provides support for interop with native code from Python code.
            </summary>
            <summary>
            Provides support for interop with native code from Python code.
            </summary>
            <summary>
            Provides support for interop with native code from Python code.
            </summary>
            <summary>
            Provides support for interop with native code from Python code.
            </summary>
        </member>
        <member name="M:IronPython.Modules.CTypes.Cast(System.IntPtr,System.IntPtr,System.IntPtr)">
            <summary>
            Implementation of our cast function.  data is marshalled as a void*
            so it ends up as an address.  obj and type are marshalled as an object
            so we need to unmarshal them.
            </summary>
        </member>
        <member name="M:IronPython.Modules.CTypes.POINTER(IronPython.Runtime.CodeContext,IronPython.Runtime.Types.PythonType)">
            <summary>
            Returns a new type which represents a pointer given the existing type.
            </summary>
        </member>
        <member name="M:IronPython.Modules.CTypes.PyObj_FromPtr(System.IntPtr)">
            <summary>
            Converts an address acquired from PyObj_FromPtr or that has been
            marshaled as type 'O' back into an object.
            </summary>
        </member>
        <member name="M:IronPython.Modules.CTypes.PyObj_ToPtr(System.Object)">
            <summary>
            Converts an object into an opaque address which can be handed out to
            managed code.
            </summary>
        </member>
        <member name="M:IronPython.Modules.CTypes.Py_DECREF(System.Object)">
            <summary>
            Decreases the ref count on an object which has been increased with
            Py_INCREF.
            </summary>
        </member>
        <member name="M:IronPython.Modules.CTypes.Py_INCREF(System.Object)">
            <summary>
            Increases the ref count on an object ensuring that it will not be collected.
            </summary>
        </member>
        <member name="M:IronPython.Modules.CTypes.addressof(IronPython.Modules.CTypes.CData)">
            <summary>
            returns address of C instance internal buffer.
            
            It is the callers responsibility to ensure that the provided instance will 
            stay alive if memory in the resulting address is to be used later.
            </summary>
        </member>
        <member name="M:IronPython.Modules.CTypes.alignment(IronPython.Runtime.Types.PythonType)">
            <summary>
            Gets the required alignment of the given type.
            </summary>
        </member>
        <member name="M:IronPython.Modules.CTypes.alignment(System.Object)">
            <summary>
            Gets the required alignment of an object.
            </summary>
        </member>
        <member name="M:IronPython.Modules.CTypes.pointer(IronPython.Runtime.CodeContext,IronPython.Modules.CTypes.CData)">
            <summary>
            Returns a pointer instance for the given CData
            </summary>
        </member>
        <member name="M:IronPython.Modules.CTypes.GetMarshalTypeFromSize(System.Int32)">
            <summary>
            Given a specific size returns a .NET type of the equivalent size that
            we can use when marshalling these values across calls.
            </summary>
        </member>
        <member name="M:IronPython.Modules.CTypes.GetFieldInfo(IronPython.Modules.CTypes.INativeType,System.Object,System.String@,IronPython.Modules.CTypes.INativeType@,System.Nullable{System.Int32}@)">
            <summary>
            Shared helper between struct and union for getting field info and validating it.
            </summary>
        </member>
        <member name="M:IronPython.Modules.CTypes.CheckBits(IronPython.Modules.CTypes.INativeType,IronPython.Runtime.PythonTuple)">
            <summary>
            Verifies that the provided bit field settings are valid for this type.
            </summary>
        </member>
        <member name="M:IronPython.Modules.CTypes.GetFieldsList(System.Object)">
            <summary>
            Shared helper to get the _fields_ list for struct/union and validate it.
            </summary>
        </member>
        <member name="M:IronPython.Modules.CTypes.StringAt(System.IntPtr,System.Int32)">
            <summary>
            Helper function for translating from memset to NT's FillMemory API.
            </summary>
        </member>
        <member name="M:IronPython.Modules.CTypes.WStringAt(System.IntPtr,System.Int32)">
            <summary>
            Helper function for translating from memset to NT's FillMemory API.
            </summary>
        </member>
        <member name="M:IronPython.Modules.CTypes.EmitCDataCreation(IronPython.Modules.CTypes.INativeType,System.Reflection.Emit.ILGenerator,System.Collections.Generic.List{System.Object},System.Int32)">
            <summary>
            Emits the marshalling code to create a CData object for reverse marshalling.
            </summary>
        </member>
        <member name="P:IronPython.Modules.CTypes._cast_addr">
            <summary>
            Gets a function which casts the specified memory.  Because this is used only
            w/ Python API we use a delegate as the return type instead of an actual address.
            </summary>
        </member>
        <member name="P:IronPython.Modules.CTypes.DynamicModule">
            <summary>
            Gets the ModuleBuilder used to generate our unsafe call stubs into.
            </summary>
        </member>
        <member name="T:IronPython.Modules.CTypes.SimpleTypeKind">
            <summary>
            The enum used for tracking the various ctypes primitive types.
            </summary>
        </member>
        <member name="F:IronPython.Modules.CTypes.SimpleTypeKind.Char">
            <summary> 'c' </summary>
        </member>
        <member name="F:IronPython.Modules.CTypes.SimpleTypeKind.SignedByte">
            <summary> 'b' </summary>
        </member>
        <member name="F:IronPython.Modules.CTypes.SimpleTypeKind.UnsignedByte">
            <summary> 'B' </summary>
        </member>
        <member name="F:IronPython.Modules.CTypes.SimpleTypeKind.SignedShort">
            <summary> 'h' </summary>
        </member>
        <member name="F:IronPython.Modules.CTypes.SimpleTypeKind.UnsignedShort">
            <summary> 'H' </summary>
        </member>
        <member name="F:IronPython.Modules.CTypes.SimpleTypeKind.SignedInt">
            <summary> 'i' </summary>
        </member>
        <member name="F:IronPython.Modules.CTypes.SimpleTypeKind.UnsignedInt">
            <summary> 'I' </summary>
        </member>
        <member name="F:IronPython.Modules.CTypes.SimpleTypeKind.SignedLong">
            <summary> 'l' </summary>
        </member>
        <member name="F:IronPython.Modules.CTypes.SimpleTypeKind.UnsignedLong">
            <summary> 'L' </summary>
        </member>
        <member name="F:IronPython.Modules.CTypes.SimpleTypeKind.Single">
            <summary> 'f' </summary>
        </member>
        <member name="F:IronPython.Modules.CTypes.SimpleTypeKind.Double">
            <summary> 'd', 'g' </summary>
        </member>
        <member name="F:IronPython.Modules.CTypes.SimpleTypeKind.SignedLongLong">
            <summary> 'q' </summary>
        </member>
        <member name="F:IronPython.Modules.CTypes.SimpleTypeKind.UnsignedLongLong">
            <summary> 'Q' </summary>
        </member>
        <member name="F:IronPython.Modules.CTypes.SimpleTypeKind.Object">
            <summary> 'O' </summary>
        </member>
        <member name="F:IronPython.Modules.CTypes.SimpleTypeKind.Pointer">
            <summary> 'P' </summary>
        </member>
        <member name="F:IronPython.Modules.CTypes.SimpleTypeKind.CharPointer">
            <summary> 'z' </summary>
        </member>
        <member name="F:IronPython.Modules.CTypes.SimpleTypeKind.WCharPointer">
            <summary> 'Z' </summary>
        </member>
        <member name="F:IronPython.Modules.CTypes.SimpleTypeKind.WChar">
            <summary> 'u' </summary>
        </member>
        <member name="F:IronPython.Modules.CTypes.SimpleTypeKind.Boolean">
            <summary> '?' </summary>
        </member>
        <member name="F:IronPython.Modules.CTypes.SimpleTypeKind.VariantBool">
            <summary> 'v' </summary>
        </member>
        <member name="F:IronPython.Modules.CTypes.SimpleTypeKind.BStr">
            <summary> 'X' </summary>
        </member>
        <member name="T:IronPython.Modules.CTypes.CData">
            <summary>
            Base class for all ctypes interop types.
            </summary>
        </member>
        <member name="T:IronPython.Modules.CTypes.ArrayType">
            <summary>
            The meta class for ctypes array instances.
            </summary>
        </member>
        <member name="T:IronPython.Modules.CTypes.INativeType">
            <summary>
            Common functionality that all of the meta classes provide which is part of
            our implementation.  This is used to implement the serialization/deserialization
            of values into/out of memory, emit the marshalling logic for call stubs, and
            provide common information (size/alignment) for the types.
            </summary>
        </member>
        <member name="M:IronPython.Modules.CTypes.INativeType.GetValue(IronPython.Modules.MemoryHolder,System.Object,System.Int32,System.Boolean)">
            <summary>
            Deserialized the value of this type from the given address at the given
            offset.  Any new objects which are created will keep the provided 
            MemoryHolder alive.
            
            raw determines if the cdata is returned or if the primitive value is
            returned.  This is only applicable for subtypes of simple cdata types.
            </summary>
        </member>
        <member name="M:IronPython.Modules.CTypes.INativeType.SetValue(IronPython.Modules.MemoryHolder,System.Int32,System.Object)">
            <summary>
            Serializes the provided value into the specified address at the given
            offset.
            </summary>
        </member>
        <member name="M:IronPython.Modules.CTypes.INativeType.GetNativeType">
            <summary>
            Gets the .NET type which is used when calling or returning the value
            from native code.
            </summary>
        </member>
        <member name="M:IronPython.Modules.CTypes.INativeType.GetPythonType">
            <summary>
            Gets the .NET type which the native type is converted into when going to Python
            code.  This is usually int, BigInt, double, object, or a CData type.
            </summary>
        </member>
        <member name="M:IronPython.Modules.CTypes.INativeType.EmitMarshalling(System.Reflection.Emit.ILGenerator,IronPython.Modules.LocalOrArg,System.Collections.Generic.List{System.Object},System.Int32)">
            <summary>
            Emits marshalling of an object from Python to native code.  This produces the
            native type from the Python type.
            </summary>
        </member>
        <member name="M:IronPython.Modules.CTypes.INativeType.EmitReverseMarshalling(System.Reflection.Emit.ILGenerator,IronPython.Modules.LocalOrArg,System.Collections.Generic.List{System.Object},System.Int32)">
            <summary>
            Emits marshalling from native code to Python code This produces the python type 
            from the native type.  This is used for return values and parameters 
            to Python callable objects that are passed back out to native code.
            </summary>
        </member>
        <member name="P:IronPython.Modules.CTypes.INativeType.Size">
            <summary>
            Gets the native size of the type
            </summary>
        </member>
        <member name="P:IronPython.Modules.CTypes.INativeType.Alignment">
            <summary>
            Gets the required alignment for the type
            </summary>
        </member>
        <member name="P:IronPython.Modules.CTypes.INativeType.TypeFormat">
            <summary>
            Returns a string which describes the type.  Used for _buffer_info implementation which
            only exists for testing purposes.
            </summary>
        </member>
        <member name="M:IronPython.Modules.CTypes.ArrayType.from_param(System.Object)">
            <summary>
            Converts an object into a function call parameter.
            </summary>
        </member>
        <member name="M:IronPython.Modules.CTypes._CFuncPtr.#ctor(IronPython.Runtime.PythonTuple)">
            <summary>
            Creates a new CFuncPtr object from a tuple.  The 1st element of the
            tuple is the ordinal or function name.  The second is an object with
            a _handle property.  The _handle property is the handle of the module
            from which the function will be loaded.
            </summary>
        </member>
        <member name="M:IronPython.Modules.CTypes._CFuncPtr.#ctor(System.Int32,System.String)">
            <summary>
            Creates a new CFuncPtr which calls a COM method.
            </summary>
        </member>
        <member name="M:IronPython.Modules.CTypes._CFuncPtr.#ctor(System.Int32)">
            <summary>
            Creates a new CFuncPtr with the specfied address.
            </summary>
        </member>
        <member name="M:IronPython.Modules.CTypes._CFuncPtr.#ctor(System.Numerics.BigInteger)">
            <summary>
            Creates a new CFuncPtr with the specfied address.
            </summary>
        </member>
        <member name="M:IronPython.Modules.CTypes._CFuncPtr.Meta.AddKeepAlives(IronPython.Modules.CTypes._CFuncPtr.Meta.ArgumentMarshaller[],System.Collections.Generic.List{System.Linq.Expressions.Expression})">
            <summary>
            we need to keep alive any methods which have arguments for the duration of the
            call.  Otherwise they could be collected on the finalizer thread before we come back.
            </summary>
        </member>
        <member name="M:IronPython.Modules.CTypes._CFuncPtr.Meta.CreateInteropInvoker(System.Runtime.InteropServices.CallingConvention,IronPython.Modules.CTypes._CFuncPtr.Meta.ArgumentMarshaller[],IronPython.Modules.CTypes.INativeType,System.Boolean,System.Collections.Generic.List{System.Object})">
            <summary>
            Creates a method for calling with the specified signature.  The returned method has a signature
            of the form:
            
            (IntPtr funcAddress, arg0, arg1, ..., object[] constantPool)
            
            where IntPtr is the address of the function to be called.  The arguments types are based upon
            the types that the ArgumentMarshaller requires.
            </summary>
        </member>
        <member name="T:IronPython.Modules.CTypes._CFuncPtr.Meta.ArgumentMarshaller">
            <summary>
            Base class for marshalling arguments from the user provided value to the
            call stub.  This class provides the logic for creating the call stub and
            calling it.
            </summary>
        </member>
        <member name="M:IronPython.Modules.CTypes._CFuncPtr.Meta.ArgumentMarshaller.EmitCallStubArgument(System.Reflection.Emit.ILGenerator,System.Int32,System.Collections.Generic.List{System.Object},System.Int32)">
            <summary>
            Emits the IL to get the argument for the call stub generated into
            a dynamic method.
            </summary>
        </member>
        <member name="M:IronPython.Modules.CTypes._CFuncPtr.Meta.ArgumentMarshaller.GetKeepAlive">
            <summary>
            Gets an expression which keeps alive the argument for the duration of the call.  
            
            Returns null if a keep alive is not necessary.
            </summary>
        </member>
        <member name="P:IronPython.Modules.CTypes._CFuncPtr.Meta.ArgumentMarshaller.ArgumentExpression">
            <summary>
            Gets the expression used to provide the argument.  This is the expression
            from an incoming DynamicMetaObject.
            </summary>
        </member>
        <member name="T:IronPython.Modules.CTypes._CFuncPtr.Meta.PrimitiveMarshaller">
            <summary>
            Provides marshalling of primitive values when the function type
            has no type information or when the user has provided us with
            an explicit cdata instance.
            </summary>
        </member>
        <member name="T:IronPython.Modules.CTypes._CFuncPtr.Meta.CDataMarshaller">
            <summary>
            Provides marshalling for when the function type provide argument information.
            </summary>
        </member>
        <member name="T:IronPython.Modules.CTypes._CFuncPtr.Meta.NativeArgumentMarshaller">
            <summary>
            Provides marshalling for when the user provides a native argument object
            (usually gotten by byref or pointer) and the function type has no type information.
            </summary>
        </member>
        <member name="T:IronPython.Modules.CTypes.CFuncPtrType">
            <summary>
            The meta class for ctypes function pointer instances.
            </summary>
        </member>
        <member name="M:IronPython.Modules.CTypes.CFuncPtrType.from_param(System.Object)">
            <summary>
            Converts an object into a function call parameter.
            </summary>
        </member>
        <member name="T:IronPython.Modules.CTypes.Field">
            <summary>
            Fields are created when a Structure is defined and provide
            introspection of the structure.
            </summary>
        </member>
        <member name="M:IronPython.Modules.CTypes.Field.ExtractBits(System.Object)">
            <summary>
            Called for fields which have been limited to a range of bits.  Given the
            value for the full type this extracts the individual bits.
            </summary>
        </member>
        <member name="M:IronPython.Modules.CTypes.Field.SetBitsValue(IronPython.Modules.MemoryHolder,System.Int32,System.Object)">
            <summary>
            Called for fields which have been limited to a range of bits.  Sets the 
            specified value into the bits for the field.
            </summary>
        </member>
        <member name="T:IronPython.Modules.CTypes.PointerType">
            <summary>
            The meta class for ctypes pointers.
            </summary>
        </member>
        <member name="M:IronPython.Modules.CTypes.PointerType.from_param(IronPython.Modules.CTypes.Pointer)">
            <summary>
            Converts an object into a function call parameter.
            </summary>
        </member>
        <member name="M:IronPython.Modules.CTypes.PointerType.from_address(System.Object)">
            <summary>
            Access an instance at the specified address
            </summary>
        </member>
        <member name="T:IronPython.Modules.CTypes.SimpleType">
            <summary>
            The meta class for ctypes simple data types.  These include primitives like ints,
            floats, etc... char/wchar pointers, and untyped pointers.
            </summary>
        </member>
        <member name="M:IronPython.Modules.CTypes.SimpleType.from_param(System.Object)">
            <summary>
            Converts an object into a function call parameter.
            </summary>
        </member>
        <member name="M:IronPython.Modules.CTypes.SimpleType.ReadChar(IronPython.Modules.MemoryHolder,System.Int32)">
            <summary>
            Helper function for reading char/wchar's.  This is used for reading from
            arrays and pointers to avoid creating lots of 1-char strings.
            </summary>
        </member>
        <member name="T:IronPython.Modules.CTypes.StructType">
            <summary>
            Meta class for structures.  Validates _fields_ on creation, provides factory
            methods for creating instances from addresses and translating to parameters.
            </summary>
        </member>
        <member name="M:IronPython.Modules.CTypes.StructType.from_param(System.Object)">
            <summary>
            Converts an object into a function call parameter.
            
            Structures just return themselves.
            </summary>
        </member>
        <member name="M:IronPython.Modules.CTypes.StructType.EnsureSizeAndAlignment">
            <summary>
            If our size/alignment hasn't been initialized then grabs the size/alignment
            from all of our base classes.  If later new _fields_ are added we'll be
            initialized and these values will be replaced.
            </summary>
        </member>
        <member name="T:IronPython.Modules.CTypes._Structure">
            <summary>
            Base class for data structures.  Subclasses can define _fields_ which 
            specifies the in memory layout of the values.  Instances can then
            be created with the initial values provided as the array.  The values
            can then be accessed from the instance by field name.  The value can also
            be passed to a foreign C API and the type can be used in other structures.
            
            class MyStructure(Structure):
                _fields_ = [('a', c_int), ('b', c_int)]
                
            MyStructure(1, 2).a
            MyStructure()
            
            class MyOtherStructure(Structure):
                _fields_ = [('c', MyStructure), ('b', c_int)]
                
            MyOtherStructure((1, 2), 3)
            MyOtherStructure(MyStructure(1, 2), 3)
            </summary>
        </member>
        <member name="T:IronPython.Modules.CTypes.UnionType">
            <summary>
            The meta class for ctypes unions.
            </summary>
        </member>
        <member name="M:IronPython.Modules.CTypes.UnionType.from_param(System.Object)">
            <summary>
            Converts an object into a function call parameter.
            </summary>
        </member>
        <member name="T:IronPython.Modules.PythonStruct.FormatType">
            <summary>
            Enum which specifies the format type for a compiled struct
            </summary>
        </member>
        <member name="T:IronPython.Modules.PythonStruct.Format">
            <summary>
            Struct used to store the format and the number of times it should be repeated.
            </summary>
        </member>
        <member name="M:IronPython.Modules.PythonThread.interrupt_main(IronPython.Runtime.CodeContext)">
            <summary>
            Stops execution of Python or other .NET code on the main thread.  If the thread is
            blocked in native code the thread will be interrupted after it returns back to Python
            or other .NET code.  
            </summary>
        </member>
        <member name="T:IronPython.Modules.PythonThread._local.ThreadLocalDictionaryStorage">
            <summary>
            Provides a dictionary storage implementation whose storage is local to
            the thread.
            </summary>
        </member>
        <member name="T:IronPython.Modules.PythonTime.FoundDateComponents">
            <summary>
            Represents the date components that we found while parsing the date.  Used for zeroing out values
            which have different defaults from CPython.  Currently we only know that we need to do this for
            the year.
            </summary>
        </member>
        <member name="T:IronPython.Modules.xxsubtype">
            <summary>
            Samples on how to subtype built-in types from C#
            </summary>
        </member>
        <member name="P:IronPython.Modules.xxsubtype.spamlist.state">
            <summary>
            an int variable for demonstration purposes
            </summary>
        </member>
        <member name="P:IronPython.Modules.xxsubtype.spamdict.state">
            <summary>
            an int variable for demonstration purposes
            </summary>
        </member>
        <member name="T:IronPython.Modules.FunctionTools.partial">
            <summary>
            Returns a new callable object with the provided initial set of arguments
            bound to it.  Calling the new function then appends to the additional
            user provided arguments.
            </summary>
        </member>
        <member name="M:IronPython.Modules.FunctionTools.partial.#ctor(IronPython.Runtime.CodeContext,System.Object,System.Object[])">
            <summary>
            Creates a new partial object with the provided positional arguments.
            </summary>
        </member>
        <member name="M:IronPython.Modules.FunctionTools.partial.#ctor(IronPython.Runtime.CodeContext,System.Object,System.Collections.Generic.IDictionary{System.Object,System.Object},System.Object[])">
            <summary>
            Creates a new partial object with the provided positional and keyword arguments.
            </summary>
        </member>
        <member name="M:IronPython.Modules.FunctionTools.partial.Call(IronPython.Runtime.CodeContext,System.Object[])">
            <summary>
            Calls func with the previously provided arguments and more positional arguments.
            </summary>
        </member>
        <member name="M:IronPython.Modules.FunctionTools.partial.Call(IronPython.Runtime.CodeContext,System.Collections.Generic.IDictionary{System.Object,System.Object},System.Object[])">
            <summary>
            Calls func with the previously provided arguments and more positional arguments and keyword arguments.
            </summary>
        </member>
        <member name="M:IronPython.Modules.FunctionTools.partial.SetMemberAfter(IronPython.Runtime.CodeContext,System.String,System.Object)">
            <summary>
            Operator method to set arbitrary members on the partial object.
            </summary>
        </member>
        <member name="M:IronPython.Modules.FunctionTools.partial.GetBoundMember(IronPython.Runtime.CodeContext,System.String)">
            <summary>
            Operator method to get additional arbitrary members defined on the partial object.
            </summary>
        </member>
        <member name="M:IronPython.Modules.FunctionTools.partial.DeleteMember(IronPython.Runtime.CodeContext,System.String)">
            <summary>
            Operator method to delete arbitrary members defined in the partial object.
            </summary>
        </member>
        <member name="P:IronPython.Modules.FunctionTools.partial.func">
            <summary>
            Gets the function which will be called
            </summary>
        </member>
        <member name="P:IronPython.Modules.FunctionTools.partial.args">
            <summary>
            Gets the initially provided positional arguments.
            </summary>
        </member>
        <member name="P:IronPython.Modules.FunctionTools.partial.keywords">
            <summary>
            Gets the initially provided keyword arguments or None.
            </summary>
        </member>
        <member name="P:IronPython.Modules.FunctionTools.partial.__dict__">
            <summary>
            Gets or sets the dictionary used for storing extra attributes on the partial object.
            </summary>
        </member>
        <member name="M:IronPython.Modules.PythonSsl.ReadInt(System.Byte[],System.Int32@)">
            <summary>
            BER encoding of an integer value is the number of bytes
            required to represent the integer followed by the bytes
            </summary>
        </member>
        <member name="M:IronPython.Modules.PythonSubprocess.DuplicateHandle(IronPython.Runtime.CodeContext,System.Numerics.BigInteger,IronPython.Modules.PythonSubprocessHandle,System.Numerics.BigInteger,System.Int32,System.Boolean,System.Object)">
            <summary>
            Duplicates a subprocess handle which was created for piping.
            
            This is only called when we're duplicating the handle to make it inheritable to the child process.  In CPython
            the parent handle is always reliably garbage collected.  Because we know this handle is not going to be 
            used we close the handle being duplicated.
            </summary>
        </member>
        <member name="M:IronPython.Modules.PythonWeakRef.ref.__hash__(IronPython.Runtime.CodeContext)">
            <summary>
            Special hash function because IStructuralEquatable.GetHashCode is not allowed to throw.
            </summary>
        </member>
        <member name="M:IronPython.Modules.PythonWeakRef.ref.RefEquals(System.Object,System.Object,System.Collections.IEqualityComparer)">
            <summary>
            Special equals because none of the special cases in Ops.Equals
            are applicable here, and the reference equality check breaks some tests.
            </summary>
        </member>
        <member name="M:IronPython.Modules.PythonWeakRef.weakproxy.GetObject">
            <summary>
            gets the object or throws a reference exception
            </summary>
        </member>
        <member name="M:IronPython.Modules.PythonWeakRef.weakproxy.__eq__(System.Object)">
            <summary>
            Special equality function because IStructuralEquatable.Equals is not allowed to throw.
            </summary>
        </member>
        <member name="M:IronPython.Modules.PythonWeakRef.weakcallableproxy.GetObject">
            <summary>
            gets the object or throws a reference exception
            </summary>
        </member>
        <member name="M:IronPython.Modules.PythonWeakRef.weakcallableproxy.__eq__(System.Object)">
            <summary>
            Special equality function because IStructuralEquatable.Equals is not allowed to throw.
            </summary>
        </member>
        <member name="M:IronPython.Modules.PythonWinReg.HKEYType.GetKey">
            <summary>
            Returns the underlying .NET RegistryKey
            </summary>
            <returns></returns>
        </member>
    </members>
</doc>
