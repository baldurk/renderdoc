/******************************************************************************
 * The MIT License (MIT)
 *
 * Copyright (c) 2019-2021 Baldur Karlsson
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 ******************************************************************************/

/******************************************************************************
 * Generated from Khronos SPIR-V machine-readable JSON grammar.
 *
 * Copyright (c) 2014-2020 The Khronos Group Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and/or associated documentation files (the "Materials"),
 * to deal in the Materials without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Materials, and to permit persons to whom the
 * Materials are furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Materials.
 *
 * MODIFICATIONS TO THIS FILE MAY MEAN IT NO LONGER ACCURATELY REFLECTS KHRONOS
 * STANDARDS. THE UNMODIFIED, NORMATIVE VERSIONS OF KHRONOS SPECIFICATIONS AND
 * HEADER INFORMATION ARE LOCATED AT https://www.khronos.org/registry/
 *
 * THE MATERIALS ARE PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM,OUT OF OR IN CONNECTION WITH THE MATERIALS OR THE USE OR OTHER DEALINGS
 * IN THE MATERIALS.
 ******************************************************************************/

// This file is autogenerated with gen_spirv_code.py - any changes will be overwritten next time
// that script is run.
// $ ./gen_spirv_code.py

// We need to disable clang-format since this file is programmatically generated
// clang-format off

#include "spirv_gen.h"
#include "os/os_specific.h"
#include "common/formatting.h"
#include "spirv_op_helpers.h"

template <>
rdcstr DoStringise(const rdcspv::ImageOperands &el)
{
  BEGIN_BITFIELD_STRINGISE(rdcspv::ImageOperands);
  {
    STRINGISE_BITFIELD_CLASS_VALUE(None);

    STRINGISE_BITFIELD_CLASS_BIT(Bias);
    STRINGISE_BITFIELD_CLASS_BIT(Lod);
    STRINGISE_BITFIELD_CLASS_BIT(Grad);
    STRINGISE_BITFIELD_CLASS_BIT(ConstOffset);
    STRINGISE_BITFIELD_CLASS_BIT(Offset);
    STRINGISE_BITFIELD_CLASS_BIT(ConstOffsets);
    STRINGISE_BITFIELD_CLASS_BIT(Sample);
    STRINGISE_BITFIELD_CLASS_BIT(MinLod);
    STRINGISE_BITFIELD_CLASS_BIT(MakeTexelAvailable);
    STRINGISE_BITFIELD_CLASS_BIT(MakeTexelVisible);
    STRINGISE_BITFIELD_CLASS_BIT(NonPrivateTexel);
    STRINGISE_BITFIELD_CLASS_BIT(VolatileTexel);
    STRINGISE_BITFIELD_CLASS_BIT(SignExtend);
    STRINGISE_BITFIELD_CLASS_BIT(ZeroExtend);
  }
  END_BITFIELD_STRINGISE();
}

template <>
rdcstr DoStringise(const rdcspv::FPFastMathMode &el)
{
  BEGIN_BITFIELD_STRINGISE(rdcspv::FPFastMathMode);
  {
    STRINGISE_BITFIELD_CLASS_VALUE(None);

    STRINGISE_BITFIELD_CLASS_BIT(NotNaN);
    STRINGISE_BITFIELD_CLASS_BIT(NotInf);
    STRINGISE_BITFIELD_CLASS_BIT(NSZ);
    STRINGISE_BITFIELD_CLASS_BIT(AllowRecip);
    STRINGISE_BITFIELD_CLASS_BIT(Fast);
  }
  END_BITFIELD_STRINGISE();
}

template <>
rdcstr DoStringise(const rdcspv::SelectionControl &el)
{
  BEGIN_BITFIELD_STRINGISE(rdcspv::SelectionControl);
  {
    STRINGISE_BITFIELD_CLASS_VALUE(None);

    STRINGISE_BITFIELD_CLASS_BIT(Flatten);
    STRINGISE_BITFIELD_CLASS_BIT(DontFlatten);
  }
  END_BITFIELD_STRINGISE();
}

template <>
rdcstr DoStringise(const rdcspv::LoopControl &el)
{
  BEGIN_BITFIELD_STRINGISE(rdcspv::LoopControl);
  {
    STRINGISE_BITFIELD_CLASS_VALUE(None);

    STRINGISE_BITFIELD_CLASS_BIT(Unroll);
    STRINGISE_BITFIELD_CLASS_BIT(DontUnroll);
    STRINGISE_BITFIELD_CLASS_BIT(DependencyInfinite);
    STRINGISE_BITFIELD_CLASS_BIT(DependencyLength);
    STRINGISE_BITFIELD_CLASS_BIT(MinIterations);
    STRINGISE_BITFIELD_CLASS_BIT(MaxIterations);
    STRINGISE_BITFIELD_CLASS_BIT(IterationMultiple);
    STRINGISE_BITFIELD_CLASS_BIT(PeelCount);
    STRINGISE_BITFIELD_CLASS_BIT(PartialCount);
    STRINGISE_BITFIELD_CLASS_BIT(InitiationIntervalINTEL);
    STRINGISE_BITFIELD_CLASS_BIT(MaxConcurrencyINTEL);
    STRINGISE_BITFIELD_CLASS_BIT(DependencyArrayINTEL);
    STRINGISE_BITFIELD_CLASS_BIT(PipelineEnableINTEL);
    STRINGISE_BITFIELD_CLASS_BIT(LoopCoalesceINTEL);
    STRINGISE_BITFIELD_CLASS_BIT(MaxInterleavingINTEL);
    STRINGISE_BITFIELD_CLASS_BIT(SpeculatedIterationsINTEL);
  }
  END_BITFIELD_STRINGISE();
}

template <>
rdcstr DoStringise(const rdcspv::FunctionControl &el)
{
  BEGIN_BITFIELD_STRINGISE(rdcspv::FunctionControl);
  {
    STRINGISE_BITFIELD_CLASS_VALUE(None);

    STRINGISE_BITFIELD_CLASS_BIT(Inline);
    STRINGISE_BITFIELD_CLASS_BIT(DontInline);
    STRINGISE_BITFIELD_CLASS_BIT(Pure);
    STRINGISE_BITFIELD_CLASS_BIT(Const);
  }
  END_BITFIELD_STRINGISE();
}

template <>
rdcstr DoStringise(const rdcspv::MemorySemantics &el)
{
  BEGIN_BITFIELD_STRINGISE(rdcspv::MemorySemantics);
  {
    STRINGISE_BITFIELD_CLASS_BIT(Relaxed);
    STRINGISE_BITFIELD_CLASS_BIT(Acquire);
    STRINGISE_BITFIELD_CLASS_BIT(Release);
    STRINGISE_BITFIELD_CLASS_BIT(AcquireRelease);
    STRINGISE_BITFIELD_CLASS_BIT(SequentiallyConsistent);
    STRINGISE_BITFIELD_CLASS_BIT(UniformMemory);
    STRINGISE_BITFIELD_CLASS_BIT(SubgroupMemory);
    STRINGISE_BITFIELD_CLASS_BIT(WorkgroupMemory);
    STRINGISE_BITFIELD_CLASS_BIT(CrossWorkgroupMemory);
    STRINGISE_BITFIELD_CLASS_BIT(AtomicCounterMemory);
    STRINGISE_BITFIELD_CLASS_BIT(ImageMemory);
    STRINGISE_BITFIELD_CLASS_BIT(OutputMemory);
    STRINGISE_BITFIELD_CLASS_BIT(MakeAvailable);
    STRINGISE_BITFIELD_CLASS_BIT(MakeVisible);
    STRINGISE_BITFIELD_CLASS_BIT(Volatile);
  }
  END_BITFIELD_STRINGISE();
}

template <>
rdcstr DoStringise(const rdcspv::MemoryAccess &el)
{
  BEGIN_BITFIELD_STRINGISE(rdcspv::MemoryAccess);
  {
    STRINGISE_BITFIELD_CLASS_VALUE(None);

    STRINGISE_BITFIELD_CLASS_BIT(Volatile);
    STRINGISE_BITFIELD_CLASS_BIT(Aligned);
    STRINGISE_BITFIELD_CLASS_BIT(Nontemporal);
    STRINGISE_BITFIELD_CLASS_BIT(MakePointerAvailable);
    STRINGISE_BITFIELD_CLASS_BIT(MakePointerVisible);
    STRINGISE_BITFIELD_CLASS_BIT(NonPrivatePointer);
  }
  END_BITFIELD_STRINGISE();
}

template <>
rdcstr DoStringise(const rdcspv::KernelProfilingInfo &el)
{
  BEGIN_BITFIELD_STRINGISE(rdcspv::KernelProfilingInfo);
  {
    STRINGISE_BITFIELD_CLASS_VALUE(None);

    STRINGISE_BITFIELD_CLASS_BIT(CmdExecTime);
  }
  END_BITFIELD_STRINGISE();
}

template <>
rdcstr DoStringise(const rdcspv::RayFlags &el)
{
  BEGIN_BITFIELD_STRINGISE(rdcspv::RayFlags);
  {
    STRINGISE_BITFIELD_CLASS_BIT(NoneKHR);
    STRINGISE_BITFIELD_CLASS_BIT(OpaqueKHR);
    STRINGISE_BITFIELD_CLASS_BIT(NoOpaqueKHR);
    STRINGISE_BITFIELD_CLASS_BIT(TerminateOnFirstHitKHR);
    STRINGISE_BITFIELD_CLASS_BIT(SkipClosestHitShaderKHR);
    STRINGISE_BITFIELD_CLASS_BIT(CullBackFacingTrianglesKHR);
    STRINGISE_BITFIELD_CLASS_BIT(CullFrontFacingTrianglesKHR);
    STRINGISE_BITFIELD_CLASS_BIT(CullOpaqueKHR);
    STRINGISE_BITFIELD_CLASS_BIT(CullNoOpaqueKHR);
    STRINGISE_BITFIELD_CLASS_BIT(SkipTrianglesKHR);
    STRINGISE_BITFIELD_CLASS_BIT(SkipAABBsKHR);
  }
  END_BITFIELD_STRINGISE();
}

template <>
rdcstr DoStringise(const rdcspv::FragmentShadingRate &el)
{
  BEGIN_BITFIELD_STRINGISE(rdcspv::FragmentShadingRate);
  {
    STRINGISE_BITFIELD_CLASS_BIT(Vertical2Pixels);
    STRINGISE_BITFIELD_CLASS_BIT(Vertical4Pixels);
    STRINGISE_BITFIELD_CLASS_BIT(Horizontal2Pixels);
    STRINGISE_BITFIELD_CLASS_BIT(Horizontal4Pixels);
  }
  END_BITFIELD_STRINGISE();
}

template <>
rdcstr DoStringise(const rdcspv::SourceLanguage &el)
{
  BEGIN_ENUM_STRINGISE(rdcspv::SourceLanguage);
  {
    STRINGISE_ENUM_CLASS(Unknown);
    STRINGISE_ENUM_CLASS(ESSL);
    STRINGISE_ENUM_CLASS(GLSL);
    STRINGISE_ENUM_CLASS(OpenCL_C);
    STRINGISE_ENUM_CLASS(OpenCL_CPP);
    STRINGISE_ENUM_CLASS(HLSL);
  }
  END_ENUM_STRINGISE();
}

template <>
rdcstr DoStringise(const rdcspv::ExecutionModel &el)
{
  BEGIN_ENUM_STRINGISE(rdcspv::ExecutionModel);
  {
    STRINGISE_ENUM_CLASS(Vertex);
    STRINGISE_ENUM_CLASS(TessellationControl);
    STRINGISE_ENUM_CLASS(TessellationEvaluation);
    STRINGISE_ENUM_CLASS(Geometry);
    STRINGISE_ENUM_CLASS(Fragment);
    STRINGISE_ENUM_CLASS(GLCompute);
    STRINGISE_ENUM_CLASS(Kernel);
    STRINGISE_ENUM_CLASS(TaskNV);
    STRINGISE_ENUM_CLASS(MeshNV);
    STRINGISE_ENUM_CLASS(RayGenerationNV);
    STRINGISE_ENUM_CLASS(IntersectionNV);
    STRINGISE_ENUM_CLASS(AnyHitNV);
    STRINGISE_ENUM_CLASS(ClosestHitNV);
    STRINGISE_ENUM_CLASS(MissNV);
    STRINGISE_ENUM_CLASS(CallableNV);
  }
  END_ENUM_STRINGISE();
}

template <>
rdcstr DoStringise(const rdcspv::AddressingModel &el)
{
  BEGIN_ENUM_STRINGISE(rdcspv::AddressingModel);
  {
    STRINGISE_ENUM_CLASS(Logical);
    STRINGISE_ENUM_CLASS(Physical32);
    STRINGISE_ENUM_CLASS(Physical64);
    STRINGISE_ENUM_CLASS(PhysicalStorageBuffer64);
  }
  END_ENUM_STRINGISE();
}

template <>
rdcstr DoStringise(const rdcspv::MemoryModel &el)
{
  BEGIN_ENUM_STRINGISE(rdcspv::MemoryModel);
  {
    STRINGISE_ENUM_CLASS(Simple);
    STRINGISE_ENUM_CLASS(GLSL450);
    STRINGISE_ENUM_CLASS(OpenCL);
    STRINGISE_ENUM_CLASS(Vulkan);
  }
  END_ENUM_STRINGISE();
}

template <>
rdcstr DoStringise(const rdcspv::ExecutionMode &el)
{
  BEGIN_ENUM_STRINGISE(rdcspv::ExecutionMode);
  {
    STRINGISE_ENUM_CLASS(Invocations);
    STRINGISE_ENUM_CLASS(SpacingEqual);
    STRINGISE_ENUM_CLASS(SpacingFractionalEven);
    STRINGISE_ENUM_CLASS(SpacingFractionalOdd);
    STRINGISE_ENUM_CLASS(VertexOrderCw);
    STRINGISE_ENUM_CLASS(VertexOrderCcw);
    STRINGISE_ENUM_CLASS(PixelCenterInteger);
    STRINGISE_ENUM_CLASS(OriginUpperLeft);
    STRINGISE_ENUM_CLASS(OriginLowerLeft);
    STRINGISE_ENUM_CLASS(EarlyFragmentTests);
    STRINGISE_ENUM_CLASS(PointMode);
    STRINGISE_ENUM_CLASS(Xfb);
    STRINGISE_ENUM_CLASS(DepthReplacing);
    STRINGISE_ENUM_CLASS(DepthGreater);
    STRINGISE_ENUM_CLASS(DepthLess);
    STRINGISE_ENUM_CLASS(DepthUnchanged);
    STRINGISE_ENUM_CLASS(LocalSize);
    STRINGISE_ENUM_CLASS(LocalSizeHint);
    STRINGISE_ENUM_CLASS(InputPoints);
    STRINGISE_ENUM_CLASS(InputLines);
    STRINGISE_ENUM_CLASS(InputLinesAdjacency);
    STRINGISE_ENUM_CLASS(Triangles);
    STRINGISE_ENUM_CLASS(InputTrianglesAdjacency);
    STRINGISE_ENUM_CLASS(Quads);
    STRINGISE_ENUM_CLASS(Isolines);
    STRINGISE_ENUM_CLASS(OutputVertices);
    STRINGISE_ENUM_CLASS(OutputPoints);
    STRINGISE_ENUM_CLASS(OutputLineStrip);
    STRINGISE_ENUM_CLASS(OutputTriangleStrip);
    STRINGISE_ENUM_CLASS(VecTypeHint);
    STRINGISE_ENUM_CLASS(ContractionOff);
    STRINGISE_ENUM_CLASS(Initializer);
    STRINGISE_ENUM_CLASS(Finalizer);
    STRINGISE_ENUM_CLASS(SubgroupSize);
    STRINGISE_ENUM_CLASS(SubgroupsPerWorkgroup);
    STRINGISE_ENUM_CLASS(SubgroupsPerWorkgroupId);
    STRINGISE_ENUM_CLASS(LocalSizeId);
    STRINGISE_ENUM_CLASS(LocalSizeHintId);
    STRINGISE_ENUM_CLASS(PostDepthCoverage);
    STRINGISE_ENUM_CLASS(DenormPreserve);
    STRINGISE_ENUM_CLASS(DenormFlushToZero);
    STRINGISE_ENUM_CLASS(SignedZeroInfNanPreserve);
    STRINGISE_ENUM_CLASS(RoundingModeRTE);
    STRINGISE_ENUM_CLASS(RoundingModeRTZ);
    STRINGISE_ENUM_CLASS(StencilRefReplacingEXT);
    STRINGISE_ENUM_CLASS(OutputLinesNV);
    STRINGISE_ENUM_CLASS(OutputPrimitivesNV);
    STRINGISE_ENUM_CLASS(DerivativeGroupQuadsNV);
    STRINGISE_ENUM_CLASS(DerivativeGroupLinearNV);
    STRINGISE_ENUM_CLASS(OutputTrianglesNV);
    STRINGISE_ENUM_CLASS(PixelInterlockOrderedEXT);
    STRINGISE_ENUM_CLASS(PixelInterlockUnorderedEXT);
    STRINGISE_ENUM_CLASS(SampleInterlockOrderedEXT);
    STRINGISE_ENUM_CLASS(SampleInterlockUnorderedEXT);
    STRINGISE_ENUM_CLASS(ShadingRateInterlockOrderedEXT);
    STRINGISE_ENUM_CLASS(ShadingRateInterlockUnorderedEXT);
    STRINGISE_ENUM_CLASS(MaxWorkgroupSizeINTEL);
    STRINGISE_ENUM_CLASS(MaxWorkDimINTEL);
    STRINGISE_ENUM_CLASS(NoGlobalOffsetINTEL);
    STRINGISE_ENUM_CLASS(NumSIMDWorkitemsINTEL);
  }
  END_ENUM_STRINGISE();
}

template <>
rdcstr DoStringise(const rdcspv::StorageClass &el)
{
  BEGIN_ENUM_STRINGISE(rdcspv::StorageClass);
  {
    STRINGISE_ENUM_CLASS(UniformConstant);
    STRINGISE_ENUM_CLASS(Input);
    STRINGISE_ENUM_CLASS(Uniform);
    STRINGISE_ENUM_CLASS(Output);
    STRINGISE_ENUM_CLASS(Workgroup);
    STRINGISE_ENUM_CLASS(CrossWorkgroup);
    STRINGISE_ENUM_CLASS(Private);
    STRINGISE_ENUM_CLASS(Function);
    STRINGISE_ENUM_CLASS(Generic);
    STRINGISE_ENUM_CLASS(PushConstant);
    STRINGISE_ENUM_CLASS(AtomicCounter);
    STRINGISE_ENUM_CLASS(Image);
    STRINGISE_ENUM_CLASS(StorageBuffer);
    STRINGISE_ENUM_CLASS(CallableDataNV);
    STRINGISE_ENUM_CLASS(IncomingCallableDataNV);
    STRINGISE_ENUM_CLASS(RayPayloadNV);
    STRINGISE_ENUM_CLASS(HitAttributeNV);
    STRINGISE_ENUM_CLASS(IncomingRayPayloadNV);
    STRINGISE_ENUM_CLASS(ShaderRecordBufferNV);
    STRINGISE_ENUM_CLASS(PhysicalStorageBuffer);
    STRINGISE_ENUM_CLASS(CodeSectionINTEL);
  }
  END_ENUM_STRINGISE();
}

template <>
rdcstr DoStringise(const rdcspv::Dim &el)
{
  BEGIN_ENUM_STRINGISE(rdcspv::Dim);
  {
    STRINGISE_ENUM_CLASS_NAMED(_1D, "1D");
    STRINGISE_ENUM_CLASS_NAMED(_2D, "2D");
    STRINGISE_ENUM_CLASS_NAMED(_3D, "3D");
    STRINGISE_ENUM_CLASS(Cube);
    STRINGISE_ENUM_CLASS(Rect);
    STRINGISE_ENUM_CLASS(Buffer);
    STRINGISE_ENUM_CLASS(SubpassData);
  }
  END_ENUM_STRINGISE();
}

template <>
rdcstr DoStringise(const rdcspv::SamplerAddressingMode &el)
{
  BEGIN_ENUM_STRINGISE(rdcspv::SamplerAddressingMode);
  {
    STRINGISE_ENUM_CLASS(None);
    STRINGISE_ENUM_CLASS(ClampToEdge);
    STRINGISE_ENUM_CLASS(Clamp);
    STRINGISE_ENUM_CLASS(Repeat);
    STRINGISE_ENUM_CLASS(RepeatMirrored);
  }
  END_ENUM_STRINGISE();
}

template <>
rdcstr DoStringise(const rdcspv::SamplerFilterMode &el)
{
  BEGIN_ENUM_STRINGISE(rdcspv::SamplerFilterMode);
  {
    STRINGISE_ENUM_CLASS(Nearest);
    STRINGISE_ENUM_CLASS(Linear);
  }
  END_ENUM_STRINGISE();
}

template <>
rdcstr DoStringise(const rdcspv::ImageFormat &el)
{
  BEGIN_ENUM_STRINGISE(rdcspv::ImageFormat);
  {
    STRINGISE_ENUM_CLASS(Unknown);
    STRINGISE_ENUM_CLASS(Rgba32f);
    STRINGISE_ENUM_CLASS(Rgba16f);
    STRINGISE_ENUM_CLASS(R32f);
    STRINGISE_ENUM_CLASS(Rgba8);
    STRINGISE_ENUM_CLASS(Rgba8Snorm);
    STRINGISE_ENUM_CLASS(Rg32f);
    STRINGISE_ENUM_CLASS(Rg16f);
    STRINGISE_ENUM_CLASS(R11fG11fB10f);
    STRINGISE_ENUM_CLASS(R16f);
    STRINGISE_ENUM_CLASS(Rgba16);
    STRINGISE_ENUM_CLASS(Rgb10A2);
    STRINGISE_ENUM_CLASS(Rg16);
    STRINGISE_ENUM_CLASS(Rg8);
    STRINGISE_ENUM_CLASS(R16);
    STRINGISE_ENUM_CLASS(R8);
    STRINGISE_ENUM_CLASS(Rgba16Snorm);
    STRINGISE_ENUM_CLASS(Rg16Snorm);
    STRINGISE_ENUM_CLASS(Rg8Snorm);
    STRINGISE_ENUM_CLASS(R16Snorm);
    STRINGISE_ENUM_CLASS(R8Snorm);
    STRINGISE_ENUM_CLASS(Rgba32i);
    STRINGISE_ENUM_CLASS(Rgba16i);
    STRINGISE_ENUM_CLASS(Rgba8i);
    STRINGISE_ENUM_CLASS(R32i);
    STRINGISE_ENUM_CLASS(Rg32i);
    STRINGISE_ENUM_CLASS(Rg16i);
    STRINGISE_ENUM_CLASS(Rg8i);
    STRINGISE_ENUM_CLASS(R16i);
    STRINGISE_ENUM_CLASS(R8i);
    STRINGISE_ENUM_CLASS(Rgba32ui);
    STRINGISE_ENUM_CLASS(Rgba16ui);
    STRINGISE_ENUM_CLASS(Rgba8ui);
    STRINGISE_ENUM_CLASS(R32ui);
    STRINGISE_ENUM_CLASS(Rgb10a2ui);
    STRINGISE_ENUM_CLASS(Rg32ui);
    STRINGISE_ENUM_CLASS(Rg16ui);
    STRINGISE_ENUM_CLASS(Rg8ui);
    STRINGISE_ENUM_CLASS(R16ui);
    STRINGISE_ENUM_CLASS(R8ui);
    STRINGISE_ENUM_CLASS(R64ui);
    STRINGISE_ENUM_CLASS(R64i);
  }
  END_ENUM_STRINGISE();
}

template <>
rdcstr DoStringise(const rdcspv::ImageChannelOrder &el)
{
  BEGIN_ENUM_STRINGISE(rdcspv::ImageChannelOrder);
  {
    STRINGISE_ENUM_CLASS(R);
    STRINGISE_ENUM_CLASS(A);
    STRINGISE_ENUM_CLASS(RG);
    STRINGISE_ENUM_CLASS(RA);
    STRINGISE_ENUM_CLASS(RGB);
    STRINGISE_ENUM_CLASS(RGBA);
    STRINGISE_ENUM_CLASS(BGRA);
    STRINGISE_ENUM_CLASS(ARGB);
    STRINGISE_ENUM_CLASS(Intensity);
    STRINGISE_ENUM_CLASS(Luminance);
    STRINGISE_ENUM_CLASS(Rx);
    STRINGISE_ENUM_CLASS(RGx);
    STRINGISE_ENUM_CLASS(RGBx);
    STRINGISE_ENUM_CLASS(Depth);
    STRINGISE_ENUM_CLASS(DepthStencil);
    STRINGISE_ENUM_CLASS(sRGB);
    STRINGISE_ENUM_CLASS(sRGBx);
    STRINGISE_ENUM_CLASS(sRGBA);
    STRINGISE_ENUM_CLASS(sBGRA);
    STRINGISE_ENUM_CLASS(ABGR);
  }
  END_ENUM_STRINGISE();
}

template <>
rdcstr DoStringise(const rdcspv::ImageChannelDataType &el)
{
  BEGIN_ENUM_STRINGISE(rdcspv::ImageChannelDataType);
  {
    STRINGISE_ENUM_CLASS(SnormInt8);
    STRINGISE_ENUM_CLASS(SnormInt16);
    STRINGISE_ENUM_CLASS(UnormInt8);
    STRINGISE_ENUM_CLASS(UnormInt16);
    STRINGISE_ENUM_CLASS(UnormShort565);
    STRINGISE_ENUM_CLASS(UnormShort555);
    STRINGISE_ENUM_CLASS(UnormInt101010);
    STRINGISE_ENUM_CLASS(SignedInt8);
    STRINGISE_ENUM_CLASS(SignedInt16);
    STRINGISE_ENUM_CLASS(SignedInt32);
    STRINGISE_ENUM_CLASS(UnsignedInt8);
    STRINGISE_ENUM_CLASS(UnsignedInt16);
    STRINGISE_ENUM_CLASS(UnsignedInt32);
    STRINGISE_ENUM_CLASS(HalfFloat);
    STRINGISE_ENUM_CLASS(Float);
    STRINGISE_ENUM_CLASS(UnormInt24);
    STRINGISE_ENUM_CLASS(UnormInt101010_2);
  }
  END_ENUM_STRINGISE();
}

template <>
rdcstr DoStringise(const rdcspv::FPRoundingMode &el)
{
  BEGIN_ENUM_STRINGISE(rdcspv::FPRoundingMode);
  {
    STRINGISE_ENUM_CLASS(RTE);
    STRINGISE_ENUM_CLASS(RTZ);
    STRINGISE_ENUM_CLASS(RTP);
    STRINGISE_ENUM_CLASS(RTN);
  }
  END_ENUM_STRINGISE();
}

template <>
rdcstr DoStringise(const rdcspv::LinkageType &el)
{
  BEGIN_ENUM_STRINGISE(rdcspv::LinkageType);
  {
    STRINGISE_ENUM_CLASS(Export);
    STRINGISE_ENUM_CLASS(Import);
  }
  END_ENUM_STRINGISE();
}

template <>
rdcstr DoStringise(const rdcspv::AccessQualifier &el)
{
  BEGIN_ENUM_STRINGISE(rdcspv::AccessQualifier);
  {
    STRINGISE_ENUM_CLASS(ReadOnly);
    STRINGISE_ENUM_CLASS(WriteOnly);
    STRINGISE_ENUM_CLASS(ReadWrite);
  }
  END_ENUM_STRINGISE();
}

template <>
rdcstr DoStringise(const rdcspv::FunctionParameterAttribute &el)
{
  BEGIN_ENUM_STRINGISE(rdcspv::FunctionParameterAttribute);
  {
    STRINGISE_ENUM_CLASS(Zext);
    STRINGISE_ENUM_CLASS(Sext);
    STRINGISE_ENUM_CLASS(ByVal);
    STRINGISE_ENUM_CLASS(Sret);
    STRINGISE_ENUM_CLASS(NoAlias);
    STRINGISE_ENUM_CLASS(NoCapture);
    STRINGISE_ENUM_CLASS(NoWrite);
    STRINGISE_ENUM_CLASS(NoReadWrite);
  }
  END_ENUM_STRINGISE();
}

template <>
rdcstr DoStringise(const rdcspv::Decoration &el)
{
  BEGIN_ENUM_STRINGISE(rdcspv::Decoration);
  {
    STRINGISE_ENUM_CLASS(RelaxedPrecision);
    STRINGISE_ENUM_CLASS(SpecId);
    STRINGISE_ENUM_CLASS(Block);
    STRINGISE_ENUM_CLASS(BufferBlock);
    STRINGISE_ENUM_CLASS(RowMajor);
    STRINGISE_ENUM_CLASS(ColMajor);
    STRINGISE_ENUM_CLASS(ArrayStride);
    STRINGISE_ENUM_CLASS(MatrixStride);
    STRINGISE_ENUM_CLASS(GLSLShared);
    STRINGISE_ENUM_CLASS(GLSLPacked);
    STRINGISE_ENUM_CLASS(CPacked);
    STRINGISE_ENUM_CLASS(BuiltIn);
    STRINGISE_ENUM_CLASS(NoPerspective);
    STRINGISE_ENUM_CLASS(Flat);
    STRINGISE_ENUM_CLASS(Patch);
    STRINGISE_ENUM_CLASS(Centroid);
    STRINGISE_ENUM_CLASS(Sample);
    STRINGISE_ENUM_CLASS(Invariant);
    STRINGISE_ENUM_CLASS(Restrict);
    STRINGISE_ENUM_CLASS(Aliased);
    STRINGISE_ENUM_CLASS(Volatile);
    STRINGISE_ENUM_CLASS(Constant);
    STRINGISE_ENUM_CLASS(Coherent);
    STRINGISE_ENUM_CLASS(NonWritable);
    STRINGISE_ENUM_CLASS(NonReadable);
    STRINGISE_ENUM_CLASS(Uniform);
    STRINGISE_ENUM_CLASS(UniformId);
    STRINGISE_ENUM_CLASS(SaturatedConversion);
    STRINGISE_ENUM_CLASS(Stream);
    STRINGISE_ENUM_CLASS(Location);
    STRINGISE_ENUM_CLASS(Component);
    STRINGISE_ENUM_CLASS(Index);
    STRINGISE_ENUM_CLASS(Binding);
    STRINGISE_ENUM_CLASS(DescriptorSet);
    STRINGISE_ENUM_CLASS(Offset);
    STRINGISE_ENUM_CLASS(XfbBuffer);
    STRINGISE_ENUM_CLASS(XfbStride);
    STRINGISE_ENUM_CLASS(FuncParamAttr);
    STRINGISE_ENUM_CLASS(FPRoundingMode);
    STRINGISE_ENUM_CLASS(FPFastMathMode);
    STRINGISE_ENUM_CLASS(LinkageAttributes);
    STRINGISE_ENUM_CLASS(NoContraction);
    STRINGISE_ENUM_CLASS(InputAttachmentIndex);
    STRINGISE_ENUM_CLASS(Alignment);
    STRINGISE_ENUM_CLASS(MaxByteOffset);
    STRINGISE_ENUM_CLASS(AlignmentId);
    STRINGISE_ENUM_CLASS(MaxByteOffsetId);
    STRINGISE_ENUM_CLASS(NoSignedWrap);
    STRINGISE_ENUM_CLASS(NoUnsignedWrap);
    STRINGISE_ENUM_CLASS(ExplicitInterpAMD);
    STRINGISE_ENUM_CLASS(OverrideCoverageNV);
    STRINGISE_ENUM_CLASS(PassthroughNV);
    STRINGISE_ENUM_CLASS(ViewportRelativeNV);
    STRINGISE_ENUM_CLASS(SecondaryViewportRelativeNV);
    STRINGISE_ENUM_CLASS(PerPrimitiveNV);
    STRINGISE_ENUM_CLASS(PerViewNV);
    STRINGISE_ENUM_CLASS(PerTaskNV);
    STRINGISE_ENUM_CLASS(PerVertexNV);
    STRINGISE_ENUM_CLASS(NonUniform);
    STRINGISE_ENUM_CLASS(RestrictPointer);
    STRINGISE_ENUM_CLASS(AliasedPointer);
    STRINGISE_ENUM_CLASS(ReferencedIndirectlyINTEL);
    STRINGISE_ENUM_CLASS(CounterBuffer);
    STRINGISE_ENUM_CLASS(UserSemantic);
    STRINGISE_ENUM_CLASS(UserTypeGOOGLE);
    STRINGISE_ENUM_CLASS(RegisterINTEL);
    STRINGISE_ENUM_CLASS(MemoryINTEL);
    STRINGISE_ENUM_CLASS(NumbanksINTEL);
    STRINGISE_ENUM_CLASS(BankwidthINTEL);
    STRINGISE_ENUM_CLASS(MaxPrivateCopiesINTEL);
    STRINGISE_ENUM_CLASS(SinglepumpINTEL);
    STRINGISE_ENUM_CLASS(DoublepumpINTEL);
    STRINGISE_ENUM_CLASS(MaxReplicatesINTEL);
    STRINGISE_ENUM_CLASS(SimpleDualPortINTEL);
    STRINGISE_ENUM_CLASS(MergeINTEL);
    STRINGISE_ENUM_CLASS(BankBitsINTEL);
    STRINGISE_ENUM_CLASS(ForcePow2DepthINTEL);
  }
  END_ENUM_STRINGISE();
}

template <>
rdcstr DoStringise(const rdcspv::BuiltIn &el)
{
  BEGIN_ENUM_STRINGISE(rdcspv::BuiltIn);
  {
    STRINGISE_ENUM_CLASS(Position);
    STRINGISE_ENUM_CLASS(PointSize);
    STRINGISE_ENUM_CLASS(ClipDistance);
    STRINGISE_ENUM_CLASS(CullDistance);
    STRINGISE_ENUM_CLASS(VertexId);
    STRINGISE_ENUM_CLASS(InstanceId);
    STRINGISE_ENUM_CLASS(PrimitiveId);
    STRINGISE_ENUM_CLASS(InvocationId);
    STRINGISE_ENUM_CLASS(Layer);
    STRINGISE_ENUM_CLASS(ViewportIndex);
    STRINGISE_ENUM_CLASS(TessLevelOuter);
    STRINGISE_ENUM_CLASS(TessLevelInner);
    STRINGISE_ENUM_CLASS(TessCoord);
    STRINGISE_ENUM_CLASS(PatchVertices);
    STRINGISE_ENUM_CLASS(FragCoord);
    STRINGISE_ENUM_CLASS(PointCoord);
    STRINGISE_ENUM_CLASS(FrontFacing);
    STRINGISE_ENUM_CLASS(SampleId);
    STRINGISE_ENUM_CLASS(SamplePosition);
    STRINGISE_ENUM_CLASS(SampleMask);
    STRINGISE_ENUM_CLASS(FragDepth);
    STRINGISE_ENUM_CLASS(HelperInvocation);
    STRINGISE_ENUM_CLASS(NumWorkgroups);
    STRINGISE_ENUM_CLASS(WorkgroupSize);
    STRINGISE_ENUM_CLASS(WorkgroupId);
    STRINGISE_ENUM_CLASS(LocalInvocationId);
    STRINGISE_ENUM_CLASS(GlobalInvocationId);
    STRINGISE_ENUM_CLASS(LocalInvocationIndex);
    STRINGISE_ENUM_CLASS(WorkDim);
    STRINGISE_ENUM_CLASS(GlobalSize);
    STRINGISE_ENUM_CLASS(EnqueuedWorkgroupSize);
    STRINGISE_ENUM_CLASS(GlobalOffset);
    STRINGISE_ENUM_CLASS(GlobalLinearId);
    STRINGISE_ENUM_CLASS(SubgroupSize);
    STRINGISE_ENUM_CLASS(SubgroupMaxSize);
    STRINGISE_ENUM_CLASS(NumSubgroups);
    STRINGISE_ENUM_CLASS(NumEnqueuedSubgroups);
    STRINGISE_ENUM_CLASS(SubgroupId);
    STRINGISE_ENUM_CLASS(SubgroupLocalInvocationId);
    STRINGISE_ENUM_CLASS(VertexIndex);
    STRINGISE_ENUM_CLASS(InstanceIndex);
    STRINGISE_ENUM_CLASS(SubgroupEqMask);
    STRINGISE_ENUM_CLASS(SubgroupGeMask);
    STRINGISE_ENUM_CLASS(SubgroupGtMask);
    STRINGISE_ENUM_CLASS(SubgroupLeMask);
    STRINGISE_ENUM_CLASS(SubgroupLtMask);
    STRINGISE_ENUM_CLASS(BaseVertex);
    STRINGISE_ENUM_CLASS(BaseInstance);
    STRINGISE_ENUM_CLASS(DrawIndex);
    STRINGISE_ENUM_CLASS(PrimitiveShadingRateKHR);
    STRINGISE_ENUM_CLASS(DeviceIndex);
    STRINGISE_ENUM_CLASS(ViewIndex);
    STRINGISE_ENUM_CLASS(ShadingRateKHR);
    STRINGISE_ENUM_CLASS(BaryCoordNoPerspAMD);
    STRINGISE_ENUM_CLASS(BaryCoordNoPerspCentroidAMD);
    STRINGISE_ENUM_CLASS(BaryCoordNoPerspSampleAMD);
    STRINGISE_ENUM_CLASS(BaryCoordSmoothAMD);
    STRINGISE_ENUM_CLASS(BaryCoordSmoothCentroidAMD);
    STRINGISE_ENUM_CLASS(BaryCoordSmoothSampleAMD);
    STRINGISE_ENUM_CLASS(BaryCoordPullModelAMD);
    STRINGISE_ENUM_CLASS(FragStencilRefEXT);
    STRINGISE_ENUM_CLASS(ViewportMaskNV);
    STRINGISE_ENUM_CLASS(SecondaryPositionNV);
    STRINGISE_ENUM_CLASS(SecondaryViewportMaskNV);
    STRINGISE_ENUM_CLASS(PositionPerViewNV);
    STRINGISE_ENUM_CLASS(ViewportMaskPerViewNV);
    STRINGISE_ENUM_CLASS(FullyCoveredEXT);
    STRINGISE_ENUM_CLASS(TaskCountNV);
    STRINGISE_ENUM_CLASS(PrimitiveCountNV);
    STRINGISE_ENUM_CLASS(PrimitiveIndicesNV);
    STRINGISE_ENUM_CLASS(ClipDistancePerViewNV);
    STRINGISE_ENUM_CLASS(CullDistancePerViewNV);
    STRINGISE_ENUM_CLASS(LayerPerViewNV);
    STRINGISE_ENUM_CLASS(MeshViewCountNV);
    STRINGISE_ENUM_CLASS(MeshViewIndicesNV);
    STRINGISE_ENUM_CLASS(BaryCoordNV);
    STRINGISE_ENUM_CLASS(BaryCoordNoPerspNV);
    STRINGISE_ENUM_CLASS(FragSizeEXT);
    STRINGISE_ENUM_CLASS(FragInvocationCountEXT);
    STRINGISE_ENUM_CLASS(LaunchIdNV);
    STRINGISE_ENUM_CLASS(LaunchSizeNV);
    STRINGISE_ENUM_CLASS(WorldRayOriginNV);
    STRINGISE_ENUM_CLASS(WorldRayDirectionNV);
    STRINGISE_ENUM_CLASS(ObjectRayOriginNV);
    STRINGISE_ENUM_CLASS(ObjectRayDirectionNV);
    STRINGISE_ENUM_CLASS(RayTminNV);
    STRINGISE_ENUM_CLASS(RayTmaxNV);
    STRINGISE_ENUM_CLASS(InstanceCustomIndexNV);
    STRINGISE_ENUM_CLASS(ObjectToWorldNV);
    STRINGISE_ENUM_CLASS(WorldToObjectNV);
    STRINGISE_ENUM_CLASS(HitTNV);
    STRINGISE_ENUM_CLASS(HitKindNV);
    STRINGISE_ENUM_CLASS(IncomingRayFlagsNV);
    STRINGISE_ENUM_CLASS(RayGeometryIndexKHR);
    STRINGISE_ENUM_CLASS(WarpsPerSMNV);
    STRINGISE_ENUM_CLASS(SMCountNV);
    STRINGISE_ENUM_CLASS(WarpIDNV);
    STRINGISE_ENUM_CLASS(SMIDNV);
  }
  END_ENUM_STRINGISE();
}

template <>
rdcstr DoStringise(const rdcspv::Scope &el)
{
  BEGIN_ENUM_STRINGISE(rdcspv::Scope);
  {
    STRINGISE_ENUM_CLASS(CrossDevice);
    STRINGISE_ENUM_CLASS(Device);
    STRINGISE_ENUM_CLASS(Workgroup);
    STRINGISE_ENUM_CLASS(Subgroup);
    STRINGISE_ENUM_CLASS(Invocation);
    STRINGISE_ENUM_CLASS(QueueFamily);
    STRINGISE_ENUM_CLASS(ShaderCallKHR);
  }
  END_ENUM_STRINGISE();
}

template <>
rdcstr DoStringise(const rdcspv::GroupOperation &el)
{
  BEGIN_ENUM_STRINGISE(rdcspv::GroupOperation);
  {
    STRINGISE_ENUM_CLASS(Reduce);
    STRINGISE_ENUM_CLASS(InclusiveScan);
    STRINGISE_ENUM_CLASS(ExclusiveScan);
    STRINGISE_ENUM_CLASS(ClusteredReduce);
    STRINGISE_ENUM_CLASS(PartitionedReduceNV);
    STRINGISE_ENUM_CLASS(PartitionedInclusiveScanNV);
    STRINGISE_ENUM_CLASS(PartitionedExclusiveScanNV);
  }
  END_ENUM_STRINGISE();
}

template <>
rdcstr DoStringise(const rdcspv::KernelEnqueueFlags &el)
{
  BEGIN_ENUM_STRINGISE(rdcspv::KernelEnqueueFlags);
  {
    STRINGISE_ENUM_CLASS(NoWait);
    STRINGISE_ENUM_CLASS(WaitKernel);
    STRINGISE_ENUM_CLASS(WaitWorkGroup);
  }
  END_ENUM_STRINGISE();
}

template <>
rdcstr DoStringise(const rdcspv::Capability &el)
{
  BEGIN_ENUM_STRINGISE(rdcspv::Capability);
  {
    STRINGISE_ENUM_CLASS(Matrix);
    STRINGISE_ENUM_CLASS(Shader);
    STRINGISE_ENUM_CLASS(Geometry);
    STRINGISE_ENUM_CLASS(Tessellation);
    STRINGISE_ENUM_CLASS(Addresses);
    STRINGISE_ENUM_CLASS(Linkage);
    STRINGISE_ENUM_CLASS(Kernel);
    STRINGISE_ENUM_CLASS(Vector16);
    STRINGISE_ENUM_CLASS(Float16Buffer);
    STRINGISE_ENUM_CLASS(Float16);
    STRINGISE_ENUM_CLASS(Float64);
    STRINGISE_ENUM_CLASS(Int64);
    STRINGISE_ENUM_CLASS(Int64Atomics);
    STRINGISE_ENUM_CLASS(ImageBasic);
    STRINGISE_ENUM_CLASS(ImageReadWrite);
    STRINGISE_ENUM_CLASS(ImageMipmap);
    STRINGISE_ENUM_CLASS(Pipes);
    STRINGISE_ENUM_CLASS(Groups);
    STRINGISE_ENUM_CLASS(DeviceEnqueue);
    STRINGISE_ENUM_CLASS(LiteralSampler);
    STRINGISE_ENUM_CLASS(AtomicStorage);
    STRINGISE_ENUM_CLASS(Int16);
    STRINGISE_ENUM_CLASS(TessellationPointSize);
    STRINGISE_ENUM_CLASS(GeometryPointSize);
    STRINGISE_ENUM_CLASS(ImageGatherExtended);
    STRINGISE_ENUM_CLASS(StorageImageMultisample);
    STRINGISE_ENUM_CLASS(UniformBufferArrayDynamicIndexing);
    STRINGISE_ENUM_CLASS(SampledImageArrayDynamicIndexing);
    STRINGISE_ENUM_CLASS(StorageBufferArrayDynamicIndexing);
    STRINGISE_ENUM_CLASS(StorageImageArrayDynamicIndexing);
    STRINGISE_ENUM_CLASS(ClipDistance);
    STRINGISE_ENUM_CLASS(CullDistance);
    STRINGISE_ENUM_CLASS(ImageCubeArray);
    STRINGISE_ENUM_CLASS(SampleRateShading);
    STRINGISE_ENUM_CLASS(ImageRect);
    STRINGISE_ENUM_CLASS(SampledRect);
    STRINGISE_ENUM_CLASS(GenericPointer);
    STRINGISE_ENUM_CLASS(Int8);
    STRINGISE_ENUM_CLASS(InputAttachment);
    STRINGISE_ENUM_CLASS(SparseResidency);
    STRINGISE_ENUM_CLASS(MinLod);
    STRINGISE_ENUM_CLASS(Sampled1D);
    STRINGISE_ENUM_CLASS(Image1D);
    STRINGISE_ENUM_CLASS(SampledCubeArray);
    STRINGISE_ENUM_CLASS(SampledBuffer);
    STRINGISE_ENUM_CLASS(ImageBuffer);
    STRINGISE_ENUM_CLASS(ImageMSArray);
    STRINGISE_ENUM_CLASS(StorageImageExtendedFormats);
    STRINGISE_ENUM_CLASS(ImageQuery);
    STRINGISE_ENUM_CLASS(DerivativeControl);
    STRINGISE_ENUM_CLASS(InterpolationFunction);
    STRINGISE_ENUM_CLASS(TransformFeedback);
    STRINGISE_ENUM_CLASS(GeometryStreams);
    STRINGISE_ENUM_CLASS(StorageImageReadWithoutFormat);
    STRINGISE_ENUM_CLASS(StorageImageWriteWithoutFormat);
    STRINGISE_ENUM_CLASS(MultiViewport);
    STRINGISE_ENUM_CLASS(SubgroupDispatch);
    STRINGISE_ENUM_CLASS(NamedBarrier);
    STRINGISE_ENUM_CLASS(PipeStorage);
    STRINGISE_ENUM_CLASS(GroupNonUniform);
    STRINGISE_ENUM_CLASS(GroupNonUniformVote);
    STRINGISE_ENUM_CLASS(GroupNonUniformArithmetic);
    STRINGISE_ENUM_CLASS(GroupNonUniformBallot);
    STRINGISE_ENUM_CLASS(GroupNonUniformShuffle);
    STRINGISE_ENUM_CLASS(GroupNonUniformShuffleRelative);
    STRINGISE_ENUM_CLASS(GroupNonUniformClustered);
    STRINGISE_ENUM_CLASS(GroupNonUniformQuad);
    STRINGISE_ENUM_CLASS(ShaderLayer);
    STRINGISE_ENUM_CLASS(ShaderViewportIndex);
    STRINGISE_ENUM_CLASS(FragmentShadingRateKHR);
    STRINGISE_ENUM_CLASS(SubgroupBallotKHR);
    STRINGISE_ENUM_CLASS(DrawParameters);
    STRINGISE_ENUM_CLASS(SubgroupVoteKHR);
    STRINGISE_ENUM_CLASS(StorageBuffer16BitAccess);
    STRINGISE_ENUM_CLASS(UniformAndStorageBuffer16BitAccess);
    STRINGISE_ENUM_CLASS(StoragePushConstant16);
    STRINGISE_ENUM_CLASS(StorageInputOutput16);
    STRINGISE_ENUM_CLASS(DeviceGroup);
    STRINGISE_ENUM_CLASS(MultiView);
    STRINGISE_ENUM_CLASS(VariablePointersStorageBuffer);
    STRINGISE_ENUM_CLASS(VariablePointers);
    STRINGISE_ENUM_CLASS(AtomicStorageOps);
    STRINGISE_ENUM_CLASS(SampleMaskPostDepthCoverage);
    STRINGISE_ENUM_CLASS(StorageBuffer8BitAccess);
    STRINGISE_ENUM_CLASS(UniformAndStorageBuffer8BitAccess);
    STRINGISE_ENUM_CLASS(StoragePushConstant8);
    STRINGISE_ENUM_CLASS(DenormPreserve);
    STRINGISE_ENUM_CLASS(DenormFlushToZero);
    STRINGISE_ENUM_CLASS(SignedZeroInfNanPreserve);
    STRINGISE_ENUM_CLASS(RoundingModeRTE);
    STRINGISE_ENUM_CLASS(RoundingModeRTZ);
    STRINGISE_ENUM_CLASS(RayQueryProvisionalKHR);
    STRINGISE_ENUM_CLASS(RayQueryKHR);
    STRINGISE_ENUM_CLASS(RayTraversalPrimitiveCullingKHR);
    STRINGISE_ENUM_CLASS(RayTracingKHR);
    STRINGISE_ENUM_CLASS(Float16ImageAMD);
    STRINGISE_ENUM_CLASS(ImageGatherBiasLodAMD);
    STRINGISE_ENUM_CLASS(FragmentMaskAMD);
    STRINGISE_ENUM_CLASS(StencilExportEXT);
    STRINGISE_ENUM_CLASS(ImageReadWriteLodAMD);
    STRINGISE_ENUM_CLASS(Int64ImageEXT);
    STRINGISE_ENUM_CLASS(ShaderClockKHR);
    STRINGISE_ENUM_CLASS(SampleMaskOverrideCoverageNV);
    STRINGISE_ENUM_CLASS(GeometryShaderPassthroughNV);
    STRINGISE_ENUM_CLASS(ShaderViewportIndexLayerEXT);
    STRINGISE_ENUM_CLASS(ShaderViewportMaskNV);
    STRINGISE_ENUM_CLASS(ShaderStereoViewNV);
    STRINGISE_ENUM_CLASS(PerViewAttributesNV);
    STRINGISE_ENUM_CLASS(FragmentFullyCoveredEXT);
    STRINGISE_ENUM_CLASS(MeshShadingNV);
    STRINGISE_ENUM_CLASS(ImageFootprintNV);
    STRINGISE_ENUM_CLASS(FragmentBarycentricNV);
    STRINGISE_ENUM_CLASS(ComputeDerivativeGroupQuadsNV);
    STRINGISE_ENUM_CLASS(FragmentDensityEXT);
    STRINGISE_ENUM_CLASS(GroupNonUniformPartitionedNV);
    STRINGISE_ENUM_CLASS(ShaderNonUniform);
    STRINGISE_ENUM_CLASS(RuntimeDescriptorArray);
    STRINGISE_ENUM_CLASS(InputAttachmentArrayDynamicIndexing);
    STRINGISE_ENUM_CLASS(UniformTexelBufferArrayDynamicIndexing);
    STRINGISE_ENUM_CLASS(StorageTexelBufferArrayDynamicIndexing);
    STRINGISE_ENUM_CLASS(UniformBufferArrayNonUniformIndexing);
    STRINGISE_ENUM_CLASS(SampledImageArrayNonUniformIndexing);
    STRINGISE_ENUM_CLASS(StorageBufferArrayNonUniformIndexing);
    STRINGISE_ENUM_CLASS(StorageImageArrayNonUniformIndexing);
    STRINGISE_ENUM_CLASS(InputAttachmentArrayNonUniformIndexing);
    STRINGISE_ENUM_CLASS(UniformTexelBufferArrayNonUniformIndexing);
    STRINGISE_ENUM_CLASS(StorageTexelBufferArrayNonUniformIndexing);
    STRINGISE_ENUM_CLASS(RayTracingNV);
    STRINGISE_ENUM_CLASS(VulkanMemoryModel);
    STRINGISE_ENUM_CLASS(VulkanMemoryModelDeviceScope);
    STRINGISE_ENUM_CLASS(PhysicalStorageBufferAddresses);
    STRINGISE_ENUM_CLASS(ComputeDerivativeGroupLinearNV);
    STRINGISE_ENUM_CLASS(RayTracingProvisionalKHR);
    STRINGISE_ENUM_CLASS(CooperativeMatrixNV);
    STRINGISE_ENUM_CLASS(FragmentShaderSampleInterlockEXT);
    STRINGISE_ENUM_CLASS(FragmentShaderShadingRateInterlockEXT);
    STRINGISE_ENUM_CLASS(ShaderSMBuiltinsNV);
    STRINGISE_ENUM_CLASS(FragmentShaderPixelInterlockEXT);
    STRINGISE_ENUM_CLASS(DemoteToHelperInvocationEXT);
    STRINGISE_ENUM_CLASS(SubgroupShuffleINTEL);
    STRINGISE_ENUM_CLASS(SubgroupBufferBlockIOINTEL);
    STRINGISE_ENUM_CLASS(SubgroupImageBlockIOINTEL);
    STRINGISE_ENUM_CLASS(SubgroupImageMediaBlockIOINTEL);
    STRINGISE_ENUM_CLASS(IntegerFunctions2INTEL);
    STRINGISE_ENUM_CLASS(FunctionPointersINTEL);
    STRINGISE_ENUM_CLASS(IndirectReferencesINTEL);
    STRINGISE_ENUM_CLASS(SubgroupAvcMotionEstimationINTEL);
    STRINGISE_ENUM_CLASS(SubgroupAvcMotionEstimationIntraINTEL);
    STRINGISE_ENUM_CLASS(SubgroupAvcMotionEstimationChromaINTEL);
    STRINGISE_ENUM_CLASS(FPGAMemoryAttributesINTEL);
    STRINGISE_ENUM_CLASS(UnstructuredLoopControlsINTEL);
    STRINGISE_ENUM_CLASS(FPGALoopControlsINTEL);
    STRINGISE_ENUM_CLASS(KernelAttributesINTEL);
    STRINGISE_ENUM_CLASS(FPGAKernelAttributesINTEL);
    STRINGISE_ENUM_CLASS(BlockingPipesINTEL);
    STRINGISE_ENUM_CLASS(FPGARegINTEL);
    STRINGISE_ENUM_CLASS(AtomicFloat32AddEXT);
    STRINGISE_ENUM_CLASS(AtomicFloat64AddEXT);
  }
  END_ENUM_STRINGISE();
}

template <>
rdcstr DoStringise(const rdcspv::RayQueryIntersection &el)
{
  BEGIN_ENUM_STRINGISE(rdcspv::RayQueryIntersection);
  {
    STRINGISE_ENUM_CLASS(RayQueryCandidateIntersectionKHR);
    STRINGISE_ENUM_CLASS(RayQueryCommittedIntersectionKHR);
  }
  END_ENUM_STRINGISE();
}

template <>
rdcstr DoStringise(const rdcspv::RayQueryCommittedIntersectionType &el)
{
  BEGIN_ENUM_STRINGISE(rdcspv::RayQueryCommittedIntersectionType);
  {
    STRINGISE_ENUM_CLASS(RayQueryCommittedIntersectionNoneKHR);
    STRINGISE_ENUM_CLASS(RayQueryCommittedIntersectionTriangleKHR);
    STRINGISE_ENUM_CLASS(RayQueryCommittedIntersectionGeneratedKHR);
  }
  END_ENUM_STRINGISE();
}

template <>
rdcstr DoStringise(const rdcspv::RayQueryCandidateIntersectionType &el)
{
  BEGIN_ENUM_STRINGISE(rdcspv::RayQueryCandidateIntersectionType);
  {
    STRINGISE_ENUM_CLASS(RayQueryCandidateIntersectionTriangleKHR);
    STRINGISE_ENUM_CLASS(RayQueryCandidateIntersectionAABBKHR);
  }
  END_ENUM_STRINGISE();
}

template <>
rdcstr DoStringise(const rdcspv::Op &el)
{
  BEGIN_ENUM_STRINGISE(rdcspv::Op);
  {
    STRINGISE_ENUM_CLASS(Nop);
    STRINGISE_ENUM_CLASS(Undef);
    STRINGISE_ENUM_CLASS(SourceContinued);
    STRINGISE_ENUM_CLASS(Source);
    STRINGISE_ENUM_CLASS(SourceExtension);
    STRINGISE_ENUM_CLASS(Name);
    STRINGISE_ENUM_CLASS(MemberName);
    STRINGISE_ENUM_CLASS(String);
    STRINGISE_ENUM_CLASS(Line);
    STRINGISE_ENUM_CLASS(Extension);
    STRINGISE_ENUM_CLASS(ExtInstImport);
    STRINGISE_ENUM_CLASS(ExtInst);
    STRINGISE_ENUM_CLASS(MemoryModel);
    STRINGISE_ENUM_CLASS(EntryPoint);
    STRINGISE_ENUM_CLASS(ExecutionMode);
    STRINGISE_ENUM_CLASS(Capability);
    STRINGISE_ENUM_CLASS(TypeVoid);
    STRINGISE_ENUM_CLASS(TypeBool);
    STRINGISE_ENUM_CLASS(TypeInt);
    STRINGISE_ENUM_CLASS(TypeFloat);
    STRINGISE_ENUM_CLASS(TypeVector);
    STRINGISE_ENUM_CLASS(TypeMatrix);
    STRINGISE_ENUM_CLASS(TypeImage);
    STRINGISE_ENUM_CLASS(TypeSampler);
    STRINGISE_ENUM_CLASS(TypeSampledImage);
    STRINGISE_ENUM_CLASS(TypeArray);
    STRINGISE_ENUM_CLASS(TypeRuntimeArray);
    STRINGISE_ENUM_CLASS(TypeStruct);
    STRINGISE_ENUM_CLASS(TypeOpaque);
    STRINGISE_ENUM_CLASS(TypePointer);
    STRINGISE_ENUM_CLASS(TypeFunction);
    STRINGISE_ENUM_CLASS(TypeEvent);
    STRINGISE_ENUM_CLASS(TypeDeviceEvent);
    STRINGISE_ENUM_CLASS(TypeReserveId);
    STRINGISE_ENUM_CLASS(TypeQueue);
    STRINGISE_ENUM_CLASS(TypePipe);
    STRINGISE_ENUM_CLASS(TypeForwardPointer);
    STRINGISE_ENUM_CLASS(ConstantTrue);
    STRINGISE_ENUM_CLASS(ConstantFalse);
    STRINGISE_ENUM_CLASS(Constant);
    STRINGISE_ENUM_CLASS(ConstantComposite);
    STRINGISE_ENUM_CLASS(ConstantSampler);
    STRINGISE_ENUM_CLASS(ConstantNull);
    STRINGISE_ENUM_CLASS(SpecConstantTrue);
    STRINGISE_ENUM_CLASS(SpecConstantFalse);
    STRINGISE_ENUM_CLASS(SpecConstant);
    STRINGISE_ENUM_CLASS(SpecConstantComposite);
    STRINGISE_ENUM_CLASS(SpecConstantOp);
    STRINGISE_ENUM_CLASS(Function);
    STRINGISE_ENUM_CLASS(FunctionParameter);
    STRINGISE_ENUM_CLASS(FunctionEnd);
    STRINGISE_ENUM_CLASS(FunctionCall);
    STRINGISE_ENUM_CLASS(Variable);
    STRINGISE_ENUM_CLASS(ImageTexelPointer);
    STRINGISE_ENUM_CLASS(Load);
    STRINGISE_ENUM_CLASS(Store);
    STRINGISE_ENUM_CLASS(CopyMemory);
    STRINGISE_ENUM_CLASS(CopyMemorySized);
    STRINGISE_ENUM_CLASS(AccessChain);
    STRINGISE_ENUM_CLASS(InBoundsAccessChain);
    STRINGISE_ENUM_CLASS(PtrAccessChain);
    STRINGISE_ENUM_CLASS(ArrayLength);
    STRINGISE_ENUM_CLASS(GenericPtrMemSemantics);
    STRINGISE_ENUM_CLASS(InBoundsPtrAccessChain);
    STRINGISE_ENUM_CLASS(Decorate);
    STRINGISE_ENUM_CLASS(MemberDecorate);
    STRINGISE_ENUM_CLASS(DecorationGroup);
    STRINGISE_ENUM_CLASS(GroupDecorate);
    STRINGISE_ENUM_CLASS(GroupMemberDecorate);
    STRINGISE_ENUM_CLASS(VectorExtractDynamic);
    STRINGISE_ENUM_CLASS(VectorInsertDynamic);
    STRINGISE_ENUM_CLASS(VectorShuffle);
    STRINGISE_ENUM_CLASS(CompositeConstruct);
    STRINGISE_ENUM_CLASS(CompositeExtract);
    STRINGISE_ENUM_CLASS(CompositeInsert);
    STRINGISE_ENUM_CLASS(CopyObject);
    STRINGISE_ENUM_CLASS(Transpose);
    STRINGISE_ENUM_CLASS(SampledImage);
    STRINGISE_ENUM_CLASS(ImageSampleImplicitLod);
    STRINGISE_ENUM_CLASS(ImageSampleExplicitLod);
    STRINGISE_ENUM_CLASS(ImageSampleDrefImplicitLod);
    STRINGISE_ENUM_CLASS(ImageSampleDrefExplicitLod);
    STRINGISE_ENUM_CLASS(ImageSampleProjImplicitLod);
    STRINGISE_ENUM_CLASS(ImageSampleProjExplicitLod);
    STRINGISE_ENUM_CLASS(ImageSampleProjDrefImplicitLod);
    STRINGISE_ENUM_CLASS(ImageSampleProjDrefExplicitLod);
    STRINGISE_ENUM_CLASS(ImageFetch);
    STRINGISE_ENUM_CLASS(ImageGather);
    STRINGISE_ENUM_CLASS(ImageDrefGather);
    STRINGISE_ENUM_CLASS(ImageRead);
    STRINGISE_ENUM_CLASS(ImageWrite);
    STRINGISE_ENUM_CLASS(Image);
    STRINGISE_ENUM_CLASS(ImageQueryFormat);
    STRINGISE_ENUM_CLASS(ImageQueryOrder);
    STRINGISE_ENUM_CLASS(ImageQuerySizeLod);
    STRINGISE_ENUM_CLASS(ImageQuerySize);
    STRINGISE_ENUM_CLASS(ImageQueryLod);
    STRINGISE_ENUM_CLASS(ImageQueryLevels);
    STRINGISE_ENUM_CLASS(ImageQuerySamples);
    STRINGISE_ENUM_CLASS(ConvertFToU);
    STRINGISE_ENUM_CLASS(ConvertFToS);
    STRINGISE_ENUM_CLASS(ConvertSToF);
    STRINGISE_ENUM_CLASS(ConvertUToF);
    STRINGISE_ENUM_CLASS(UConvert);
    STRINGISE_ENUM_CLASS(SConvert);
    STRINGISE_ENUM_CLASS(FConvert);
    STRINGISE_ENUM_CLASS(QuantizeToF16);
    STRINGISE_ENUM_CLASS(ConvertPtrToU);
    STRINGISE_ENUM_CLASS(SatConvertSToU);
    STRINGISE_ENUM_CLASS(SatConvertUToS);
    STRINGISE_ENUM_CLASS(ConvertUToPtr);
    STRINGISE_ENUM_CLASS(PtrCastToGeneric);
    STRINGISE_ENUM_CLASS(GenericCastToPtr);
    STRINGISE_ENUM_CLASS(GenericCastToPtrExplicit);
    STRINGISE_ENUM_CLASS(Bitcast);
    STRINGISE_ENUM_CLASS(SNegate);
    STRINGISE_ENUM_CLASS(FNegate);
    STRINGISE_ENUM_CLASS(IAdd);
    STRINGISE_ENUM_CLASS(FAdd);
    STRINGISE_ENUM_CLASS(ISub);
    STRINGISE_ENUM_CLASS(FSub);
    STRINGISE_ENUM_CLASS(IMul);
    STRINGISE_ENUM_CLASS(FMul);
    STRINGISE_ENUM_CLASS(UDiv);
    STRINGISE_ENUM_CLASS(SDiv);
    STRINGISE_ENUM_CLASS(FDiv);
    STRINGISE_ENUM_CLASS(UMod);
    STRINGISE_ENUM_CLASS(SRem);
    STRINGISE_ENUM_CLASS(SMod);
    STRINGISE_ENUM_CLASS(FRem);
    STRINGISE_ENUM_CLASS(FMod);
    STRINGISE_ENUM_CLASS(VectorTimesScalar);
    STRINGISE_ENUM_CLASS(MatrixTimesScalar);
    STRINGISE_ENUM_CLASS(VectorTimesMatrix);
    STRINGISE_ENUM_CLASS(MatrixTimesVector);
    STRINGISE_ENUM_CLASS(MatrixTimesMatrix);
    STRINGISE_ENUM_CLASS(OuterProduct);
    STRINGISE_ENUM_CLASS(Dot);
    STRINGISE_ENUM_CLASS(IAddCarry);
    STRINGISE_ENUM_CLASS(ISubBorrow);
    STRINGISE_ENUM_CLASS(UMulExtended);
    STRINGISE_ENUM_CLASS(SMulExtended);
    STRINGISE_ENUM_CLASS(Any);
    STRINGISE_ENUM_CLASS(All);
    STRINGISE_ENUM_CLASS(IsNan);
    STRINGISE_ENUM_CLASS(IsInf);
    STRINGISE_ENUM_CLASS(IsFinite);
    STRINGISE_ENUM_CLASS(IsNormal);
    STRINGISE_ENUM_CLASS(SignBitSet);
    STRINGISE_ENUM_CLASS(LessOrGreater);
    STRINGISE_ENUM_CLASS(Ordered);
    STRINGISE_ENUM_CLASS(Unordered);
    STRINGISE_ENUM_CLASS(LogicalEqual);
    STRINGISE_ENUM_CLASS(LogicalNotEqual);
    STRINGISE_ENUM_CLASS(LogicalOr);
    STRINGISE_ENUM_CLASS(LogicalAnd);
    STRINGISE_ENUM_CLASS(LogicalNot);
    STRINGISE_ENUM_CLASS(Select);
    STRINGISE_ENUM_CLASS(IEqual);
    STRINGISE_ENUM_CLASS(INotEqual);
    STRINGISE_ENUM_CLASS(UGreaterThan);
    STRINGISE_ENUM_CLASS(SGreaterThan);
    STRINGISE_ENUM_CLASS(UGreaterThanEqual);
    STRINGISE_ENUM_CLASS(SGreaterThanEqual);
    STRINGISE_ENUM_CLASS(ULessThan);
    STRINGISE_ENUM_CLASS(SLessThan);
    STRINGISE_ENUM_CLASS(ULessThanEqual);
    STRINGISE_ENUM_CLASS(SLessThanEqual);
    STRINGISE_ENUM_CLASS(FOrdEqual);
    STRINGISE_ENUM_CLASS(FUnordEqual);
    STRINGISE_ENUM_CLASS(FOrdNotEqual);
    STRINGISE_ENUM_CLASS(FUnordNotEqual);
    STRINGISE_ENUM_CLASS(FOrdLessThan);
    STRINGISE_ENUM_CLASS(FUnordLessThan);
    STRINGISE_ENUM_CLASS(FOrdGreaterThan);
    STRINGISE_ENUM_CLASS(FUnordGreaterThan);
    STRINGISE_ENUM_CLASS(FOrdLessThanEqual);
    STRINGISE_ENUM_CLASS(FUnordLessThanEqual);
    STRINGISE_ENUM_CLASS(FOrdGreaterThanEqual);
    STRINGISE_ENUM_CLASS(FUnordGreaterThanEqual);
    STRINGISE_ENUM_CLASS(ShiftRightLogical);
    STRINGISE_ENUM_CLASS(ShiftRightArithmetic);
    STRINGISE_ENUM_CLASS(ShiftLeftLogical);
    STRINGISE_ENUM_CLASS(BitwiseOr);
    STRINGISE_ENUM_CLASS(BitwiseXor);
    STRINGISE_ENUM_CLASS(BitwiseAnd);
    STRINGISE_ENUM_CLASS(Not);
    STRINGISE_ENUM_CLASS(BitFieldInsert);
    STRINGISE_ENUM_CLASS(BitFieldSExtract);
    STRINGISE_ENUM_CLASS(BitFieldUExtract);
    STRINGISE_ENUM_CLASS(BitReverse);
    STRINGISE_ENUM_CLASS(BitCount);
    STRINGISE_ENUM_CLASS(DPdx);
    STRINGISE_ENUM_CLASS(DPdy);
    STRINGISE_ENUM_CLASS(Fwidth);
    STRINGISE_ENUM_CLASS(DPdxFine);
    STRINGISE_ENUM_CLASS(DPdyFine);
    STRINGISE_ENUM_CLASS(FwidthFine);
    STRINGISE_ENUM_CLASS(DPdxCoarse);
    STRINGISE_ENUM_CLASS(DPdyCoarse);
    STRINGISE_ENUM_CLASS(FwidthCoarse);
    STRINGISE_ENUM_CLASS(EmitVertex);
    STRINGISE_ENUM_CLASS(EndPrimitive);
    STRINGISE_ENUM_CLASS(EmitStreamVertex);
    STRINGISE_ENUM_CLASS(EndStreamPrimitive);
    STRINGISE_ENUM_CLASS(ControlBarrier);
    STRINGISE_ENUM_CLASS(MemoryBarrier);
    STRINGISE_ENUM_CLASS(AtomicLoad);
    STRINGISE_ENUM_CLASS(AtomicStore);
    STRINGISE_ENUM_CLASS(AtomicExchange);
    STRINGISE_ENUM_CLASS(AtomicCompareExchange);
    STRINGISE_ENUM_CLASS(AtomicCompareExchangeWeak);
    STRINGISE_ENUM_CLASS(AtomicIIncrement);
    STRINGISE_ENUM_CLASS(AtomicIDecrement);
    STRINGISE_ENUM_CLASS(AtomicIAdd);
    STRINGISE_ENUM_CLASS(AtomicISub);
    STRINGISE_ENUM_CLASS(AtomicSMin);
    STRINGISE_ENUM_CLASS(AtomicUMin);
    STRINGISE_ENUM_CLASS(AtomicSMax);
    STRINGISE_ENUM_CLASS(AtomicUMax);
    STRINGISE_ENUM_CLASS(AtomicAnd);
    STRINGISE_ENUM_CLASS(AtomicOr);
    STRINGISE_ENUM_CLASS(AtomicXor);
    STRINGISE_ENUM_CLASS(Phi);
    STRINGISE_ENUM_CLASS(LoopMerge);
    STRINGISE_ENUM_CLASS(SelectionMerge);
    STRINGISE_ENUM_CLASS(Label);
    STRINGISE_ENUM_CLASS(Branch);
    STRINGISE_ENUM_CLASS(BranchConditional);
    STRINGISE_ENUM_CLASS(Switch);
    STRINGISE_ENUM_CLASS(Kill);
    STRINGISE_ENUM_CLASS(Return);
    STRINGISE_ENUM_CLASS(ReturnValue);
    STRINGISE_ENUM_CLASS(Unreachable);
    STRINGISE_ENUM_CLASS(LifetimeStart);
    STRINGISE_ENUM_CLASS(LifetimeStop);
    STRINGISE_ENUM_CLASS(GroupAsyncCopy);
    STRINGISE_ENUM_CLASS(GroupWaitEvents);
    STRINGISE_ENUM_CLASS(GroupAll);
    STRINGISE_ENUM_CLASS(GroupAny);
    STRINGISE_ENUM_CLASS(GroupBroadcast);
    STRINGISE_ENUM_CLASS(GroupIAdd);
    STRINGISE_ENUM_CLASS(GroupFAdd);
    STRINGISE_ENUM_CLASS(GroupFMin);
    STRINGISE_ENUM_CLASS(GroupUMin);
    STRINGISE_ENUM_CLASS(GroupSMin);
    STRINGISE_ENUM_CLASS(GroupFMax);
    STRINGISE_ENUM_CLASS(GroupUMax);
    STRINGISE_ENUM_CLASS(GroupSMax);
    STRINGISE_ENUM_CLASS(ReadPipe);
    STRINGISE_ENUM_CLASS(WritePipe);
    STRINGISE_ENUM_CLASS(ReservedReadPipe);
    STRINGISE_ENUM_CLASS(ReservedWritePipe);
    STRINGISE_ENUM_CLASS(ReserveReadPipePackets);
    STRINGISE_ENUM_CLASS(ReserveWritePipePackets);
    STRINGISE_ENUM_CLASS(CommitReadPipe);
    STRINGISE_ENUM_CLASS(CommitWritePipe);
    STRINGISE_ENUM_CLASS(IsValidReserveId);
    STRINGISE_ENUM_CLASS(GetNumPipePackets);
    STRINGISE_ENUM_CLASS(GetMaxPipePackets);
    STRINGISE_ENUM_CLASS(GroupReserveReadPipePackets);
    STRINGISE_ENUM_CLASS(GroupReserveWritePipePackets);
    STRINGISE_ENUM_CLASS(GroupCommitReadPipe);
    STRINGISE_ENUM_CLASS(GroupCommitWritePipe);
    STRINGISE_ENUM_CLASS(EnqueueMarker);
    STRINGISE_ENUM_CLASS(EnqueueKernel);
    STRINGISE_ENUM_CLASS(GetKernelNDrangeSubGroupCount);
    STRINGISE_ENUM_CLASS(GetKernelNDrangeMaxSubGroupSize);
    STRINGISE_ENUM_CLASS(GetKernelWorkGroupSize);
    STRINGISE_ENUM_CLASS(GetKernelPreferredWorkGroupSizeMultiple);
    STRINGISE_ENUM_CLASS(RetainEvent);
    STRINGISE_ENUM_CLASS(ReleaseEvent);
    STRINGISE_ENUM_CLASS(CreateUserEvent);
    STRINGISE_ENUM_CLASS(IsValidEvent);
    STRINGISE_ENUM_CLASS(SetUserEventStatus);
    STRINGISE_ENUM_CLASS(CaptureEventProfilingInfo);
    STRINGISE_ENUM_CLASS(GetDefaultQueue);
    STRINGISE_ENUM_CLASS(BuildNDRange);
    STRINGISE_ENUM_CLASS(ImageSparseSampleImplicitLod);
    STRINGISE_ENUM_CLASS(ImageSparseSampleExplicitLod);
    STRINGISE_ENUM_CLASS(ImageSparseSampleDrefImplicitLod);
    STRINGISE_ENUM_CLASS(ImageSparseSampleDrefExplicitLod);
    STRINGISE_ENUM_CLASS(ImageSparseSampleProjImplicitLod);
    STRINGISE_ENUM_CLASS(ImageSparseSampleProjExplicitLod);
    STRINGISE_ENUM_CLASS(ImageSparseSampleProjDrefImplicitLod);
    STRINGISE_ENUM_CLASS(ImageSparseSampleProjDrefExplicitLod);
    STRINGISE_ENUM_CLASS(ImageSparseFetch);
    STRINGISE_ENUM_CLASS(ImageSparseGather);
    STRINGISE_ENUM_CLASS(ImageSparseDrefGather);
    STRINGISE_ENUM_CLASS(ImageSparseTexelsResident);
    STRINGISE_ENUM_CLASS(NoLine);
    STRINGISE_ENUM_CLASS(AtomicFlagTestAndSet);
    STRINGISE_ENUM_CLASS(AtomicFlagClear);
    STRINGISE_ENUM_CLASS(ImageSparseRead);
    STRINGISE_ENUM_CLASS(SizeOf);
    STRINGISE_ENUM_CLASS(TypePipeStorage);
    STRINGISE_ENUM_CLASS(ConstantPipeStorage);
    STRINGISE_ENUM_CLASS(CreatePipeFromPipeStorage);
    STRINGISE_ENUM_CLASS(GetKernelLocalSizeForSubgroupCount);
    STRINGISE_ENUM_CLASS(GetKernelMaxNumSubgroups);
    STRINGISE_ENUM_CLASS(TypeNamedBarrier);
    STRINGISE_ENUM_CLASS(NamedBarrierInitialize);
    STRINGISE_ENUM_CLASS(MemoryNamedBarrier);
    STRINGISE_ENUM_CLASS(ModuleProcessed);
    STRINGISE_ENUM_CLASS(ExecutionModeId);
    STRINGISE_ENUM_CLASS(DecorateId);
    STRINGISE_ENUM_CLASS(GroupNonUniformElect);
    STRINGISE_ENUM_CLASS(GroupNonUniformAll);
    STRINGISE_ENUM_CLASS(GroupNonUniformAny);
    STRINGISE_ENUM_CLASS(GroupNonUniformAllEqual);
    STRINGISE_ENUM_CLASS(GroupNonUniformBroadcast);
    STRINGISE_ENUM_CLASS(GroupNonUniformBroadcastFirst);
    STRINGISE_ENUM_CLASS(GroupNonUniformBallot);
    STRINGISE_ENUM_CLASS(GroupNonUniformInverseBallot);
    STRINGISE_ENUM_CLASS(GroupNonUniformBallotBitExtract);
    STRINGISE_ENUM_CLASS(GroupNonUniformBallotBitCount);
    STRINGISE_ENUM_CLASS(GroupNonUniformBallotFindLSB);
    STRINGISE_ENUM_CLASS(GroupNonUniformBallotFindMSB);
    STRINGISE_ENUM_CLASS(GroupNonUniformShuffle);
    STRINGISE_ENUM_CLASS(GroupNonUniformShuffleXor);
    STRINGISE_ENUM_CLASS(GroupNonUniformShuffleUp);
    STRINGISE_ENUM_CLASS(GroupNonUniformShuffleDown);
    STRINGISE_ENUM_CLASS(GroupNonUniformIAdd);
    STRINGISE_ENUM_CLASS(GroupNonUniformFAdd);
    STRINGISE_ENUM_CLASS(GroupNonUniformIMul);
    STRINGISE_ENUM_CLASS(GroupNonUniformFMul);
    STRINGISE_ENUM_CLASS(GroupNonUniformSMin);
    STRINGISE_ENUM_CLASS(GroupNonUniformUMin);
    STRINGISE_ENUM_CLASS(GroupNonUniformFMin);
    STRINGISE_ENUM_CLASS(GroupNonUniformSMax);
    STRINGISE_ENUM_CLASS(GroupNonUniformUMax);
    STRINGISE_ENUM_CLASS(GroupNonUniformFMax);
    STRINGISE_ENUM_CLASS(GroupNonUniformBitwiseAnd);
    STRINGISE_ENUM_CLASS(GroupNonUniformBitwiseOr);
    STRINGISE_ENUM_CLASS(GroupNonUniformBitwiseXor);
    STRINGISE_ENUM_CLASS(GroupNonUniformLogicalAnd);
    STRINGISE_ENUM_CLASS(GroupNonUniformLogicalOr);
    STRINGISE_ENUM_CLASS(GroupNonUniformLogicalXor);
    STRINGISE_ENUM_CLASS(GroupNonUniformQuadBroadcast);
    STRINGISE_ENUM_CLASS(GroupNonUniformQuadSwap);
    STRINGISE_ENUM_CLASS(CopyLogical);
    STRINGISE_ENUM_CLASS(PtrEqual);
    STRINGISE_ENUM_CLASS(PtrNotEqual);
    STRINGISE_ENUM_CLASS(PtrDiff);
    STRINGISE_ENUM_CLASS(TerminateInvocation);
    STRINGISE_ENUM_CLASS(SubgroupBallotKHR);
    STRINGISE_ENUM_CLASS(SubgroupFirstInvocationKHR);
    STRINGISE_ENUM_CLASS(SubgroupAllKHR);
    STRINGISE_ENUM_CLASS(SubgroupAnyKHR);
    STRINGISE_ENUM_CLASS(SubgroupAllEqualKHR);
    STRINGISE_ENUM_CLASS(SubgroupReadInvocationKHR);
    STRINGISE_ENUM_CLASS(TraceRayKHR);
    STRINGISE_ENUM_CLASS(ExecuteCallableKHR);
    STRINGISE_ENUM_CLASS(ConvertUToAccelerationStructureKHR);
    STRINGISE_ENUM_CLASS(IgnoreIntersectionKHR);
    STRINGISE_ENUM_CLASS(TerminateRayKHR);
    STRINGISE_ENUM_CLASS(TypeRayQueryKHR);
    STRINGISE_ENUM_CLASS(RayQueryInitializeKHR);
    STRINGISE_ENUM_CLASS(RayQueryTerminateKHR);
    STRINGISE_ENUM_CLASS(RayQueryGenerateIntersectionKHR);
    STRINGISE_ENUM_CLASS(RayQueryConfirmIntersectionKHR);
    STRINGISE_ENUM_CLASS(RayQueryProceedKHR);
    STRINGISE_ENUM_CLASS(RayQueryGetIntersectionTypeKHR);
    STRINGISE_ENUM_CLASS(GroupIAddNonUniformAMD);
    STRINGISE_ENUM_CLASS(GroupFAddNonUniformAMD);
    STRINGISE_ENUM_CLASS(GroupFMinNonUniformAMD);
    STRINGISE_ENUM_CLASS(GroupUMinNonUniformAMD);
    STRINGISE_ENUM_CLASS(GroupSMinNonUniformAMD);
    STRINGISE_ENUM_CLASS(GroupFMaxNonUniformAMD);
    STRINGISE_ENUM_CLASS(GroupUMaxNonUniformAMD);
    STRINGISE_ENUM_CLASS(GroupSMaxNonUniformAMD);
    STRINGISE_ENUM_CLASS(FragmentMaskFetchAMD);
    STRINGISE_ENUM_CLASS(FragmentFetchAMD);
    STRINGISE_ENUM_CLASS(ReadClockKHR);
    STRINGISE_ENUM_CLASS(ImageSampleFootprintNV);
    STRINGISE_ENUM_CLASS(GroupNonUniformPartitionNV);
    STRINGISE_ENUM_CLASS(WritePackedPrimitiveIndices4x8NV);
    STRINGISE_ENUM_CLASS(ReportIntersectionNV);
    STRINGISE_ENUM_CLASS(IgnoreIntersectionNV);
    STRINGISE_ENUM_CLASS(TerminateRayNV);
    STRINGISE_ENUM_CLASS(TraceNV);
    STRINGISE_ENUM_CLASS(TypeAccelerationStructureNV);
    STRINGISE_ENUM_CLASS(ExecuteCallableNV);
    STRINGISE_ENUM_CLASS(TypeCooperativeMatrixNV);
    STRINGISE_ENUM_CLASS(CooperativeMatrixLoadNV);
    STRINGISE_ENUM_CLASS(CooperativeMatrixStoreNV);
    STRINGISE_ENUM_CLASS(CooperativeMatrixMulAddNV);
    STRINGISE_ENUM_CLASS(CooperativeMatrixLengthNV);
    STRINGISE_ENUM_CLASS(BeginInvocationInterlockEXT);
    STRINGISE_ENUM_CLASS(EndInvocationInterlockEXT);
    STRINGISE_ENUM_CLASS(DemoteToHelperInvocationEXT);
    STRINGISE_ENUM_CLASS(IsHelperInvocationEXT);
    STRINGISE_ENUM_CLASS(SubgroupShuffleINTEL);
    STRINGISE_ENUM_CLASS(SubgroupShuffleDownINTEL);
    STRINGISE_ENUM_CLASS(SubgroupShuffleUpINTEL);
    STRINGISE_ENUM_CLASS(SubgroupShuffleXorINTEL);
    STRINGISE_ENUM_CLASS(SubgroupBlockReadINTEL);
    STRINGISE_ENUM_CLASS(SubgroupBlockWriteINTEL);
    STRINGISE_ENUM_CLASS(SubgroupImageBlockReadINTEL);
    STRINGISE_ENUM_CLASS(SubgroupImageBlockWriteINTEL);
    STRINGISE_ENUM_CLASS(SubgroupImageMediaBlockReadINTEL);
    STRINGISE_ENUM_CLASS(SubgroupImageMediaBlockWriteINTEL);
    STRINGISE_ENUM_CLASS(UCountLeadingZerosINTEL);
    STRINGISE_ENUM_CLASS(UCountTrailingZerosINTEL);
    STRINGISE_ENUM_CLASS(AbsISubINTEL);
    STRINGISE_ENUM_CLASS(AbsUSubINTEL);
    STRINGISE_ENUM_CLASS(IAddSatINTEL);
    STRINGISE_ENUM_CLASS(UAddSatINTEL);
    STRINGISE_ENUM_CLASS(IAverageINTEL);
    STRINGISE_ENUM_CLASS(UAverageINTEL);
    STRINGISE_ENUM_CLASS(IAverageRoundedINTEL);
    STRINGISE_ENUM_CLASS(UAverageRoundedINTEL);
    STRINGISE_ENUM_CLASS(ISubSatINTEL);
    STRINGISE_ENUM_CLASS(USubSatINTEL);
    STRINGISE_ENUM_CLASS(IMul32x16INTEL);
    STRINGISE_ENUM_CLASS(UMul32x16INTEL);
    STRINGISE_ENUM_CLASS(FunctionPointerINTEL);
    STRINGISE_ENUM_CLASS(FunctionPointerCallINTEL);
    STRINGISE_ENUM_CLASS(DecorateString);
    STRINGISE_ENUM_CLASS(MemberDecorateString);
    STRINGISE_ENUM_CLASS(VmeImageINTEL);
    STRINGISE_ENUM_CLASS(TypeVmeImageINTEL);
    STRINGISE_ENUM_CLASS(TypeAvcImePayloadINTEL);
    STRINGISE_ENUM_CLASS(TypeAvcRefPayloadINTEL);
    STRINGISE_ENUM_CLASS(TypeAvcSicPayloadINTEL);
    STRINGISE_ENUM_CLASS(TypeAvcMcePayloadINTEL);
    STRINGISE_ENUM_CLASS(TypeAvcMceResultINTEL);
    STRINGISE_ENUM_CLASS(TypeAvcImeResultINTEL);
    STRINGISE_ENUM_CLASS(TypeAvcImeResultSingleReferenceStreamoutINTEL);
    STRINGISE_ENUM_CLASS(TypeAvcImeResultDualReferenceStreamoutINTEL);
    STRINGISE_ENUM_CLASS(TypeAvcImeSingleReferenceStreaminINTEL);
    STRINGISE_ENUM_CLASS(TypeAvcImeDualReferenceStreaminINTEL);
    STRINGISE_ENUM_CLASS(TypeAvcRefResultINTEL);
    STRINGISE_ENUM_CLASS(TypeAvcSicResultINTEL);
    STRINGISE_ENUM_CLASS(SubgroupAvcMceGetDefaultInterBaseMultiReferencePenaltyINTEL);
    STRINGISE_ENUM_CLASS(SubgroupAvcMceSetInterBaseMultiReferencePenaltyINTEL);
    STRINGISE_ENUM_CLASS(SubgroupAvcMceGetDefaultInterShapePenaltyINTEL);
    STRINGISE_ENUM_CLASS(SubgroupAvcMceSetInterShapePenaltyINTEL);
    STRINGISE_ENUM_CLASS(SubgroupAvcMceGetDefaultInterDirectionPenaltyINTEL);
    STRINGISE_ENUM_CLASS(SubgroupAvcMceSetInterDirectionPenaltyINTEL);
    STRINGISE_ENUM_CLASS(SubgroupAvcMceGetDefaultIntraLumaShapePenaltyINTEL);
    STRINGISE_ENUM_CLASS(SubgroupAvcMceGetDefaultInterMotionVectorCostTableINTEL);
    STRINGISE_ENUM_CLASS(SubgroupAvcMceGetDefaultHighPenaltyCostTableINTEL);
    STRINGISE_ENUM_CLASS(SubgroupAvcMceGetDefaultMediumPenaltyCostTableINTEL);
    STRINGISE_ENUM_CLASS(SubgroupAvcMceGetDefaultLowPenaltyCostTableINTEL);
    STRINGISE_ENUM_CLASS(SubgroupAvcMceSetMotionVectorCostFunctionINTEL);
    STRINGISE_ENUM_CLASS(SubgroupAvcMceGetDefaultIntraLumaModePenaltyINTEL);
    STRINGISE_ENUM_CLASS(SubgroupAvcMceGetDefaultNonDcLumaIntraPenaltyINTEL);
    STRINGISE_ENUM_CLASS(SubgroupAvcMceGetDefaultIntraChromaModeBasePenaltyINTEL);
    STRINGISE_ENUM_CLASS(SubgroupAvcMceSetAcOnlyHaarINTEL);
    STRINGISE_ENUM_CLASS(SubgroupAvcMceSetSourceInterlacedFieldPolarityINTEL);
    STRINGISE_ENUM_CLASS(SubgroupAvcMceSetSingleReferenceInterlacedFieldPolarityINTEL);
    STRINGISE_ENUM_CLASS(SubgroupAvcMceSetDualReferenceInterlacedFieldPolaritiesINTEL);
    STRINGISE_ENUM_CLASS(SubgroupAvcMceConvertToImePayloadINTEL);
    STRINGISE_ENUM_CLASS(SubgroupAvcMceConvertToImeResultINTEL);
    STRINGISE_ENUM_CLASS(SubgroupAvcMceConvertToRefPayloadINTEL);
    STRINGISE_ENUM_CLASS(SubgroupAvcMceConvertToRefResultINTEL);
    STRINGISE_ENUM_CLASS(SubgroupAvcMceConvertToSicPayloadINTEL);
    STRINGISE_ENUM_CLASS(SubgroupAvcMceConvertToSicResultINTEL);
    STRINGISE_ENUM_CLASS(SubgroupAvcMceGetMotionVectorsINTEL);
    STRINGISE_ENUM_CLASS(SubgroupAvcMceGetInterDistortionsINTEL);
    STRINGISE_ENUM_CLASS(SubgroupAvcMceGetBestInterDistortionsINTEL);
    STRINGISE_ENUM_CLASS(SubgroupAvcMceGetInterMajorShapeINTEL);
    STRINGISE_ENUM_CLASS(SubgroupAvcMceGetInterMinorShapeINTEL);
    STRINGISE_ENUM_CLASS(SubgroupAvcMceGetInterDirectionsINTEL);
    STRINGISE_ENUM_CLASS(SubgroupAvcMceGetInterMotionVectorCountINTEL);
    STRINGISE_ENUM_CLASS(SubgroupAvcMceGetInterReferenceIdsINTEL);
    STRINGISE_ENUM_CLASS(SubgroupAvcMceGetInterReferenceInterlacedFieldPolaritiesINTEL);
    STRINGISE_ENUM_CLASS(SubgroupAvcImeInitializeINTEL);
    STRINGISE_ENUM_CLASS(SubgroupAvcImeSetSingleReferenceINTEL);
    STRINGISE_ENUM_CLASS(SubgroupAvcImeSetDualReferenceINTEL);
    STRINGISE_ENUM_CLASS(SubgroupAvcImeRefWindowSizeINTEL);
    STRINGISE_ENUM_CLASS(SubgroupAvcImeAdjustRefOffsetINTEL);
    STRINGISE_ENUM_CLASS(SubgroupAvcImeConvertToMcePayloadINTEL);
    STRINGISE_ENUM_CLASS(SubgroupAvcImeSetMaxMotionVectorCountINTEL);
    STRINGISE_ENUM_CLASS(SubgroupAvcImeSetUnidirectionalMixDisableINTEL);
    STRINGISE_ENUM_CLASS(SubgroupAvcImeSetEarlySearchTerminationThresholdINTEL);
    STRINGISE_ENUM_CLASS(SubgroupAvcImeSetWeightedSadINTEL);
    STRINGISE_ENUM_CLASS(SubgroupAvcImeEvaluateWithSingleReferenceINTEL);
    STRINGISE_ENUM_CLASS(SubgroupAvcImeEvaluateWithDualReferenceINTEL);
    STRINGISE_ENUM_CLASS(SubgroupAvcImeEvaluateWithSingleReferenceStreaminINTEL);
    STRINGISE_ENUM_CLASS(SubgroupAvcImeEvaluateWithDualReferenceStreaminINTEL);
    STRINGISE_ENUM_CLASS(SubgroupAvcImeEvaluateWithSingleReferenceStreamoutINTEL);
    STRINGISE_ENUM_CLASS(SubgroupAvcImeEvaluateWithDualReferenceStreamoutINTEL);
    STRINGISE_ENUM_CLASS(SubgroupAvcImeEvaluateWithSingleReferenceStreaminoutINTEL);
    STRINGISE_ENUM_CLASS(SubgroupAvcImeEvaluateWithDualReferenceStreaminoutINTEL);
    STRINGISE_ENUM_CLASS(SubgroupAvcImeConvertToMceResultINTEL);
    STRINGISE_ENUM_CLASS(SubgroupAvcImeGetSingleReferenceStreaminINTEL);
    STRINGISE_ENUM_CLASS(SubgroupAvcImeGetDualReferenceStreaminINTEL);
    STRINGISE_ENUM_CLASS(SubgroupAvcImeStripSingleReferenceStreamoutINTEL);
    STRINGISE_ENUM_CLASS(SubgroupAvcImeStripDualReferenceStreamoutINTEL);
    STRINGISE_ENUM_CLASS(SubgroupAvcImeGetStreamoutSingleReferenceMajorShapeMotionVectorsINTEL);
    STRINGISE_ENUM_CLASS(SubgroupAvcImeGetStreamoutSingleReferenceMajorShapeDistortionsINTEL);
    STRINGISE_ENUM_CLASS(SubgroupAvcImeGetStreamoutSingleReferenceMajorShapeReferenceIdsINTEL);
    STRINGISE_ENUM_CLASS(SubgroupAvcImeGetStreamoutDualReferenceMajorShapeMotionVectorsINTEL);
    STRINGISE_ENUM_CLASS(SubgroupAvcImeGetStreamoutDualReferenceMajorShapeDistortionsINTEL);
    STRINGISE_ENUM_CLASS(SubgroupAvcImeGetStreamoutDualReferenceMajorShapeReferenceIdsINTEL);
    STRINGISE_ENUM_CLASS(SubgroupAvcImeGetBorderReachedINTEL);
    STRINGISE_ENUM_CLASS(SubgroupAvcImeGetTruncatedSearchIndicationINTEL);
    STRINGISE_ENUM_CLASS(SubgroupAvcImeGetUnidirectionalEarlySearchTerminationINTEL);
    STRINGISE_ENUM_CLASS(SubgroupAvcImeGetWeightingPatternMinimumMotionVectorINTEL);
    STRINGISE_ENUM_CLASS(SubgroupAvcImeGetWeightingPatternMinimumDistortionINTEL);
    STRINGISE_ENUM_CLASS(SubgroupAvcFmeInitializeINTEL);
    STRINGISE_ENUM_CLASS(SubgroupAvcBmeInitializeINTEL);
    STRINGISE_ENUM_CLASS(SubgroupAvcRefConvertToMcePayloadINTEL);
    STRINGISE_ENUM_CLASS(SubgroupAvcRefSetBidirectionalMixDisableINTEL);
    STRINGISE_ENUM_CLASS(SubgroupAvcRefSetBilinearFilterEnableINTEL);
    STRINGISE_ENUM_CLASS(SubgroupAvcRefEvaluateWithSingleReferenceINTEL);
    STRINGISE_ENUM_CLASS(SubgroupAvcRefEvaluateWithDualReferenceINTEL);
    STRINGISE_ENUM_CLASS(SubgroupAvcRefEvaluateWithMultiReferenceINTEL);
    STRINGISE_ENUM_CLASS(SubgroupAvcRefEvaluateWithMultiReferenceInterlacedINTEL);
    STRINGISE_ENUM_CLASS(SubgroupAvcRefConvertToMceResultINTEL);
    STRINGISE_ENUM_CLASS(SubgroupAvcSicInitializeINTEL);
    STRINGISE_ENUM_CLASS(SubgroupAvcSicConfigureSkcINTEL);
    STRINGISE_ENUM_CLASS(SubgroupAvcSicConfigureIpeLumaINTEL);
    STRINGISE_ENUM_CLASS(SubgroupAvcSicConfigureIpeLumaChromaINTEL);
    STRINGISE_ENUM_CLASS(SubgroupAvcSicGetMotionVectorMaskINTEL);
    STRINGISE_ENUM_CLASS(SubgroupAvcSicConvertToMcePayloadINTEL);
    STRINGISE_ENUM_CLASS(SubgroupAvcSicSetIntraLumaShapePenaltyINTEL);
    STRINGISE_ENUM_CLASS(SubgroupAvcSicSetIntraLumaModeCostFunctionINTEL);
    STRINGISE_ENUM_CLASS(SubgroupAvcSicSetIntraChromaModeCostFunctionINTEL);
    STRINGISE_ENUM_CLASS(SubgroupAvcSicSetBilinearFilterEnableINTEL);
    STRINGISE_ENUM_CLASS(SubgroupAvcSicSetSkcForwardTransformEnableINTEL);
    STRINGISE_ENUM_CLASS(SubgroupAvcSicSetBlockBasedRawSkipSadINTEL);
    STRINGISE_ENUM_CLASS(SubgroupAvcSicEvaluateIpeINTEL);
    STRINGISE_ENUM_CLASS(SubgroupAvcSicEvaluateWithSingleReferenceINTEL);
    STRINGISE_ENUM_CLASS(SubgroupAvcSicEvaluateWithDualReferenceINTEL);
    STRINGISE_ENUM_CLASS(SubgroupAvcSicEvaluateWithMultiReferenceINTEL);
    STRINGISE_ENUM_CLASS(SubgroupAvcSicEvaluateWithMultiReferenceInterlacedINTEL);
    STRINGISE_ENUM_CLASS(SubgroupAvcSicConvertToMceResultINTEL);
    STRINGISE_ENUM_CLASS(SubgroupAvcSicGetIpeLumaShapeINTEL);
    STRINGISE_ENUM_CLASS(SubgroupAvcSicGetBestIpeLumaDistortionINTEL);
    STRINGISE_ENUM_CLASS(SubgroupAvcSicGetBestIpeChromaDistortionINTEL);
    STRINGISE_ENUM_CLASS(SubgroupAvcSicGetPackedIpeLumaModesINTEL);
    STRINGISE_ENUM_CLASS(SubgroupAvcSicGetIpeChromaModeINTEL);
    STRINGISE_ENUM_CLASS(SubgroupAvcSicGetPackedSkcLumaCountThresholdINTEL);
    STRINGISE_ENUM_CLASS(SubgroupAvcSicGetPackedSkcLumaSumThresholdINTEL);
    STRINGISE_ENUM_CLASS(SubgroupAvcSicGetInterRawSadsINTEL);
    STRINGISE_ENUM_CLASS(LoopControlINTEL);
    STRINGISE_ENUM_CLASS(ReadPipeBlockingINTEL);
    STRINGISE_ENUM_CLASS(WritePipeBlockingINTEL);
    STRINGISE_ENUM_CLASS(FPGARegINTEL);
    STRINGISE_ENUM_CLASS(RayQueryGetRayTMinKHR);
    STRINGISE_ENUM_CLASS(RayQueryGetRayFlagsKHR);
    STRINGISE_ENUM_CLASS(RayQueryGetIntersectionTKHR);
    STRINGISE_ENUM_CLASS(RayQueryGetIntersectionInstanceCustomIndexKHR);
    STRINGISE_ENUM_CLASS(RayQueryGetIntersectionInstanceIdKHR);
    STRINGISE_ENUM_CLASS(RayQueryGetIntersectionInstanceShaderBindingTableRecordOffsetKHR);
    STRINGISE_ENUM_CLASS(RayQueryGetIntersectionGeometryIndexKHR);
    STRINGISE_ENUM_CLASS(RayQueryGetIntersectionPrimitiveIndexKHR);
    STRINGISE_ENUM_CLASS(RayQueryGetIntersectionBarycentricsKHR);
    STRINGISE_ENUM_CLASS(RayQueryGetIntersectionFrontFaceKHR);
    STRINGISE_ENUM_CLASS(RayQueryGetIntersectionCandidateAABBOpaqueKHR);
    STRINGISE_ENUM_CLASS(RayQueryGetIntersectionObjectRayDirectionKHR);
    STRINGISE_ENUM_CLASS(RayQueryGetIntersectionObjectRayOriginKHR);
    STRINGISE_ENUM_CLASS(RayQueryGetWorldRayDirectionKHR);
    STRINGISE_ENUM_CLASS(RayQueryGetWorldRayOriginKHR);
    STRINGISE_ENUM_CLASS(RayQueryGetIntersectionObjectToWorldKHR);
    STRINGISE_ENUM_CLASS(RayQueryGetIntersectionWorldToObjectKHR);
    STRINGISE_ENUM_CLASS(AtomicFAddEXT);
  }
  END_ENUM_STRINGISE();
}

namespace rdcspv
{

template<>
rdcstr ParamToStr(const std::function<rdcstr(rdcspv::Id)> &idName, const Id &el)
{
  return idName(el);
}

template<>
rdcstr ParamToStr(const std::function<rdcstr(rdcspv::Id)> &idName, const rdcstr &el)
{
  return "\"" + el + "\"";
}

template<>
rdcstr ParamToStr(const std::function<rdcstr(rdcspv::Id)> &idName, const PairLiteralIntegerIdRef &el)
{
  return StringFormat::Fmt("[%u, %s]", el.first, idName(el.second).c_str());
}

template<>
rdcstr ParamToStr(const std::function<rdcstr(rdcspv::Id)> &idName, const PairIdRefLiteralInteger &el)
{
  return StringFormat::Fmt("[%s, %u]", idName(el.first).c_str(), el.second);
}

template<>
rdcstr ParamToStr(const std::function<rdcstr(rdcspv::Id)> &idName, const PairIdRefIdRef &el)
{
  return StringFormat::Fmt("[%s, %s]", idName(el.first).c_str(), idName(el.second).c_str());
}

template<>
rdcstr ParamToStr(const std::function<rdcstr(rdcspv::Id)> &idName, const rdcspv::ImageOperandsAndParamDatas &el)
{
  rdcstr ret;
  
  if(el.flags & ImageOperands::None)
    ret += "None" ", ";
  if(el.flags & ImageOperands::Bias)
    ret += "Bias" "(" + idName(el.bias) + ")" ", ";
  if(el.flags & ImageOperands::Lod)
    ret += "Lod" "(" + idName(el.lod) + ")" ", ";
  if(el.flags & ImageOperands::Grad)
    ret += "Grad" "(" + idName(el.grad.first) + ", "  + idName(el.grad.second) + ")" ", ";
  if(el.flags & ImageOperands::ConstOffset)
    ret += "ConstOffset" "(" + idName(el.constOffset) + ")" ", ";
  if(el.flags & ImageOperands::Offset)
    ret += "Offset" "(" + idName(el.offset) + ")" ", ";
  if(el.flags & ImageOperands::ConstOffsets)
    ret += "ConstOffsets" "(" + idName(el.constOffsets) + ")" ", ";
  if(el.flags & ImageOperands::Sample)
    ret += "Sample" "(" + idName(el.sample) + ")" ", ";
  if(el.flags & ImageOperands::MinLod)
    ret += "MinLod" "(" + idName(el.minLod) + ")" ", ";
  if(el.flags & ImageOperands::MakeTexelAvailable)
    ret += "MakeTexelAvailable" "(" + idName(el.makeTexelAvailable) + ")" ", ";
  if(el.flags & ImageOperands::MakeTexelVisible)
    ret += "MakeTexelVisible" "(" + idName(el.makeTexelVisible) + ")" ", ";
  if(el.flags & ImageOperands::NonPrivateTexel)
    ret += "NonPrivateTexel" ", ";
  if(el.flags & ImageOperands::VolatileTexel)
    ret += "VolatileTexel" ", ";
  if(el.flags & ImageOperands::SignExtend)
    ret += "SignExtend" ", ";
  if(el.flags & ImageOperands::ZeroExtend)
    ret += "ZeroExtend" ", ";

  // remove trailing ", "
  if(ret.size() > 2)
    ret.erase(ret.size()-2, 2);

  return ret;
}

template<>
rdcstr ParamToStr(const std::function<rdcstr(rdcspv::Id)> &idName, const rdcspv::LoopControlAndParamDatas &el)
{
  rdcstr ret;
  
  if(el.flags & LoopControl::None)
    ret += "None" ", ";
  if(el.flags & LoopControl::Unroll)
    ret += "Unroll" ", ";
  if(el.flags & LoopControl::DontUnroll)
    ret += "DontUnroll" ", ";
  if(el.flags & LoopControl::DependencyInfinite)
    ret += "DependencyInfinite" ", ";
  if(el.flags & LoopControl::DependencyLength)
    ret += "DependencyLength" "(" + ToStr(el.dependencyLength) + ")" ", ";
  if(el.flags & LoopControl::MinIterations)
    ret += "MinIterations" "(" + ToStr(el.minIterations) + ")" ", ";
  if(el.flags & LoopControl::MaxIterations)
    ret += "MaxIterations" "(" + ToStr(el.maxIterations) + ")" ", ";
  if(el.flags & LoopControl::IterationMultiple)
    ret += "IterationMultiple" "(" + ToStr(el.iterationMultiple) + ")" ", ";
  if(el.flags & LoopControl::PeelCount)
    ret += "PeelCount" "(" + ToStr(el.peelCount) + ")" ", ";
  if(el.flags & LoopControl::PartialCount)
    ret += "PartialCount" "(" + ToStr(el.partialCount) + ")" ", ";
  if(el.flags & LoopControl::InitiationIntervalINTEL)
    ret += "InitiationIntervalINTEL" "(" + ToStr(el.initiationIntervalINTEL) + ")" ", ";
  if(el.flags & LoopControl::MaxConcurrencyINTEL)
    ret += "MaxConcurrencyINTEL" "(" + ToStr(el.maxConcurrencyINTEL) + ")" ", ";
  if(el.flags & LoopControl::DependencyArrayINTEL)
    ret += "DependencyArrayINTEL" "(" + ToStr(el.dependencyArrayINTEL) + ")" ", ";
  if(el.flags & LoopControl::PipelineEnableINTEL)
    ret += "PipelineEnableINTEL" "(" + ToStr(el.pipelineEnableINTEL) + ")" ", ";
  if(el.flags & LoopControl::LoopCoalesceINTEL)
    ret += "LoopCoalesceINTEL" "(" + ToStr(el.loopCoalesceINTEL) + ")" ", ";
  if(el.flags & LoopControl::MaxInterleavingINTEL)
    ret += "MaxInterleavingINTEL" "(" + ToStr(el.maxInterleavingINTEL) + ")" ", ";
  if(el.flags & LoopControl::SpeculatedIterationsINTEL)
    ret += "SpeculatedIterationsINTEL" "(" + ToStr(el.speculatedIterationsINTEL) + ")" ", ";

  // remove trailing ", "
  if(ret.size() > 2)
    ret.erase(ret.size()-2, 2);

  return ret;
}

template<>
rdcstr ParamToStr(const std::function<rdcstr(rdcspv::Id)> &idName, const rdcspv::MemoryAccessAndParamDatas &el)
{
  rdcstr ret;
  
  if(el.flags & MemoryAccess::None)
    ret += "None" ", ";
  if(el.flags & MemoryAccess::Volatile)
    ret += "Volatile" ", ";
  if(el.flags & MemoryAccess::Aligned)
    ret += "Aligned" "(" + ToStr(el.aligned) + ")" ", ";
  if(el.flags & MemoryAccess::Nontemporal)
    ret += "Nontemporal" ", ";
  if(el.flags & MemoryAccess::MakePointerAvailable)
    ret += "MakePointerAvailable" "(" + idName(el.makePointerAvailable) + ")" ", ";
  if(el.flags & MemoryAccess::MakePointerVisible)
    ret += "MakePointerVisible" "(" + idName(el.makePointerVisible) + ")" ", ";
  if(el.flags & MemoryAccess::NonPrivatePointer)
    ret += "NonPrivatePointer" ", ";

  // remove trailing ", "
  if(ret.size() > 2)
    ret.erase(ret.size()-2, 2);

  return ret;
}

template<>
rdcstr ParamToStr(const std::function<rdcstr(rdcspv::Id)> &idName, const rdcspv::ExecutionModeAndParamData &el)
{
  rdcstr ret = ToStr(el.value);

  switch(el.value)
  {
    case ExecutionMode::Invocations:
      ret +=  "(" + ToStr(el.invocations) + ")"; break;
    case ExecutionMode::LocalSize:
      ret +=  "(" + ToStr(el.localSize.xsize) + ", "  + ToStr(el.localSize.ysize) + ", "  + ToStr(el.localSize.zsize) + ")"; break;
    case ExecutionMode::LocalSizeHint:
      ret +=  "(" + ToStr(el.localSizeHint.xsize) + ", "  + ToStr(el.localSizeHint.ysize) + ", "  + ToStr(el.localSizeHint.zsize) + ")"; break;
    case ExecutionMode::OutputVertices:
      ret +=  "(" + ToStr(el.outputVertices) + ")"; break;
    case ExecutionMode::VecTypeHint:
      ret +=  "(" + ToStr(el.vecTypeHint) + ")"; break;
    case ExecutionMode::SubgroupSize:
      ret +=  "(" + ToStr(el.subgroupSize) + ")"; break;
    case ExecutionMode::SubgroupsPerWorkgroup:
      ret +=  "(" + ToStr(el.subgroupsPerWorkgroup) + ")"; break;
    case ExecutionMode::SubgroupsPerWorkgroupId:
      ret +=  "(" + idName(el.subgroupsPerWorkgroupId) + ")"; break;
    case ExecutionMode::LocalSizeId:
      ret +=  "(" + idName(el.localSizeId.xsize) + ", "  + idName(el.localSizeId.ysize) + ", "  + idName(el.localSizeId.zsize) + ")"; break;
    case ExecutionMode::LocalSizeHintId:
      ret +=  "(" + idName(el.localSizeHintId) + ")"; break;
    case ExecutionMode::DenormPreserve:
      ret +=  "(" + ToStr(el.denormPreserve) + ")"; break;
    case ExecutionMode::DenormFlushToZero:
      ret +=  "(" + ToStr(el.denormFlushToZero) + ")"; break;
    case ExecutionMode::SignedZeroInfNanPreserve:
      ret +=  "(" + ToStr(el.signedZeroInfNanPreserve) + ")"; break;
    case ExecutionMode::RoundingModeRTE:
      ret +=  "(" + ToStr(el.roundingModeRTE) + ")"; break;
    case ExecutionMode::RoundingModeRTZ:
      ret +=  "(" + ToStr(el.roundingModeRTZ) + ")"; break;
    case ExecutionMode::OutputPrimitivesNV:
      ret +=  "(" + ToStr(el.outputPrimitivesNV) + ")"; break;
    case ExecutionMode::MaxWorkgroupSizeINTEL:
      ret +=  "(" + ToStr(el.maxWorkgroupSizeINTEL.max_x_size) + ", "  + ToStr(el.maxWorkgroupSizeINTEL.max_y_size) + ", "  + ToStr(el.maxWorkgroupSizeINTEL.max_z_size) + ")"; break;
    case ExecutionMode::MaxWorkDimINTEL:
      ret +=  "(" + ToStr(el.maxWorkDimINTEL) + ")"; break;
    case ExecutionMode::NumSIMDWorkitemsINTEL:
      ret +=  "(" + ToStr(el.numSIMDWorkitemsINTEL) + ")"; break;
    default:
      break;
  }

  return ret;
}

template<>
rdcstr ParamToStr(const std::function<rdcstr(rdcspv::Id)> &idName, const rdcspv::DecorationAndParamData &el)
{
  rdcstr ret = ToStr(el.value);

  switch(el.value)
  {
    case Decoration::SpecId:
      ret +=  "(" + ToStr(el.specId) + ")"; break;
    case Decoration::ArrayStride:
      ret +=  "(" + ToStr(el.arrayStride) + ")"; break;
    case Decoration::MatrixStride:
      ret +=  "(" + ToStr(el.matrixStride) + ")"; break;
    case Decoration::BuiltIn:
      ret +=  "(" + ToStr(el.builtIn) + ")"; break;
    case Decoration::UniformId:
      ret +=  "(" + idName(el.uniformId) + ")"; break;
    case Decoration::Stream:
      ret +=  "(" + ToStr(el.stream) + ")"; break;
    case Decoration::Location:
      ret +=  "(" + ToStr(el.location) + ")"; break;
    case Decoration::Component:
      ret +=  "(" + ToStr(el.component) + ")"; break;
    case Decoration::Index:
      ret +=  "(" + ToStr(el.index) + ")"; break;
    case Decoration::Binding:
      ret +=  "(" + ToStr(el.binding) + ")"; break;
    case Decoration::DescriptorSet:
      ret +=  "(" + ToStr(el.descriptorSet) + ")"; break;
    case Decoration::Offset:
      ret +=  "(" + ToStr(el.offset) + ")"; break;
    case Decoration::XfbBuffer:
      ret +=  "(" + ToStr(el.xfbBuffer) + ")"; break;
    case Decoration::XfbStride:
      ret +=  "(" + ToStr(el.xfbStride) + ")"; break;
    case Decoration::FuncParamAttr:
      ret +=  "(" + ToStr(el.funcParamAttr) + ")"; break;
    case Decoration::FPRoundingMode:
      ret +=  "(" + ToStr(el.fPRoundingMode) + ")"; break;
    case Decoration::FPFastMathMode:
      ret +=  "(" + ToStr(el.fPFastMathMode) + ")"; break;
    case Decoration::InputAttachmentIndex:
      ret +=  "(" + ToStr(el.inputAttachmentIndex) + ")"; break;
    case Decoration::Alignment:
      ret +=  "(" + ToStr(el.alignment) + ")"; break;
    case Decoration::MaxByteOffset:
      ret +=  "(" + ToStr(el.maxByteOffset) + ")"; break;
    case Decoration::AlignmentId:
      ret +=  "(" + idName(el.alignmentId) + ")"; break;
    case Decoration::MaxByteOffsetId:
      ret +=  "(" + idName(el.maxByteOffsetId) + ")"; break;
    case Decoration::SecondaryViewportRelativeNV:
      ret +=  "(" + ToStr(el.secondaryViewportRelativeNV) + ")"; break;
    case Decoration::CounterBuffer:
      ret +=  "(" + idName(el.counterBuffer) + ")"; break;
    case Decoration::NumbanksINTEL:
      ret +=  "(" + ToStr(el.numbanksINTEL) + ")"; break;
    case Decoration::BankwidthINTEL:
      ret +=  "(" + ToStr(el.bankwidthINTEL) + ")"; break;
    case Decoration::MaxPrivateCopiesINTEL:
      ret +=  "(" + ToStr(el.maxPrivateCopiesINTEL) + ")"; break;
    case Decoration::MaxReplicatesINTEL:
      ret +=  "(" + ToStr(el.maxReplicatesINTEL) + ")"; break;
    case Decoration::BankBitsINTEL:
      ret +=  "(" + ToStr(el.bankBitsINTEL) + ")"; break;
    case Decoration::ForcePow2DepthINTEL:
      ret +=  "(" + ToStr(el.forcePow2DepthINTEL) + ")"; break;
    default:
      break;
  }

  return ret;
}

void OpDecoder::ForEachID(const ConstIter &it, const std::function<void(Id,bool)> &callback)
{
  size_t size = it.size();
  switch(it.opcode())
  {
    case rdcspv::Op::Nop:
      break;
    case rdcspv::Op::Undef:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      break;
    case rdcspv::Op::SourceContinued:
      break;
    case rdcspv::Op::Source:
      callback(Id::fromWord(it.word(3)), false);
      break;
    case rdcspv::Op::SourceExtension:
      break;
    case rdcspv::Op::Name:
      callback(Id::fromWord(it.word(1)), false);
      break;
    case rdcspv::Op::MemberName:
      callback(Id::fromWord(it.word(1)), false);
      break;
    case rdcspv::Op::String:
      callback(Id::fromWord(it.word(1)), true);
      break;
    case rdcspv::Op::Line:
      callback(Id::fromWord(it.word(1)), false);
      break;
    case rdcspv::Op::Extension:
      break;
    case rdcspv::Op::ExtInstImport:
      callback(Id::fromWord(it.word(1)), true);
      break;
    case rdcspv::Op::ExtInst:
      break;
    case rdcspv::Op::MemoryModel:
      break;
    case rdcspv::Op::EntryPoint:
      callback(Id::fromWord(it.word(2)), false);
      for(size_t i=0; i < size-4; i++) callback(Id::fromWord(it.word(4+i)), false);
      break;
    case rdcspv::Op::ExecutionMode:
      callback(Id::fromWord(it.word(1)), false);
      break;
    case rdcspv::Op::Capability:
      break;
    case rdcspv::Op::TypeVoid:
      callback(Id::fromWord(it.word(1)), true);
      break;
    case rdcspv::Op::TypeBool:
      callback(Id::fromWord(it.word(1)), true);
      break;
    case rdcspv::Op::TypeInt:
      callback(Id::fromWord(it.word(1)), true);
      break;
    case rdcspv::Op::TypeFloat:
      callback(Id::fromWord(it.word(1)), true);
      break;
    case rdcspv::Op::TypeVector:
      callback(Id::fromWord(it.word(1)), true);
      callback(Id::fromWord(it.word(2)), false);
      break;
    case rdcspv::Op::TypeMatrix:
      callback(Id::fromWord(it.word(1)), true);
      callback(Id::fromWord(it.word(2)), false);
      break;
    case rdcspv::Op::TypeImage:
      callback(Id::fromWord(it.word(1)), true);
      callback(Id::fromWord(it.word(2)), false);
      break;
    case rdcspv::Op::TypeSampler:
      callback(Id::fromWord(it.word(1)), true);
      break;
    case rdcspv::Op::TypeSampledImage:
      callback(Id::fromWord(it.word(1)), true);
      callback(Id::fromWord(it.word(2)), false);
      break;
    case rdcspv::Op::TypeArray:
      callback(Id::fromWord(it.word(1)), true);
      callback(Id::fromWord(it.word(2)), false);
      callback(Id::fromWord(it.word(3)), false);
      break;
    case rdcspv::Op::TypeRuntimeArray:
      callback(Id::fromWord(it.word(1)), true);
      callback(Id::fromWord(it.word(2)), false);
      break;
    case rdcspv::Op::TypeStruct:
      callback(Id::fromWord(it.word(1)), true);
      for(size_t i=0; i < size-2; i++) callback(Id::fromWord(it.word(2+i)), false);
      break;
    case rdcspv::Op::TypeOpaque:
      callback(Id::fromWord(it.word(1)), true);
      break;
    case rdcspv::Op::TypePointer:
      callback(Id::fromWord(it.word(1)), true);
      callback(Id::fromWord(it.word(3)), false);
      break;
    case rdcspv::Op::TypeFunction:
      callback(Id::fromWord(it.word(1)), true);
      callback(Id::fromWord(it.word(2)), false);
      for(size_t i=0; i < size-3; i++) callback(Id::fromWord(it.word(3+i)), false);
      break;
    case rdcspv::Op::TypeEvent:
      callback(Id::fromWord(it.word(1)), true);
      break;
    case rdcspv::Op::TypeDeviceEvent:
      callback(Id::fromWord(it.word(1)), true);
      break;
    case rdcspv::Op::TypeReserveId:
      callback(Id::fromWord(it.word(1)), true);
      break;
    case rdcspv::Op::TypeQueue:
      callback(Id::fromWord(it.word(1)), true);
      break;
    case rdcspv::Op::TypePipe:
      callback(Id::fromWord(it.word(1)), true);
      break;
    case rdcspv::Op::TypeForwardPointer:
      callback(Id::fromWord(it.word(1)), false);
      break;
    case rdcspv::Op::ConstantTrue:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      break;
    case rdcspv::Op::ConstantFalse:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      break;
    case rdcspv::Op::Constant:
      break;
    case rdcspv::Op::ConstantComposite:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      for(size_t i=0; i < size-3; i++) callback(Id::fromWord(it.word(3+i)), false);
      break;
    case rdcspv::Op::ConstantSampler:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      break;
    case rdcspv::Op::ConstantNull:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      break;
    case rdcspv::Op::SpecConstantTrue:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      break;
    case rdcspv::Op::SpecConstantFalse:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      break;
    case rdcspv::Op::SpecConstant:
      break;
    case rdcspv::Op::SpecConstantComposite:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      for(size_t i=0; i < size-3; i++) callback(Id::fromWord(it.word(3+i)), false);
      break;
    case rdcspv::Op::SpecConstantOp:
      break;
    case rdcspv::Op::Function:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(4)), false);
      break;
    case rdcspv::Op::FunctionParameter:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      break;
    case rdcspv::Op::FunctionEnd:
      break;
    case rdcspv::Op::FunctionCall:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      for(size_t i=0; i < size-4; i++) callback(Id::fromWord(it.word(4+i)), false);
      break;
    case rdcspv::Op::Variable:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(4)), false);
      break;
    case rdcspv::Op::ImageTexelPointer:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      callback(Id::fromWord(it.word(5)), false);
      break;
    case rdcspv::Op::Load:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      break;
    case rdcspv::Op::Store:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), false);
      break;
    case rdcspv::Op::CopyMemory:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), false);
      break;
    case rdcspv::Op::CopyMemorySized:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), false);
      callback(Id::fromWord(it.word(3)), false);
      break;
    case rdcspv::Op::AccessChain:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      for(size_t i=0; i < size-4; i++) callback(Id::fromWord(it.word(4+i)), false);
      break;
    case rdcspv::Op::InBoundsAccessChain:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      for(size_t i=0; i < size-4; i++) callback(Id::fromWord(it.word(4+i)), false);
      break;
    case rdcspv::Op::PtrAccessChain:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      for(size_t i=0; i < size-5; i++) callback(Id::fromWord(it.word(5+i)), false);
      break;
    case rdcspv::Op::ArrayLength:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      break;
    case rdcspv::Op::GenericPtrMemSemantics:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      break;
    case rdcspv::Op::InBoundsPtrAccessChain:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      for(size_t i=0; i < size-5; i++) callback(Id::fromWord(it.word(5+i)), false);
      break;
    case rdcspv::Op::Decorate:
      callback(Id::fromWord(it.word(1)), false);
      break;
    case rdcspv::Op::MemberDecorate:
      callback(Id::fromWord(it.word(1)), false);
      break;
    case rdcspv::Op::DecorationGroup:
      callback(Id::fromWord(it.word(1)), true);
      break;
    case rdcspv::Op::GroupDecorate:
      callback(Id::fromWord(it.word(1)), false);
      for(size_t i=0; i < size-2; i++) callback(Id::fromWord(it.word(2+i)), false);
      break;
    case rdcspv::Op::GroupMemberDecorate:
      callback(Id::fromWord(it.word(1)), false);
      break;
    case rdcspv::Op::VectorExtractDynamic:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      break;
    case rdcspv::Op::VectorInsertDynamic:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      callback(Id::fromWord(it.word(5)), false);
      break;
    case rdcspv::Op::VectorShuffle:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      break;
    case rdcspv::Op::CompositeConstruct:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      for(size_t i=0; i < size-3; i++) callback(Id::fromWord(it.word(3+i)), false);
      break;
    case rdcspv::Op::CompositeExtract:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      break;
    case rdcspv::Op::CompositeInsert:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      break;
    case rdcspv::Op::CopyObject:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      break;
    case rdcspv::Op::Transpose:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      break;
    case rdcspv::Op::SampledImage:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      break;
    case rdcspv::Op::ImageSampleImplicitLod:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      break;
    case rdcspv::Op::ImageSampleExplicitLod:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      break;
    case rdcspv::Op::ImageSampleDrefImplicitLod:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      callback(Id::fromWord(it.word(5)), false);
      break;
    case rdcspv::Op::ImageSampleDrefExplicitLod:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      callback(Id::fromWord(it.word(5)), false);
      break;
    case rdcspv::Op::ImageSampleProjImplicitLod:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      break;
    case rdcspv::Op::ImageSampleProjExplicitLod:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      break;
    case rdcspv::Op::ImageSampleProjDrefImplicitLod:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      callback(Id::fromWord(it.word(5)), false);
      break;
    case rdcspv::Op::ImageSampleProjDrefExplicitLod:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      callback(Id::fromWord(it.word(5)), false);
      break;
    case rdcspv::Op::ImageFetch:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      break;
    case rdcspv::Op::ImageGather:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      callback(Id::fromWord(it.word(5)), false);
      break;
    case rdcspv::Op::ImageDrefGather:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      callback(Id::fromWord(it.word(5)), false);
      break;
    case rdcspv::Op::ImageRead:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      break;
    case rdcspv::Op::ImageWrite:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), false);
      callback(Id::fromWord(it.word(3)), false);
      break;
    case rdcspv::Op::Image:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      break;
    case rdcspv::Op::ImageQueryFormat:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      break;
    case rdcspv::Op::ImageQueryOrder:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      break;
    case rdcspv::Op::ImageQuerySizeLod:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      break;
    case rdcspv::Op::ImageQuerySize:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      break;
    case rdcspv::Op::ImageQueryLod:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      break;
    case rdcspv::Op::ImageQueryLevels:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      break;
    case rdcspv::Op::ImageQuerySamples:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      break;
    case rdcspv::Op::ConvertFToU:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      break;
    case rdcspv::Op::ConvertFToS:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      break;
    case rdcspv::Op::ConvertSToF:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      break;
    case rdcspv::Op::ConvertUToF:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      break;
    case rdcspv::Op::UConvert:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      break;
    case rdcspv::Op::SConvert:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      break;
    case rdcspv::Op::FConvert:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      break;
    case rdcspv::Op::QuantizeToF16:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      break;
    case rdcspv::Op::ConvertPtrToU:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      break;
    case rdcspv::Op::SatConvertSToU:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      break;
    case rdcspv::Op::SatConvertUToS:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      break;
    case rdcspv::Op::ConvertUToPtr:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      break;
    case rdcspv::Op::PtrCastToGeneric:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      break;
    case rdcspv::Op::GenericCastToPtr:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      break;
    case rdcspv::Op::GenericCastToPtrExplicit:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      break;
    case rdcspv::Op::Bitcast:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      break;
    case rdcspv::Op::SNegate:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      break;
    case rdcspv::Op::FNegate:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      break;
    case rdcspv::Op::IAdd:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      break;
    case rdcspv::Op::FAdd:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      break;
    case rdcspv::Op::ISub:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      break;
    case rdcspv::Op::FSub:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      break;
    case rdcspv::Op::IMul:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      break;
    case rdcspv::Op::FMul:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      break;
    case rdcspv::Op::UDiv:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      break;
    case rdcspv::Op::SDiv:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      break;
    case rdcspv::Op::FDiv:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      break;
    case rdcspv::Op::UMod:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      break;
    case rdcspv::Op::SRem:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      break;
    case rdcspv::Op::SMod:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      break;
    case rdcspv::Op::FRem:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      break;
    case rdcspv::Op::FMod:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      break;
    case rdcspv::Op::VectorTimesScalar:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      break;
    case rdcspv::Op::MatrixTimesScalar:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      break;
    case rdcspv::Op::VectorTimesMatrix:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      break;
    case rdcspv::Op::MatrixTimesVector:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      break;
    case rdcspv::Op::MatrixTimesMatrix:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      break;
    case rdcspv::Op::OuterProduct:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      break;
    case rdcspv::Op::Dot:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      break;
    case rdcspv::Op::IAddCarry:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      break;
    case rdcspv::Op::ISubBorrow:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      break;
    case rdcspv::Op::UMulExtended:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      break;
    case rdcspv::Op::SMulExtended:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      break;
    case rdcspv::Op::Any:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      break;
    case rdcspv::Op::All:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      break;
    case rdcspv::Op::IsNan:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      break;
    case rdcspv::Op::IsInf:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      break;
    case rdcspv::Op::IsFinite:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      break;
    case rdcspv::Op::IsNormal:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      break;
    case rdcspv::Op::SignBitSet:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      break;
    case rdcspv::Op::LessOrGreater:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      break;
    case rdcspv::Op::Ordered:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      break;
    case rdcspv::Op::Unordered:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      break;
    case rdcspv::Op::LogicalEqual:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      break;
    case rdcspv::Op::LogicalNotEqual:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      break;
    case rdcspv::Op::LogicalOr:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      break;
    case rdcspv::Op::LogicalAnd:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      break;
    case rdcspv::Op::LogicalNot:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      break;
    case rdcspv::Op::Select:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      callback(Id::fromWord(it.word(5)), false);
      break;
    case rdcspv::Op::IEqual:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      break;
    case rdcspv::Op::INotEqual:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      break;
    case rdcspv::Op::UGreaterThan:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      break;
    case rdcspv::Op::SGreaterThan:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      break;
    case rdcspv::Op::UGreaterThanEqual:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      break;
    case rdcspv::Op::SGreaterThanEqual:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      break;
    case rdcspv::Op::ULessThan:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      break;
    case rdcspv::Op::SLessThan:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      break;
    case rdcspv::Op::ULessThanEqual:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      break;
    case rdcspv::Op::SLessThanEqual:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      break;
    case rdcspv::Op::FOrdEqual:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      break;
    case rdcspv::Op::FUnordEqual:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      break;
    case rdcspv::Op::FOrdNotEqual:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      break;
    case rdcspv::Op::FUnordNotEqual:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      break;
    case rdcspv::Op::FOrdLessThan:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      break;
    case rdcspv::Op::FUnordLessThan:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      break;
    case rdcspv::Op::FOrdGreaterThan:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      break;
    case rdcspv::Op::FUnordGreaterThan:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      break;
    case rdcspv::Op::FOrdLessThanEqual:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      break;
    case rdcspv::Op::FUnordLessThanEqual:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      break;
    case rdcspv::Op::FOrdGreaterThanEqual:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      break;
    case rdcspv::Op::FUnordGreaterThanEqual:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      break;
    case rdcspv::Op::ShiftRightLogical:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      break;
    case rdcspv::Op::ShiftRightArithmetic:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      break;
    case rdcspv::Op::ShiftLeftLogical:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      break;
    case rdcspv::Op::BitwiseOr:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      break;
    case rdcspv::Op::BitwiseXor:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      break;
    case rdcspv::Op::BitwiseAnd:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      break;
    case rdcspv::Op::Not:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      break;
    case rdcspv::Op::BitFieldInsert:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      callback(Id::fromWord(it.word(5)), false);
      callback(Id::fromWord(it.word(6)), false);
      break;
    case rdcspv::Op::BitFieldSExtract:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      callback(Id::fromWord(it.word(5)), false);
      break;
    case rdcspv::Op::BitFieldUExtract:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      callback(Id::fromWord(it.word(5)), false);
      break;
    case rdcspv::Op::BitReverse:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      break;
    case rdcspv::Op::BitCount:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      break;
    case rdcspv::Op::DPdx:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      break;
    case rdcspv::Op::DPdy:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      break;
    case rdcspv::Op::Fwidth:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      break;
    case rdcspv::Op::DPdxFine:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      break;
    case rdcspv::Op::DPdyFine:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      break;
    case rdcspv::Op::FwidthFine:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      break;
    case rdcspv::Op::DPdxCoarse:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      break;
    case rdcspv::Op::DPdyCoarse:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      break;
    case rdcspv::Op::FwidthCoarse:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      break;
    case rdcspv::Op::EmitVertex:
      break;
    case rdcspv::Op::EndPrimitive:
      break;
    case rdcspv::Op::EmitStreamVertex:
      callback(Id::fromWord(it.word(1)), false);
      break;
    case rdcspv::Op::EndStreamPrimitive:
      callback(Id::fromWord(it.word(1)), false);
      break;
    case rdcspv::Op::ControlBarrier:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), false);
      callback(Id::fromWord(it.word(3)), false);
      break;
    case rdcspv::Op::MemoryBarrier:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), false);
      break;
    case rdcspv::Op::AtomicLoad:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      callback(Id::fromWord(it.word(5)), false);
      break;
    case rdcspv::Op::AtomicStore:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), false);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      break;
    case rdcspv::Op::AtomicExchange:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      callback(Id::fromWord(it.word(5)), false);
      callback(Id::fromWord(it.word(6)), false);
      break;
    case rdcspv::Op::AtomicCompareExchange:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      callback(Id::fromWord(it.word(5)), false);
      callback(Id::fromWord(it.word(6)), false);
      callback(Id::fromWord(it.word(7)), false);
      callback(Id::fromWord(it.word(8)), false);
      break;
    case rdcspv::Op::AtomicCompareExchangeWeak:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      callback(Id::fromWord(it.word(5)), false);
      callback(Id::fromWord(it.word(6)), false);
      callback(Id::fromWord(it.word(7)), false);
      callback(Id::fromWord(it.word(8)), false);
      break;
    case rdcspv::Op::AtomicIIncrement:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      callback(Id::fromWord(it.word(5)), false);
      break;
    case rdcspv::Op::AtomicIDecrement:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      callback(Id::fromWord(it.word(5)), false);
      break;
    case rdcspv::Op::AtomicIAdd:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      callback(Id::fromWord(it.word(5)), false);
      callback(Id::fromWord(it.word(6)), false);
      break;
    case rdcspv::Op::AtomicISub:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      callback(Id::fromWord(it.word(5)), false);
      callback(Id::fromWord(it.word(6)), false);
      break;
    case rdcspv::Op::AtomicSMin:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      callback(Id::fromWord(it.word(5)), false);
      callback(Id::fromWord(it.word(6)), false);
      break;
    case rdcspv::Op::AtomicUMin:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      callback(Id::fromWord(it.word(5)), false);
      callback(Id::fromWord(it.word(6)), false);
      break;
    case rdcspv::Op::AtomicSMax:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      callback(Id::fromWord(it.word(5)), false);
      callback(Id::fromWord(it.word(6)), false);
      break;
    case rdcspv::Op::AtomicUMax:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      callback(Id::fromWord(it.word(5)), false);
      callback(Id::fromWord(it.word(6)), false);
      break;
    case rdcspv::Op::AtomicAnd:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      callback(Id::fromWord(it.word(5)), false);
      callback(Id::fromWord(it.word(6)), false);
      break;
    case rdcspv::Op::AtomicOr:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      callback(Id::fromWord(it.word(5)), false);
      callback(Id::fromWord(it.word(6)), false);
      break;
    case rdcspv::Op::AtomicXor:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      callback(Id::fromWord(it.word(5)), false);
      callback(Id::fromWord(it.word(6)), false);
      break;
    case rdcspv::Op::Phi:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      break;
    case rdcspv::Op::LoopMerge:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), false);
      break;
    case rdcspv::Op::SelectionMerge:
      callback(Id::fromWord(it.word(1)), false);
      break;
    case rdcspv::Op::Label:
      callback(Id::fromWord(it.word(1)), true);
      break;
    case rdcspv::Op::Branch:
      callback(Id::fromWord(it.word(1)), false);
      break;
    case rdcspv::Op::BranchConditional:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), false);
      callback(Id::fromWord(it.word(3)), false);
      break;
    case rdcspv::Op::Switch:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), false);
      break;
    case rdcspv::Op::Kill:
      break;
    case rdcspv::Op::Return:
      break;
    case rdcspv::Op::ReturnValue:
      callback(Id::fromWord(it.word(1)), false);
      break;
    case rdcspv::Op::Unreachable:
      break;
    case rdcspv::Op::LifetimeStart:
      callback(Id::fromWord(it.word(1)), false);
      break;
    case rdcspv::Op::LifetimeStop:
      callback(Id::fromWord(it.word(1)), false);
      break;
    case rdcspv::Op::GroupAsyncCopy:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      callback(Id::fromWord(it.word(5)), false);
      callback(Id::fromWord(it.word(6)), false);
      callback(Id::fromWord(it.word(7)), false);
      callback(Id::fromWord(it.word(8)), false);
      break;
    case rdcspv::Op::GroupWaitEvents:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), false);
      callback(Id::fromWord(it.word(3)), false);
      break;
    case rdcspv::Op::GroupAll:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      break;
    case rdcspv::Op::GroupAny:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      break;
    case rdcspv::Op::GroupBroadcast:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      callback(Id::fromWord(it.word(5)), false);
      break;
    case rdcspv::Op::GroupIAdd:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(5)), false);
      break;
    case rdcspv::Op::GroupFAdd:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(5)), false);
      break;
    case rdcspv::Op::GroupFMin:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(5)), false);
      break;
    case rdcspv::Op::GroupUMin:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(5)), false);
      break;
    case rdcspv::Op::GroupSMin:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(5)), false);
      break;
    case rdcspv::Op::GroupFMax:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(5)), false);
      break;
    case rdcspv::Op::GroupUMax:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(5)), false);
      break;
    case rdcspv::Op::GroupSMax:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(5)), false);
      break;
    case rdcspv::Op::ReadPipe:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      callback(Id::fromWord(it.word(5)), false);
      callback(Id::fromWord(it.word(6)), false);
      break;
    case rdcspv::Op::WritePipe:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      callback(Id::fromWord(it.word(5)), false);
      callback(Id::fromWord(it.word(6)), false);
      break;
    case rdcspv::Op::ReservedReadPipe:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      callback(Id::fromWord(it.word(5)), false);
      callback(Id::fromWord(it.word(6)), false);
      callback(Id::fromWord(it.word(7)), false);
      callback(Id::fromWord(it.word(8)), false);
      break;
    case rdcspv::Op::ReservedWritePipe:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      callback(Id::fromWord(it.word(5)), false);
      callback(Id::fromWord(it.word(6)), false);
      callback(Id::fromWord(it.word(7)), false);
      callback(Id::fromWord(it.word(8)), false);
      break;
    case rdcspv::Op::ReserveReadPipePackets:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      callback(Id::fromWord(it.word(5)), false);
      callback(Id::fromWord(it.word(6)), false);
      break;
    case rdcspv::Op::ReserveWritePipePackets:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      callback(Id::fromWord(it.word(5)), false);
      callback(Id::fromWord(it.word(6)), false);
      break;
    case rdcspv::Op::CommitReadPipe:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), false);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      break;
    case rdcspv::Op::CommitWritePipe:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), false);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      break;
    case rdcspv::Op::IsValidReserveId:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      break;
    case rdcspv::Op::GetNumPipePackets:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      callback(Id::fromWord(it.word(5)), false);
      break;
    case rdcspv::Op::GetMaxPipePackets:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      callback(Id::fromWord(it.word(5)), false);
      break;
    case rdcspv::Op::GroupReserveReadPipePackets:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      callback(Id::fromWord(it.word(5)), false);
      callback(Id::fromWord(it.word(6)), false);
      callback(Id::fromWord(it.word(7)), false);
      break;
    case rdcspv::Op::GroupReserveWritePipePackets:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      callback(Id::fromWord(it.word(5)), false);
      callback(Id::fromWord(it.word(6)), false);
      callback(Id::fromWord(it.word(7)), false);
      break;
    case rdcspv::Op::GroupCommitReadPipe:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), false);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      callback(Id::fromWord(it.word(5)), false);
      break;
    case rdcspv::Op::GroupCommitWritePipe:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), false);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      callback(Id::fromWord(it.word(5)), false);
      break;
    case rdcspv::Op::EnqueueMarker:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      callback(Id::fromWord(it.word(5)), false);
      callback(Id::fromWord(it.word(6)), false);
      break;
    case rdcspv::Op::EnqueueKernel:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      callback(Id::fromWord(it.word(5)), false);
      callback(Id::fromWord(it.word(6)), false);
      callback(Id::fromWord(it.word(7)), false);
      callback(Id::fromWord(it.word(8)), false);
      callback(Id::fromWord(it.word(9)), false);
      callback(Id::fromWord(it.word(10)), false);
      callback(Id::fromWord(it.word(11)), false);
      callback(Id::fromWord(it.word(12)), false);
      for(size_t i=0; i < size-13; i++) callback(Id::fromWord(it.word(13+i)), false);
      break;
    case rdcspv::Op::GetKernelNDrangeSubGroupCount:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      callback(Id::fromWord(it.word(5)), false);
      callback(Id::fromWord(it.word(6)), false);
      callback(Id::fromWord(it.word(7)), false);
      break;
    case rdcspv::Op::GetKernelNDrangeMaxSubGroupSize:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      callback(Id::fromWord(it.word(5)), false);
      callback(Id::fromWord(it.word(6)), false);
      callback(Id::fromWord(it.word(7)), false);
      break;
    case rdcspv::Op::GetKernelWorkGroupSize:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      callback(Id::fromWord(it.word(5)), false);
      callback(Id::fromWord(it.word(6)), false);
      break;
    case rdcspv::Op::GetKernelPreferredWorkGroupSizeMultiple:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      callback(Id::fromWord(it.word(5)), false);
      callback(Id::fromWord(it.word(6)), false);
      break;
    case rdcspv::Op::RetainEvent:
      callback(Id::fromWord(it.word(1)), false);
      break;
    case rdcspv::Op::ReleaseEvent:
      callback(Id::fromWord(it.word(1)), false);
      break;
    case rdcspv::Op::CreateUserEvent:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      break;
    case rdcspv::Op::IsValidEvent:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      break;
    case rdcspv::Op::SetUserEventStatus:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), false);
      break;
    case rdcspv::Op::CaptureEventProfilingInfo:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), false);
      callback(Id::fromWord(it.word(3)), false);
      break;
    case rdcspv::Op::GetDefaultQueue:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      break;
    case rdcspv::Op::BuildNDRange:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      callback(Id::fromWord(it.word(5)), false);
      break;
    case rdcspv::Op::ImageSparseSampleImplicitLod:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      break;
    case rdcspv::Op::ImageSparseSampleExplicitLod:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      break;
    case rdcspv::Op::ImageSparseSampleDrefImplicitLod:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      callback(Id::fromWord(it.word(5)), false);
      break;
    case rdcspv::Op::ImageSparseSampleDrefExplicitLod:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      callback(Id::fromWord(it.word(5)), false);
      break;
    case rdcspv::Op::ImageSparseSampleProjImplicitLod:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      break;
    case rdcspv::Op::ImageSparseSampleProjExplicitLod:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      break;
    case rdcspv::Op::ImageSparseSampleProjDrefImplicitLod:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      callback(Id::fromWord(it.word(5)), false);
      break;
    case rdcspv::Op::ImageSparseSampleProjDrefExplicitLod:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      callback(Id::fromWord(it.word(5)), false);
      break;
    case rdcspv::Op::ImageSparseFetch:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      break;
    case rdcspv::Op::ImageSparseGather:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      callback(Id::fromWord(it.word(5)), false);
      break;
    case rdcspv::Op::ImageSparseDrefGather:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      callback(Id::fromWord(it.word(5)), false);
      break;
    case rdcspv::Op::ImageSparseTexelsResident:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      break;
    case rdcspv::Op::NoLine:
      break;
    case rdcspv::Op::AtomicFlagTestAndSet:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      callback(Id::fromWord(it.word(5)), false);
      break;
    case rdcspv::Op::AtomicFlagClear:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), false);
      callback(Id::fromWord(it.word(3)), false);
      break;
    case rdcspv::Op::ImageSparseRead:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      break;
    case rdcspv::Op::SizeOf:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      break;
    case rdcspv::Op::TypePipeStorage:
      callback(Id::fromWord(it.word(1)), true);
      break;
    case rdcspv::Op::ConstantPipeStorage:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      break;
    case rdcspv::Op::CreatePipeFromPipeStorage:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      break;
    case rdcspv::Op::GetKernelLocalSizeForSubgroupCount:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      callback(Id::fromWord(it.word(5)), false);
      callback(Id::fromWord(it.word(6)), false);
      callback(Id::fromWord(it.word(7)), false);
      break;
    case rdcspv::Op::GetKernelMaxNumSubgroups:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      callback(Id::fromWord(it.word(5)), false);
      callback(Id::fromWord(it.word(6)), false);
      break;
    case rdcspv::Op::TypeNamedBarrier:
      callback(Id::fromWord(it.word(1)), true);
      break;
    case rdcspv::Op::NamedBarrierInitialize:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      break;
    case rdcspv::Op::MemoryNamedBarrier:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), false);
      callback(Id::fromWord(it.word(3)), false);
      break;
    case rdcspv::Op::ModuleProcessed:
      break;
    case rdcspv::Op::ExecutionModeId:
      callback(Id::fromWord(it.word(1)), false);
      break;
    case rdcspv::Op::DecorateId:
      callback(Id::fromWord(it.word(1)), false);
      break;
    case rdcspv::Op::GroupNonUniformElect:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      break;
    case rdcspv::Op::GroupNonUniformAll:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      break;
    case rdcspv::Op::GroupNonUniformAny:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      break;
    case rdcspv::Op::GroupNonUniformAllEqual:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      break;
    case rdcspv::Op::GroupNonUniformBroadcast:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      callback(Id::fromWord(it.word(5)), false);
      break;
    case rdcspv::Op::GroupNonUniformBroadcastFirst:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      break;
    case rdcspv::Op::GroupNonUniformBallot:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      break;
    case rdcspv::Op::GroupNonUniformInverseBallot:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      break;
    case rdcspv::Op::GroupNonUniformBallotBitExtract:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      callback(Id::fromWord(it.word(5)), false);
      break;
    case rdcspv::Op::GroupNonUniformBallotBitCount:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(5)), false);
      break;
    case rdcspv::Op::GroupNonUniformBallotFindLSB:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      break;
    case rdcspv::Op::GroupNonUniformBallotFindMSB:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      break;
    case rdcspv::Op::GroupNonUniformShuffle:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      callback(Id::fromWord(it.word(5)), false);
      break;
    case rdcspv::Op::GroupNonUniformShuffleXor:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      callback(Id::fromWord(it.word(5)), false);
      break;
    case rdcspv::Op::GroupNonUniformShuffleUp:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      callback(Id::fromWord(it.word(5)), false);
      break;
    case rdcspv::Op::GroupNonUniformShuffleDown:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      callback(Id::fromWord(it.word(5)), false);
      break;
    case rdcspv::Op::GroupNonUniformIAdd:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(5)), false);
      callback(Id::fromWord(it.word(6)), false);
      break;
    case rdcspv::Op::GroupNonUniformFAdd:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(5)), false);
      callback(Id::fromWord(it.word(6)), false);
      break;
    case rdcspv::Op::GroupNonUniformIMul:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(5)), false);
      callback(Id::fromWord(it.word(6)), false);
      break;
    case rdcspv::Op::GroupNonUniformFMul:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(5)), false);
      callback(Id::fromWord(it.word(6)), false);
      break;
    case rdcspv::Op::GroupNonUniformSMin:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(5)), false);
      callback(Id::fromWord(it.word(6)), false);
      break;
    case rdcspv::Op::GroupNonUniformUMin:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(5)), false);
      callback(Id::fromWord(it.word(6)), false);
      break;
    case rdcspv::Op::GroupNonUniformFMin:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(5)), false);
      callback(Id::fromWord(it.word(6)), false);
      break;
    case rdcspv::Op::GroupNonUniformSMax:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(5)), false);
      callback(Id::fromWord(it.word(6)), false);
      break;
    case rdcspv::Op::GroupNonUniformUMax:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(5)), false);
      callback(Id::fromWord(it.word(6)), false);
      break;
    case rdcspv::Op::GroupNonUniformFMax:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(5)), false);
      callback(Id::fromWord(it.word(6)), false);
      break;
    case rdcspv::Op::GroupNonUniformBitwiseAnd:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(5)), false);
      callback(Id::fromWord(it.word(6)), false);
      break;
    case rdcspv::Op::GroupNonUniformBitwiseOr:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(5)), false);
      callback(Id::fromWord(it.word(6)), false);
      break;
    case rdcspv::Op::GroupNonUniformBitwiseXor:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(5)), false);
      callback(Id::fromWord(it.word(6)), false);
      break;
    case rdcspv::Op::GroupNonUniformLogicalAnd:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(5)), false);
      callback(Id::fromWord(it.word(6)), false);
      break;
    case rdcspv::Op::GroupNonUniformLogicalOr:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(5)), false);
      callback(Id::fromWord(it.word(6)), false);
      break;
    case rdcspv::Op::GroupNonUniformLogicalXor:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(5)), false);
      callback(Id::fromWord(it.word(6)), false);
      break;
    case rdcspv::Op::GroupNonUniformQuadBroadcast:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      callback(Id::fromWord(it.word(5)), false);
      break;
    case rdcspv::Op::GroupNonUniformQuadSwap:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      callback(Id::fromWord(it.word(5)), false);
      break;
    case rdcspv::Op::CopyLogical:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      break;
    case rdcspv::Op::PtrEqual:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      break;
    case rdcspv::Op::PtrNotEqual:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      break;
    case rdcspv::Op::PtrDiff:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      break;
    case rdcspv::Op::TerminateInvocation:
      break;
    case rdcspv::Op::SubgroupBallotKHR:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      break;
    case rdcspv::Op::SubgroupFirstInvocationKHR:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      break;
    case rdcspv::Op::SubgroupAllKHR:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      break;
    case rdcspv::Op::SubgroupAnyKHR:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      break;
    case rdcspv::Op::SubgroupAllEqualKHR:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      break;
    case rdcspv::Op::SubgroupReadInvocationKHR:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      break;
    case rdcspv::Op::TraceRayKHR:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), false);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      callback(Id::fromWord(it.word(5)), false);
      callback(Id::fromWord(it.word(6)), false);
      callback(Id::fromWord(it.word(7)), false);
      callback(Id::fromWord(it.word(8)), false);
      callback(Id::fromWord(it.word(9)), false);
      callback(Id::fromWord(it.word(10)), false);
      callback(Id::fromWord(it.word(11)), false);
      break;
    case rdcspv::Op::ExecuteCallableKHR:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), false);
      break;
    case rdcspv::Op::ConvertUToAccelerationStructureKHR:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      break;
    case rdcspv::Op::IgnoreIntersectionKHR:
      break;
    case rdcspv::Op::TerminateRayKHR:
      break;
    case rdcspv::Op::TypeRayQueryKHR:
      callback(Id::fromWord(it.word(1)), true);
      break;
    case rdcspv::Op::RayQueryInitializeKHR:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), false);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      callback(Id::fromWord(it.word(5)), false);
      callback(Id::fromWord(it.word(6)), false);
      callback(Id::fromWord(it.word(7)), false);
      callback(Id::fromWord(it.word(8)), false);
      break;
    case rdcspv::Op::RayQueryTerminateKHR:
      callback(Id::fromWord(it.word(1)), false);
      break;
    case rdcspv::Op::RayQueryGenerateIntersectionKHR:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), false);
      break;
    case rdcspv::Op::RayQueryConfirmIntersectionKHR:
      callback(Id::fromWord(it.word(1)), false);
      break;
    case rdcspv::Op::RayQueryProceedKHR:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      break;
    case rdcspv::Op::RayQueryGetIntersectionTypeKHR:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      break;
    case rdcspv::Op::GroupIAddNonUniformAMD:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(5)), false);
      break;
    case rdcspv::Op::GroupFAddNonUniformAMD:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(5)), false);
      break;
    case rdcspv::Op::GroupFMinNonUniformAMD:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(5)), false);
      break;
    case rdcspv::Op::GroupUMinNonUniformAMD:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(5)), false);
      break;
    case rdcspv::Op::GroupSMinNonUniformAMD:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(5)), false);
      break;
    case rdcspv::Op::GroupFMaxNonUniformAMD:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(5)), false);
      break;
    case rdcspv::Op::GroupUMaxNonUniformAMD:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(5)), false);
      break;
    case rdcspv::Op::GroupSMaxNonUniformAMD:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(5)), false);
      break;
    case rdcspv::Op::FragmentMaskFetchAMD:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      break;
    case rdcspv::Op::FragmentFetchAMD:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      callback(Id::fromWord(it.word(5)), false);
      break;
    case rdcspv::Op::ReadClockKHR:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      break;
    case rdcspv::Op::ImageSampleFootprintNV:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      callback(Id::fromWord(it.word(5)), false);
      callback(Id::fromWord(it.word(6)), false);
      break;
    case rdcspv::Op::GroupNonUniformPartitionNV:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      break;
    case rdcspv::Op::WritePackedPrimitiveIndices4x8NV:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), false);
      break;
    case rdcspv::Op::ReportIntersectionNV:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      break;
    case rdcspv::Op::IgnoreIntersectionNV:
      break;
    case rdcspv::Op::TerminateRayNV:
      break;
    case rdcspv::Op::TraceNV:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), false);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      callback(Id::fromWord(it.word(5)), false);
      callback(Id::fromWord(it.word(6)), false);
      callback(Id::fromWord(it.word(7)), false);
      callback(Id::fromWord(it.word(8)), false);
      callback(Id::fromWord(it.word(9)), false);
      callback(Id::fromWord(it.word(10)), false);
      callback(Id::fromWord(it.word(11)), false);
      break;
    case rdcspv::Op::TypeAccelerationStructureNV:
      callback(Id::fromWord(it.word(1)), true);
      break;
    case rdcspv::Op::ExecuteCallableNV:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), false);
      break;
    case rdcspv::Op::TypeCooperativeMatrixNV:
      callback(Id::fromWord(it.word(1)), true);
      callback(Id::fromWord(it.word(2)), false);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      callback(Id::fromWord(it.word(5)), false);
      break;
    case rdcspv::Op::CooperativeMatrixLoadNV:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      callback(Id::fromWord(it.word(5)), false);
      break;
    case rdcspv::Op::CooperativeMatrixStoreNV:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), false);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      break;
    case rdcspv::Op::CooperativeMatrixMulAddNV:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      callback(Id::fromWord(it.word(5)), false);
      break;
    case rdcspv::Op::CooperativeMatrixLengthNV:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      break;
    case rdcspv::Op::BeginInvocationInterlockEXT:
      break;
    case rdcspv::Op::EndInvocationInterlockEXT:
      break;
    case rdcspv::Op::DemoteToHelperInvocationEXT:
      break;
    case rdcspv::Op::IsHelperInvocationEXT:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      break;
    case rdcspv::Op::SubgroupShuffleINTEL:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      break;
    case rdcspv::Op::SubgroupShuffleDownINTEL:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      callback(Id::fromWord(it.word(5)), false);
      break;
    case rdcspv::Op::SubgroupShuffleUpINTEL:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      callback(Id::fromWord(it.word(5)), false);
      break;
    case rdcspv::Op::SubgroupShuffleXorINTEL:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      break;
    case rdcspv::Op::SubgroupBlockReadINTEL:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      break;
    case rdcspv::Op::SubgroupBlockWriteINTEL:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), false);
      break;
    case rdcspv::Op::SubgroupImageBlockReadINTEL:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      break;
    case rdcspv::Op::SubgroupImageBlockWriteINTEL:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), false);
      callback(Id::fromWord(it.word(3)), false);
      break;
    case rdcspv::Op::SubgroupImageMediaBlockReadINTEL:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      callback(Id::fromWord(it.word(5)), false);
      callback(Id::fromWord(it.word(6)), false);
      break;
    case rdcspv::Op::SubgroupImageMediaBlockWriteINTEL:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), false);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      callback(Id::fromWord(it.word(5)), false);
      break;
    case rdcspv::Op::UCountLeadingZerosINTEL:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      break;
    case rdcspv::Op::UCountTrailingZerosINTEL:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      break;
    case rdcspv::Op::AbsISubINTEL:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      break;
    case rdcspv::Op::AbsUSubINTEL:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      break;
    case rdcspv::Op::IAddSatINTEL:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      break;
    case rdcspv::Op::UAddSatINTEL:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      break;
    case rdcspv::Op::IAverageINTEL:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      break;
    case rdcspv::Op::UAverageINTEL:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      break;
    case rdcspv::Op::IAverageRoundedINTEL:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      break;
    case rdcspv::Op::UAverageRoundedINTEL:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      break;
    case rdcspv::Op::ISubSatINTEL:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      break;
    case rdcspv::Op::USubSatINTEL:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      break;
    case rdcspv::Op::IMul32x16INTEL:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      break;
    case rdcspv::Op::UMul32x16INTEL:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      break;
    case rdcspv::Op::FunctionPointerINTEL:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      break;
    case rdcspv::Op::FunctionPointerCallINTEL:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      for(size_t i=0; i < size-3; i++) callback(Id::fromWord(it.word(3+i)), false);
      break;
    case rdcspv::Op::DecorateString:
      callback(Id::fromWord(it.word(1)), false);
      break;
    case rdcspv::Op::MemberDecorateString:
      callback(Id::fromWord(it.word(1)), false);
      break;
    case rdcspv::Op::VmeImageINTEL:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      break;
    case rdcspv::Op::TypeVmeImageINTEL:
      callback(Id::fromWord(it.word(1)), true);
      callback(Id::fromWord(it.word(2)), false);
      break;
    case rdcspv::Op::TypeAvcImePayloadINTEL:
      callback(Id::fromWord(it.word(1)), true);
      break;
    case rdcspv::Op::TypeAvcRefPayloadINTEL:
      callback(Id::fromWord(it.word(1)), true);
      break;
    case rdcspv::Op::TypeAvcSicPayloadINTEL:
      callback(Id::fromWord(it.word(1)), true);
      break;
    case rdcspv::Op::TypeAvcMcePayloadINTEL:
      callback(Id::fromWord(it.word(1)), true);
      break;
    case rdcspv::Op::TypeAvcMceResultINTEL:
      callback(Id::fromWord(it.word(1)), true);
      break;
    case rdcspv::Op::TypeAvcImeResultINTEL:
      callback(Id::fromWord(it.word(1)), true);
      break;
    case rdcspv::Op::TypeAvcImeResultSingleReferenceStreamoutINTEL:
      callback(Id::fromWord(it.word(1)), true);
      break;
    case rdcspv::Op::TypeAvcImeResultDualReferenceStreamoutINTEL:
      callback(Id::fromWord(it.word(1)), true);
      break;
    case rdcspv::Op::TypeAvcImeSingleReferenceStreaminINTEL:
      callback(Id::fromWord(it.word(1)), true);
      break;
    case rdcspv::Op::TypeAvcImeDualReferenceStreaminINTEL:
      callback(Id::fromWord(it.word(1)), true);
      break;
    case rdcspv::Op::TypeAvcRefResultINTEL:
      callback(Id::fromWord(it.word(1)), true);
      break;
    case rdcspv::Op::TypeAvcSicResultINTEL:
      callback(Id::fromWord(it.word(1)), true);
      break;
    case rdcspv::Op::SubgroupAvcMceGetDefaultInterBaseMultiReferencePenaltyINTEL:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      break;
    case rdcspv::Op::SubgroupAvcMceSetInterBaseMultiReferencePenaltyINTEL:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      break;
    case rdcspv::Op::SubgroupAvcMceGetDefaultInterShapePenaltyINTEL:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      break;
    case rdcspv::Op::SubgroupAvcMceSetInterShapePenaltyINTEL:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      break;
    case rdcspv::Op::SubgroupAvcMceGetDefaultInterDirectionPenaltyINTEL:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      break;
    case rdcspv::Op::SubgroupAvcMceSetInterDirectionPenaltyINTEL:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      break;
    case rdcspv::Op::SubgroupAvcMceGetDefaultIntraLumaShapePenaltyINTEL:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      break;
    case rdcspv::Op::SubgroupAvcMceGetDefaultInterMotionVectorCostTableINTEL:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      break;
    case rdcspv::Op::SubgroupAvcMceGetDefaultHighPenaltyCostTableINTEL:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      break;
    case rdcspv::Op::SubgroupAvcMceGetDefaultMediumPenaltyCostTableINTEL:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      break;
    case rdcspv::Op::SubgroupAvcMceGetDefaultLowPenaltyCostTableINTEL:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      break;
    case rdcspv::Op::SubgroupAvcMceSetMotionVectorCostFunctionINTEL:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      callback(Id::fromWord(it.word(5)), false);
      callback(Id::fromWord(it.word(6)), false);
      break;
    case rdcspv::Op::SubgroupAvcMceGetDefaultIntraLumaModePenaltyINTEL:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      break;
    case rdcspv::Op::SubgroupAvcMceGetDefaultNonDcLumaIntraPenaltyINTEL:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      break;
    case rdcspv::Op::SubgroupAvcMceGetDefaultIntraChromaModeBasePenaltyINTEL:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      break;
    case rdcspv::Op::SubgroupAvcMceSetAcOnlyHaarINTEL:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      break;
    case rdcspv::Op::SubgroupAvcMceSetSourceInterlacedFieldPolarityINTEL:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      break;
    case rdcspv::Op::SubgroupAvcMceSetSingleReferenceInterlacedFieldPolarityINTEL:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      break;
    case rdcspv::Op::SubgroupAvcMceSetDualReferenceInterlacedFieldPolaritiesINTEL:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      callback(Id::fromWord(it.word(5)), false);
      break;
    case rdcspv::Op::SubgroupAvcMceConvertToImePayloadINTEL:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      break;
    case rdcspv::Op::SubgroupAvcMceConvertToImeResultINTEL:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      break;
    case rdcspv::Op::SubgroupAvcMceConvertToRefPayloadINTEL:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      break;
    case rdcspv::Op::SubgroupAvcMceConvertToRefResultINTEL:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      break;
    case rdcspv::Op::SubgroupAvcMceConvertToSicPayloadINTEL:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      break;
    case rdcspv::Op::SubgroupAvcMceConvertToSicResultINTEL:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      break;
    case rdcspv::Op::SubgroupAvcMceGetMotionVectorsINTEL:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      break;
    case rdcspv::Op::SubgroupAvcMceGetInterDistortionsINTEL:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      break;
    case rdcspv::Op::SubgroupAvcMceGetBestInterDistortionsINTEL:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      break;
    case rdcspv::Op::SubgroupAvcMceGetInterMajorShapeINTEL:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      break;
    case rdcspv::Op::SubgroupAvcMceGetInterMinorShapeINTEL:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      break;
    case rdcspv::Op::SubgroupAvcMceGetInterDirectionsINTEL:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      break;
    case rdcspv::Op::SubgroupAvcMceGetInterMotionVectorCountINTEL:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      break;
    case rdcspv::Op::SubgroupAvcMceGetInterReferenceIdsINTEL:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      break;
    case rdcspv::Op::SubgroupAvcMceGetInterReferenceInterlacedFieldPolaritiesINTEL:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      callback(Id::fromWord(it.word(5)), false);
      break;
    case rdcspv::Op::SubgroupAvcImeInitializeINTEL:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      callback(Id::fromWord(it.word(5)), false);
      break;
    case rdcspv::Op::SubgroupAvcImeSetSingleReferenceINTEL:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      callback(Id::fromWord(it.word(5)), false);
      break;
    case rdcspv::Op::SubgroupAvcImeSetDualReferenceINTEL:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      callback(Id::fromWord(it.word(5)), false);
      callback(Id::fromWord(it.word(6)), false);
      break;
    case rdcspv::Op::SubgroupAvcImeRefWindowSizeINTEL:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      break;
    case rdcspv::Op::SubgroupAvcImeAdjustRefOffsetINTEL:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      callback(Id::fromWord(it.word(5)), false);
      callback(Id::fromWord(it.word(6)), false);
      break;
    case rdcspv::Op::SubgroupAvcImeConvertToMcePayloadINTEL:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      break;
    case rdcspv::Op::SubgroupAvcImeSetMaxMotionVectorCountINTEL:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      break;
    case rdcspv::Op::SubgroupAvcImeSetUnidirectionalMixDisableINTEL:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      break;
    case rdcspv::Op::SubgroupAvcImeSetEarlySearchTerminationThresholdINTEL:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      break;
    case rdcspv::Op::SubgroupAvcImeSetWeightedSadINTEL:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      break;
    case rdcspv::Op::SubgroupAvcImeEvaluateWithSingleReferenceINTEL:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      callback(Id::fromWord(it.word(5)), false);
      break;
    case rdcspv::Op::SubgroupAvcImeEvaluateWithDualReferenceINTEL:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      callback(Id::fromWord(it.word(5)), false);
      callback(Id::fromWord(it.word(6)), false);
      break;
    case rdcspv::Op::SubgroupAvcImeEvaluateWithSingleReferenceStreaminINTEL:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      callback(Id::fromWord(it.word(5)), false);
      callback(Id::fromWord(it.word(6)), false);
      break;
    case rdcspv::Op::SubgroupAvcImeEvaluateWithDualReferenceStreaminINTEL:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      callback(Id::fromWord(it.word(5)), false);
      callback(Id::fromWord(it.word(6)), false);
      callback(Id::fromWord(it.word(7)), false);
      break;
    case rdcspv::Op::SubgroupAvcImeEvaluateWithSingleReferenceStreamoutINTEL:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      callback(Id::fromWord(it.word(5)), false);
      break;
    case rdcspv::Op::SubgroupAvcImeEvaluateWithDualReferenceStreamoutINTEL:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      callback(Id::fromWord(it.word(5)), false);
      callback(Id::fromWord(it.word(6)), false);
      break;
    case rdcspv::Op::SubgroupAvcImeEvaluateWithSingleReferenceStreaminoutINTEL:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      callback(Id::fromWord(it.word(5)), false);
      callback(Id::fromWord(it.word(6)), false);
      break;
    case rdcspv::Op::SubgroupAvcImeEvaluateWithDualReferenceStreaminoutINTEL:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      callback(Id::fromWord(it.word(5)), false);
      callback(Id::fromWord(it.word(6)), false);
      callback(Id::fromWord(it.word(7)), false);
      break;
    case rdcspv::Op::SubgroupAvcImeConvertToMceResultINTEL:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      break;
    case rdcspv::Op::SubgroupAvcImeGetSingleReferenceStreaminINTEL:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      break;
    case rdcspv::Op::SubgroupAvcImeGetDualReferenceStreaminINTEL:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      break;
    case rdcspv::Op::SubgroupAvcImeStripSingleReferenceStreamoutINTEL:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      break;
    case rdcspv::Op::SubgroupAvcImeStripDualReferenceStreamoutINTEL:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      break;
    case rdcspv::Op::SubgroupAvcImeGetStreamoutSingleReferenceMajorShapeMotionVectorsINTEL:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      break;
    case rdcspv::Op::SubgroupAvcImeGetStreamoutSingleReferenceMajorShapeDistortionsINTEL:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      break;
    case rdcspv::Op::SubgroupAvcImeGetStreamoutSingleReferenceMajorShapeReferenceIdsINTEL:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      break;
    case rdcspv::Op::SubgroupAvcImeGetStreamoutDualReferenceMajorShapeMotionVectorsINTEL:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      callback(Id::fromWord(it.word(5)), false);
      break;
    case rdcspv::Op::SubgroupAvcImeGetStreamoutDualReferenceMajorShapeDistortionsINTEL:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      callback(Id::fromWord(it.word(5)), false);
      break;
    case rdcspv::Op::SubgroupAvcImeGetStreamoutDualReferenceMajorShapeReferenceIdsINTEL:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      callback(Id::fromWord(it.word(5)), false);
      break;
    case rdcspv::Op::SubgroupAvcImeGetBorderReachedINTEL:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      break;
    case rdcspv::Op::SubgroupAvcImeGetTruncatedSearchIndicationINTEL:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      break;
    case rdcspv::Op::SubgroupAvcImeGetUnidirectionalEarlySearchTerminationINTEL:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      break;
    case rdcspv::Op::SubgroupAvcImeGetWeightingPatternMinimumMotionVectorINTEL:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      break;
    case rdcspv::Op::SubgroupAvcImeGetWeightingPatternMinimumDistortionINTEL:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      break;
    case rdcspv::Op::SubgroupAvcFmeInitializeINTEL:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      callback(Id::fromWord(it.word(5)), false);
      callback(Id::fromWord(it.word(6)), false);
      callback(Id::fromWord(it.word(7)), false);
      callback(Id::fromWord(it.word(8)), false);
      callback(Id::fromWord(it.word(9)), false);
      break;
    case rdcspv::Op::SubgroupAvcBmeInitializeINTEL:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      callback(Id::fromWord(it.word(5)), false);
      callback(Id::fromWord(it.word(6)), false);
      callback(Id::fromWord(it.word(7)), false);
      callback(Id::fromWord(it.word(8)), false);
      callback(Id::fromWord(it.word(9)), false);
      callback(Id::fromWord(it.word(10)), false);
      break;
    case rdcspv::Op::SubgroupAvcRefConvertToMcePayloadINTEL:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      break;
    case rdcspv::Op::SubgroupAvcRefSetBidirectionalMixDisableINTEL:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      break;
    case rdcspv::Op::SubgroupAvcRefSetBilinearFilterEnableINTEL:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      break;
    case rdcspv::Op::SubgroupAvcRefEvaluateWithSingleReferenceINTEL:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      callback(Id::fromWord(it.word(5)), false);
      break;
    case rdcspv::Op::SubgroupAvcRefEvaluateWithDualReferenceINTEL:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      callback(Id::fromWord(it.word(5)), false);
      callback(Id::fromWord(it.word(6)), false);
      break;
    case rdcspv::Op::SubgroupAvcRefEvaluateWithMultiReferenceINTEL:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      callback(Id::fromWord(it.word(5)), false);
      break;
    case rdcspv::Op::SubgroupAvcRefEvaluateWithMultiReferenceInterlacedINTEL:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      callback(Id::fromWord(it.word(5)), false);
      callback(Id::fromWord(it.word(6)), false);
      break;
    case rdcspv::Op::SubgroupAvcRefConvertToMceResultINTEL:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      break;
    case rdcspv::Op::SubgroupAvcSicInitializeINTEL:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      break;
    case rdcspv::Op::SubgroupAvcSicConfigureSkcINTEL:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      callback(Id::fromWord(it.word(5)), false);
      callback(Id::fromWord(it.word(6)), false);
      callback(Id::fromWord(it.word(7)), false);
      callback(Id::fromWord(it.word(8)), false);
      break;
    case rdcspv::Op::SubgroupAvcSicConfigureIpeLumaINTEL:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      callback(Id::fromWord(it.word(5)), false);
      callback(Id::fromWord(it.word(6)), false);
      callback(Id::fromWord(it.word(7)), false);
      callback(Id::fromWord(it.word(8)), false);
      callback(Id::fromWord(it.word(9)), false);
      callback(Id::fromWord(it.word(10)), false);
      break;
    case rdcspv::Op::SubgroupAvcSicConfigureIpeLumaChromaINTEL:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      callback(Id::fromWord(it.word(5)), false);
      callback(Id::fromWord(it.word(6)), false);
      callback(Id::fromWord(it.word(7)), false);
      callback(Id::fromWord(it.word(8)), false);
      callback(Id::fromWord(it.word(9)), false);
      callback(Id::fromWord(it.word(10)), false);
      callback(Id::fromWord(it.word(11)), false);
      callback(Id::fromWord(it.word(12)), false);
      callback(Id::fromWord(it.word(13)), false);
      break;
    case rdcspv::Op::SubgroupAvcSicGetMotionVectorMaskINTEL:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      break;
    case rdcspv::Op::SubgroupAvcSicConvertToMcePayloadINTEL:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      break;
    case rdcspv::Op::SubgroupAvcSicSetIntraLumaShapePenaltyINTEL:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      break;
    case rdcspv::Op::SubgroupAvcSicSetIntraLumaModeCostFunctionINTEL:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      callback(Id::fromWord(it.word(5)), false);
      callback(Id::fromWord(it.word(6)), false);
      break;
    case rdcspv::Op::SubgroupAvcSicSetIntraChromaModeCostFunctionINTEL:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      break;
    case rdcspv::Op::SubgroupAvcSicSetBilinearFilterEnableINTEL:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      break;
    case rdcspv::Op::SubgroupAvcSicSetSkcForwardTransformEnableINTEL:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      break;
    case rdcspv::Op::SubgroupAvcSicSetBlockBasedRawSkipSadINTEL:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      break;
    case rdcspv::Op::SubgroupAvcSicEvaluateIpeINTEL:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      break;
    case rdcspv::Op::SubgroupAvcSicEvaluateWithSingleReferenceINTEL:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      callback(Id::fromWord(it.word(5)), false);
      break;
    case rdcspv::Op::SubgroupAvcSicEvaluateWithDualReferenceINTEL:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      callback(Id::fromWord(it.word(5)), false);
      callback(Id::fromWord(it.word(6)), false);
      break;
    case rdcspv::Op::SubgroupAvcSicEvaluateWithMultiReferenceINTEL:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      callback(Id::fromWord(it.word(5)), false);
      break;
    case rdcspv::Op::SubgroupAvcSicEvaluateWithMultiReferenceInterlacedINTEL:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      callback(Id::fromWord(it.word(5)), false);
      callback(Id::fromWord(it.word(6)), false);
      break;
    case rdcspv::Op::SubgroupAvcSicConvertToMceResultINTEL:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      break;
    case rdcspv::Op::SubgroupAvcSicGetIpeLumaShapeINTEL:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      break;
    case rdcspv::Op::SubgroupAvcSicGetBestIpeLumaDistortionINTEL:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      break;
    case rdcspv::Op::SubgroupAvcSicGetBestIpeChromaDistortionINTEL:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      break;
    case rdcspv::Op::SubgroupAvcSicGetPackedIpeLumaModesINTEL:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      break;
    case rdcspv::Op::SubgroupAvcSicGetIpeChromaModeINTEL:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      break;
    case rdcspv::Op::SubgroupAvcSicGetPackedSkcLumaCountThresholdINTEL:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      break;
    case rdcspv::Op::SubgroupAvcSicGetPackedSkcLumaSumThresholdINTEL:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      break;
    case rdcspv::Op::SubgroupAvcSicGetInterRawSadsINTEL:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      break;
    case rdcspv::Op::LoopControlINTEL:
      break;
    case rdcspv::Op::ReadPipeBlockingINTEL:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      break;
    case rdcspv::Op::WritePipeBlockingINTEL:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      break;
    case rdcspv::Op::FPGARegINTEL:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      break;
    case rdcspv::Op::RayQueryGetRayTMinKHR:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      break;
    case rdcspv::Op::RayQueryGetRayFlagsKHR:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      break;
    case rdcspv::Op::RayQueryGetIntersectionTKHR:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      break;
    case rdcspv::Op::RayQueryGetIntersectionInstanceCustomIndexKHR:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      break;
    case rdcspv::Op::RayQueryGetIntersectionInstanceIdKHR:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      break;
    case rdcspv::Op::RayQueryGetIntersectionInstanceShaderBindingTableRecordOffsetKHR:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      break;
    case rdcspv::Op::RayQueryGetIntersectionGeometryIndexKHR:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      break;
    case rdcspv::Op::RayQueryGetIntersectionPrimitiveIndexKHR:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      break;
    case rdcspv::Op::RayQueryGetIntersectionBarycentricsKHR:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      break;
    case rdcspv::Op::RayQueryGetIntersectionFrontFaceKHR:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      break;
    case rdcspv::Op::RayQueryGetIntersectionCandidateAABBOpaqueKHR:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      break;
    case rdcspv::Op::RayQueryGetIntersectionObjectRayDirectionKHR:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      break;
    case rdcspv::Op::RayQueryGetIntersectionObjectRayOriginKHR:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      break;
    case rdcspv::Op::RayQueryGetWorldRayDirectionKHR:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      break;
    case rdcspv::Op::RayQueryGetWorldRayOriginKHR:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      break;
    case rdcspv::Op::RayQueryGetIntersectionObjectToWorldKHR:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      break;
    case rdcspv::Op::RayQueryGetIntersectionWorldToObjectKHR:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      break;
    case rdcspv::Op::AtomicFAddEXT:
      callback(Id::fromWord(it.word(1)), false);
      callback(Id::fromWord(it.word(2)), true);
      callback(Id::fromWord(it.word(3)), false);
      callback(Id::fromWord(it.word(4)), false);
      callback(Id::fromWord(it.word(5)), false);
      callback(Id::fromWord(it.word(6)), false);
      break;
    case Op::Max: break;
  }
}

rdcstr OpDecoder::Disassemble(const ConstIter &it, const std::function<rdcstr(Id,Id)> &declName, const std::function<rdcstr(rdcspv::Id)> &idName, const std::function<uint32_t(Id)> &constIntVal)
{
  rdcstr ret;
  switch(it.opcode())
  {
    case rdcspv::Op::Nop:
    {
      OpNop decoded(it);
      ret += "Nop(" ")";
      break;
    }
    case rdcspv::Op::Undef:
    {
      OpUndef decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "Undef(" ")";
      break;
    }
    case rdcspv::Op::SourceContinued:
    {
      OpSourceContinued decoded(it);
      ret += "SourceContinued(" + ParamToStr(idName, decoded.continuedSource) + ")";
      break;
    }
    case rdcspv::Op::Source:
    {
      OpSource decoded(it);
      ret += "Source(" + ParamToStr(idName, decoded.sourceLanguage) + ", " + ParamToStr(idName, decoded.version) + ", " + ParamToStr(idName, decoded.file) + ", " + ParamToStr(idName, decoded.source) + ")";
      break;
    }
    case rdcspv::Op::SourceExtension:
    {
      OpSourceExtension decoded(it);
      ret += "SourceExtension(" + ParamToStr(idName, decoded.extension) + ")";
      break;
    }
    case rdcspv::Op::Name:
    {
      OpName decoded(it);
      ret += "Name(" + ParamToStr(idName, decoded.target) + ", " + ParamToStr(idName, decoded.name) + ")";
      break;
    }
    case rdcspv::Op::MemberName:
    {
      OpMemberName decoded(it);
      ret += "MemberName(" + ParamToStr(idName, decoded.type) + ", " + ParamToStr(idName, decoded.member) + ", " + ParamToStr(idName, decoded.name) + ")";
      break;
    }
    case rdcspv::Op::String:
    {
      OpString decoded(it);
      ret += idName(decoded.result) + " = ";
      ret += "String(" + ParamToStr(idName, decoded.string) + ")";
      break;
    }
    case rdcspv::Op::Line:
    {
      OpLine decoded(it);
      ret += "Line(" + ParamToStr(idName, decoded.file) + ", " + ParamToStr(idName, decoded.line) + ", " + ParamToStr(idName, decoded.column) + ")";
      break;
    }
    case rdcspv::Op::Extension:
    {
      OpExtension decoded(it);
      ret += "Extension(" + ParamToStr(idName, decoded.name) + ")";
      break;
    }
    case rdcspv::Op::ExtInstImport:
    {
      OpExtInstImport decoded(it);
      ret += idName(decoded.result) + " = ";
      ret += "ExtInstImport(" + ParamToStr(idName, decoded.name) + ")";
      break;
    }
    case rdcspv::Op::ExtInst:
    {
      OpDecoder decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "ExtInst(...)";
      break;
    }
    case rdcspv::Op::MemoryModel:
    {
      OpMemoryModel decoded(it);
      ret += "MemoryModel(" + ParamToStr(idName, decoded.addressingModel) + ", " + ParamToStr(idName, decoded.memoryModel) + ")";
      break;
    }
    case rdcspv::Op::EntryPoint:
    {
      OpEntryPoint decoded(it);
      ret += "EntryPoint(" + ParamToStr(idName, decoded.executionModel) + ", " + ParamToStr(idName, decoded.entryPoint) + ", " + ParamToStr(idName, decoded.name) + ", " + ParamsToStr(idName, decoded.iface) + ")";
      break;
    }
    case rdcspv::Op::ExecutionMode:
    {
      OpExecutionMode decoded(it);
      ret += "ExecutionMode(" + ParamToStr(idName, decoded.entryPoint) + ", " + ParamToStr(idName, decoded.mode) + ")";
      break;
    }
    case rdcspv::Op::Capability:
    {
      OpCapability decoded(it);
      ret += "Capability(" + ParamToStr(idName, decoded.capability) + ")";
      break;
    }
    case rdcspv::Op::TypeVoid:
    {
      OpTypeVoid decoded(it);
      ret += idName(decoded.result) + " = ";
      ret += "TypeVoid(" ")";
      break;
    }
    case rdcspv::Op::TypeBool:
    {
      OpTypeBool decoded(it);
      ret += idName(decoded.result) + " = ";
      ret += "TypeBool(" ")";
      break;
    }
    case rdcspv::Op::TypeInt:
    {
      OpTypeInt decoded(it);
      ret += idName(decoded.result) + " = ";
      ret += "TypeInt(" + ParamToStr(idName, decoded.width) + ", " + ParamToStr(idName, decoded.signedness) + ")";
      break;
    }
    case rdcspv::Op::TypeFloat:
    {
      OpTypeFloat decoded(it);
      ret += idName(decoded.result) + " = ";
      ret += "TypeFloat(" + ParamToStr(idName, decoded.width) + ")";
      break;
    }
    case rdcspv::Op::TypeVector:
    {
      OpTypeVector decoded(it);
      ret += idName(decoded.result) + " = ";
      ret += "TypeVector(" + ParamToStr(idName, decoded.componentType) + ", " + ParamToStr(idName, decoded.componentCount) + ")";
      break;
    }
    case rdcspv::Op::TypeMatrix:
    {
      OpTypeMatrix decoded(it);
      ret += idName(decoded.result) + " = ";
      ret += "TypeMatrix(" + ParamToStr(idName, decoded.columnType) + ", " + ParamToStr(idName, decoded.columnCount) + ")";
      break;
    }
    case rdcspv::Op::TypeImage:
    {
      OpTypeImage decoded(it);
      ret += idName(decoded.result) + " = ";
      ret += "TypeImage(" + ParamToStr(idName, decoded.sampledType) + ", " + ParamToStr(idName, decoded.dim) + ", " + ParamToStr(idName, decoded.depth) + ", " + ParamToStr(idName, decoded.arrayed) + ", " + ParamToStr(idName, decoded.mS) + ", " + ParamToStr(idName, decoded.sampled) + ", " + ParamToStr(idName, decoded.imageFormat) + ", " + ParamToStr(idName, decoded.accessQualifier) + ")";
      break;
    }
    case rdcspv::Op::TypeSampler:
    {
      OpTypeSampler decoded(it);
      ret += idName(decoded.result) + " = ";
      ret += "TypeSampler(" ")";
      break;
    }
    case rdcspv::Op::TypeSampledImage:
    {
      OpTypeSampledImage decoded(it);
      ret += idName(decoded.result) + " = ";
      ret += "TypeSampledImage(" + ParamToStr(idName, decoded.imageType) + ")";
      break;
    }
    case rdcspv::Op::TypeArray:
    {
      OpTypeArray decoded(it);
      ret += idName(decoded.result) + " = ";
      ret += "TypeArray(" + ParamToStr(idName, decoded.elementType) + ", " + ParamToStr(idName, decoded.length) + ")";
      break;
    }
    case rdcspv::Op::TypeRuntimeArray:
    {
      OpTypeRuntimeArray decoded(it);
      ret += idName(decoded.result) + " = ";
      ret += "TypeRuntimeArray(" + ParamToStr(idName, decoded.elementType) + ")";
      break;
    }
    case rdcspv::Op::TypeStruct:
    {
      OpTypeStruct decoded(it);
      ret += idName(decoded.result) + " = ";
      ret += "TypeStruct(" + ParamsToStr(idName, decoded.members) + ")";
      break;
    }
    case rdcspv::Op::TypeOpaque:
    {
      OpTypeOpaque decoded(it);
      ret += idName(decoded.result) + " = ";
      ret += "TypeOpaque(" + ParamToStr(idName, decoded.thenameoftheopaquetype) + ")";
      break;
    }
    case rdcspv::Op::TypePointer:
    {
      OpTypePointer decoded(it);
      ret += idName(decoded.result) + " = ";
      ret += "TypePointer(" + ParamToStr(idName, decoded.storageClass) + ", " + ParamToStr(idName, decoded.type) + ")";
      break;
    }
    case rdcspv::Op::TypeFunction:
    {
      OpTypeFunction decoded(it);
      ret += idName(decoded.result) + " = ";
      ret += "TypeFunction(" + ParamToStr(idName, decoded.returnType) + ", " + ParamsToStr(idName, decoded.parameters) + ")";
      break;
    }
    case rdcspv::Op::TypeEvent:
    {
      OpTypeEvent decoded(it);
      ret += idName(decoded.result) + " = ";
      ret += "TypeEvent(" ")";
      break;
    }
    case rdcspv::Op::TypeDeviceEvent:
    {
      OpTypeDeviceEvent decoded(it);
      ret += idName(decoded.result) + " = ";
      ret += "TypeDeviceEvent(" ")";
      break;
    }
    case rdcspv::Op::TypeReserveId:
    {
      OpTypeReserveId decoded(it);
      ret += idName(decoded.result) + " = ";
      ret += "TypeReserveId(" ")";
      break;
    }
    case rdcspv::Op::TypeQueue:
    {
      OpTypeQueue decoded(it);
      ret += idName(decoded.result) + " = ";
      ret += "TypeQueue(" ")";
      break;
    }
    case rdcspv::Op::TypePipe:
    {
      OpTypePipe decoded(it);
      ret += idName(decoded.result) + " = ";
      ret += "TypePipe(" + ParamToStr(idName, decoded.qualifier) + ")";
      break;
    }
    case rdcspv::Op::TypeForwardPointer:
    {
      OpTypeForwardPointer decoded(it);
      ret += "TypeForwardPointer(" + ParamToStr(idName, decoded.pointerType) + ", " + ParamToStr(idName, decoded.storageClass) + ")";
      break;
    }
    case rdcspv::Op::ConstantTrue:
    {
      OpConstantTrue decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "ConstantTrue(" ")";
      break;
    }
    case rdcspv::Op::ConstantFalse:
    {
      OpConstantFalse decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "ConstantFalse(" ")";
      break;
    }
    case rdcspv::Op::Constant:
    {
      OpDecoder decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "Constant(...)";
      break;
    }
    case rdcspv::Op::ConstantComposite:
    {
      OpConstantComposite decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "ConstantComposite(" + ParamsToStr(idName, decoded.constituents) + ")";
      break;
    }
    case rdcspv::Op::ConstantSampler:
    {
      OpConstantSampler decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "ConstantSampler(" + ParamToStr(idName, decoded.samplerAddressingMode) + ", " + ParamToStr(idName, decoded.param) + ", " + ParamToStr(idName, decoded.samplerFilterMode) + ")";
      break;
    }
    case rdcspv::Op::ConstantNull:
    {
      OpConstantNull decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "ConstantNull(" ")";
      break;
    }
    case rdcspv::Op::SpecConstantTrue:
    {
      OpSpecConstantTrue decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "SpecConstantTrue(" ")";
      break;
    }
    case rdcspv::Op::SpecConstantFalse:
    {
      OpSpecConstantFalse decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "SpecConstantFalse(" ")";
      break;
    }
    case rdcspv::Op::SpecConstant:
    {
      OpDecoder decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "SpecConstant(...)";
      break;
    }
    case rdcspv::Op::SpecConstantComposite:
    {
      OpSpecConstantComposite decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "SpecConstantComposite(" + ParamsToStr(idName, decoded.constituents) + ")";
      break;
    }
    case rdcspv::Op::SpecConstantOp:
    {
      OpDecoder decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "SpecConstantOp(...)";
      break;
    }
    case rdcspv::Op::Function:
    {
      OpFunction decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "Function(" + ParamToStr(idName, decoded.functionControl) + ", " + ParamToStr(idName, decoded.functionType) + ")";
      break;
    }
    case rdcspv::Op::FunctionParameter:
    {
      OpFunctionParameter decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "FunctionParameter(" ")";
      break;
    }
    case rdcspv::Op::FunctionEnd:
    {
      OpFunctionEnd decoded(it);
      ret += "FunctionEnd(" ")";
      break;
    }
    case rdcspv::Op::FunctionCall:
    {
      OpFunctionCall decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "FunctionCall(" + ParamToStr(idName, decoded.function) + ", " + ParamsToStr(idName, decoded.arguments) + ")";
      break;
    }
    case rdcspv::Op::Variable:
    {
      OpVariable decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "Variable(" + ParamToStr(idName, decoded.storageClass) + ", " + ParamToStr(idName, decoded.initializer) + ")";
      break;
    }
    case rdcspv::Op::ImageTexelPointer:
    {
      OpImageTexelPointer decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "ImageTexelPointer(" + ParamToStr(idName, decoded.image) + ", " + ParamToStr(idName, decoded.coordinate) + ", " + ParamToStr(idName, decoded.sample) + ")";
      break;
    }
    case rdcspv::Op::Load:
    {
      OpLoad decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "Load(" + ParamToStr(idName, decoded.pointer) + ", " + ParamToStr(idName, decoded.memoryAccess) + ")";
      break;
    }
    case rdcspv::Op::Store:
    {
      OpStore decoded(it);
      ret += "Store(" + ParamToStr(idName, decoded.pointer) + ", " + ParamToStr(idName, decoded.object) + ", " + ParamToStr(idName, decoded.memoryAccess) + ")";
      break;
    }
    case rdcspv::Op::CopyMemory:
    {
      OpCopyMemory decoded(it);
      ret += "CopyMemory(" + ParamToStr(idName, decoded.target) + ", " + ParamToStr(idName, decoded.source) + ", " + ParamToStr(idName, decoded.memoryAccess0) + ", " + ParamToStr(idName, decoded.memoryAccess1) + ")";
      break;
    }
    case rdcspv::Op::CopyMemorySized:
    {
      OpCopyMemorySized decoded(it);
      ret += "CopyMemorySized(" + ParamToStr(idName, decoded.target) + ", " + ParamToStr(idName, decoded.source) + ", " + ParamToStr(idName, decoded.size) + ", " + ParamToStr(idName, decoded.memoryAccess0) + ", " + ParamToStr(idName, decoded.memoryAccess1) + ")";
      break;
    }
    case rdcspv::Op::AccessChain:
    {
      OpAccessChain decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "AccessChain(" + ParamToStr(idName, decoded.base) + ", " + ParamsToStr(idName, decoded.indexes) + ")";
      break;
    }
    case rdcspv::Op::InBoundsAccessChain:
    {
      OpInBoundsAccessChain decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "InBoundsAccessChain(" + ParamToStr(idName, decoded.base) + ", " + ParamsToStr(idName, decoded.indexes) + ")";
      break;
    }
    case rdcspv::Op::PtrAccessChain:
    {
      OpPtrAccessChain decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "PtrAccessChain(" + ParamToStr(idName, decoded.base) + ", " + ParamToStr(idName, decoded.element) + ", " + ParamsToStr(idName, decoded.indexes) + ")";
      break;
    }
    case rdcspv::Op::ArrayLength:
    {
      OpArrayLength decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "ArrayLength(" + ParamToStr(idName, decoded.structure) + ", " + ParamToStr(idName, decoded.arraymember) + ")";
      break;
    }
    case rdcspv::Op::GenericPtrMemSemantics:
    {
      OpGenericPtrMemSemantics decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "GenericPtrMemSemantics(" + ParamToStr(idName, decoded.pointer) + ")";
      break;
    }
    case rdcspv::Op::InBoundsPtrAccessChain:
    {
      OpInBoundsPtrAccessChain decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "InBoundsPtrAccessChain(" + ParamToStr(idName, decoded.base) + ", " + ParamToStr(idName, decoded.element) + ", " + ParamsToStr(idName, decoded.indexes) + ")";
      break;
    }
    case rdcspv::Op::Decorate:
    {
      OpDecorate decoded(it);
      ret += "Decorate(" + ParamToStr(idName, decoded.target) + ", " + ParamToStr(idName, decoded.decoration) + ")";
      break;
    }
    case rdcspv::Op::MemberDecorate:
    {
      OpMemberDecorate decoded(it);
      ret += "MemberDecorate(" + ParamToStr(idName, decoded.structureType) + ", " + ParamToStr(idName, decoded.member) + ", " + ParamToStr(idName, decoded.decoration) + ")";
      break;
    }
    case rdcspv::Op::DecorationGroup:
    {
      OpDecorationGroup decoded(it);
      ret += idName(decoded.result) + " = ";
      ret += "DecorationGroup(" ")";
      break;
    }
    case rdcspv::Op::GroupDecorate:
    {
      OpGroupDecorate decoded(it);
      ret += "GroupDecorate(" + ParamToStr(idName, decoded.decorationGroup) + ", " + ParamsToStr(idName, decoded.targets) + ")";
      break;
    }
    case rdcspv::Op::GroupMemberDecorate:
    {
      OpGroupMemberDecorate decoded(it);
      ret += "GroupMemberDecorate(" + ParamToStr(idName, decoded.decorationGroup) + ", " + ParamsToStr(idName, decoded.targets) + ")";
      break;
    }
    case rdcspv::Op::VectorExtractDynamic:
    {
      OpVectorExtractDynamic decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "VectorExtractDynamic(" + ParamToStr(idName, decoded.vector) + ", " + ParamToStr(idName, decoded.index) + ")";
      break;
    }
    case rdcspv::Op::VectorInsertDynamic:
    {
      OpVectorInsertDynamic decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "VectorInsertDynamic(" + ParamToStr(idName, decoded.vector) + ", " + ParamToStr(idName, decoded.component) + ", " + ParamToStr(idName, decoded.index) + ")";
      break;
    }
    case rdcspv::Op::VectorShuffle:
    {
      OpVectorShuffle decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "VectorShuffle(" + ParamToStr(idName, decoded.vector1) + ", " + ParamToStr(idName, decoded.vector2) + ", " + ParamsToStr(idName, decoded.components) + ")";
      break;
    }
    case rdcspv::Op::CompositeConstruct:
    {
      OpCompositeConstruct decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "CompositeConstruct(" + ParamsToStr(idName, decoded.constituents) + ")";
      break;
    }
    case rdcspv::Op::CompositeExtract:
    {
      OpCompositeExtract decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "CompositeExtract(" + ParamToStr(idName, decoded.composite) + ", " + ParamsToStr(idName, decoded.indexes) + ")";
      break;
    }
    case rdcspv::Op::CompositeInsert:
    {
      OpCompositeInsert decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "CompositeInsert(" + ParamToStr(idName, decoded.object) + ", " + ParamToStr(idName, decoded.composite) + ", " + ParamsToStr(idName, decoded.indexes) + ")";
      break;
    }
    case rdcspv::Op::CopyObject:
    {
      OpCopyObject decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "CopyObject(" + ParamToStr(idName, decoded.operand) + ")";
      break;
    }
    case rdcspv::Op::Transpose:
    {
      OpTranspose decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "Transpose(" + ParamToStr(idName, decoded.matrix) + ")";
      break;
    }
    case rdcspv::Op::SampledImage:
    {
      OpSampledImage decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "SampledImage(" + ParamToStr(idName, decoded.image) + ", " + ParamToStr(idName, decoded.sampler) + ")";
      break;
    }
    case rdcspv::Op::ImageSampleImplicitLod:
    {
      OpImageSampleImplicitLod decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "ImageSampleImplicitLod(" + ParamToStr(idName, decoded.sampledImage) + ", " + ParamToStr(idName, decoded.coordinate) + ", " + ParamToStr(idName, decoded.imageOperands) + ")";
      break;
    }
    case rdcspv::Op::ImageSampleExplicitLod:
    {
      OpImageSampleExplicitLod decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "ImageSampleExplicitLod(" + ParamToStr(idName, decoded.sampledImage) + ", " + ParamToStr(idName, decoded.coordinate) + ", " + ParamToStr(idName, decoded.imageOperands) + ")";
      break;
    }
    case rdcspv::Op::ImageSampleDrefImplicitLod:
    {
      OpImageSampleDrefImplicitLod decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "ImageSampleDrefImplicitLod(" + ParamToStr(idName, decoded.sampledImage) + ", " + ParamToStr(idName, decoded.coordinate) + ", " + ParamToStr(idName, decoded.dref) + ", " + ParamToStr(idName, decoded.imageOperands) + ")";
      break;
    }
    case rdcspv::Op::ImageSampleDrefExplicitLod:
    {
      OpImageSampleDrefExplicitLod decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "ImageSampleDrefExplicitLod(" + ParamToStr(idName, decoded.sampledImage) + ", " + ParamToStr(idName, decoded.coordinate) + ", " + ParamToStr(idName, decoded.dref) + ", " + ParamToStr(idName, decoded.imageOperands) + ")";
      break;
    }
    case rdcspv::Op::ImageSampleProjImplicitLod:
    {
      OpImageSampleProjImplicitLod decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "ImageSampleProjImplicitLod(" + ParamToStr(idName, decoded.sampledImage) + ", " + ParamToStr(idName, decoded.coordinate) + ", " + ParamToStr(idName, decoded.imageOperands) + ")";
      break;
    }
    case rdcspv::Op::ImageSampleProjExplicitLod:
    {
      OpImageSampleProjExplicitLod decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "ImageSampleProjExplicitLod(" + ParamToStr(idName, decoded.sampledImage) + ", " + ParamToStr(idName, decoded.coordinate) + ", " + ParamToStr(idName, decoded.imageOperands) + ")";
      break;
    }
    case rdcspv::Op::ImageSampleProjDrefImplicitLod:
    {
      OpImageSampleProjDrefImplicitLod decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "ImageSampleProjDrefImplicitLod(" + ParamToStr(idName, decoded.sampledImage) + ", " + ParamToStr(idName, decoded.coordinate) + ", " + ParamToStr(idName, decoded.dref) + ", " + ParamToStr(idName, decoded.imageOperands) + ")";
      break;
    }
    case rdcspv::Op::ImageSampleProjDrefExplicitLod:
    {
      OpImageSampleProjDrefExplicitLod decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "ImageSampleProjDrefExplicitLod(" + ParamToStr(idName, decoded.sampledImage) + ", " + ParamToStr(idName, decoded.coordinate) + ", " + ParamToStr(idName, decoded.dref) + ", " + ParamToStr(idName, decoded.imageOperands) + ")";
      break;
    }
    case rdcspv::Op::ImageFetch:
    {
      OpImageFetch decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "ImageFetch(" + ParamToStr(idName, decoded.image) + ", " + ParamToStr(idName, decoded.coordinate) + ", " + ParamToStr(idName, decoded.imageOperands) + ")";
      break;
    }
    case rdcspv::Op::ImageGather:
    {
      OpImageGather decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "ImageGather(" + ParamToStr(idName, decoded.sampledImage) + ", " + ParamToStr(idName, decoded.coordinate) + ", " + ParamToStr(idName, decoded.component) + ", " + ParamToStr(idName, decoded.imageOperands) + ")";
      break;
    }
    case rdcspv::Op::ImageDrefGather:
    {
      OpImageDrefGather decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "ImageDrefGather(" + ParamToStr(idName, decoded.sampledImage) + ", " + ParamToStr(idName, decoded.coordinate) + ", " + ParamToStr(idName, decoded.dref) + ", " + ParamToStr(idName, decoded.imageOperands) + ")";
      break;
    }
    case rdcspv::Op::ImageRead:
    {
      OpImageRead decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "ImageRead(" + ParamToStr(idName, decoded.image) + ", " + ParamToStr(idName, decoded.coordinate) + ", " + ParamToStr(idName, decoded.imageOperands) + ")";
      break;
    }
    case rdcspv::Op::ImageWrite:
    {
      OpImageWrite decoded(it);
      ret += "ImageWrite(" + ParamToStr(idName, decoded.image) + ", " + ParamToStr(idName, decoded.coordinate) + ", " + ParamToStr(idName, decoded.texel) + ", " + ParamToStr(idName, decoded.imageOperands) + ")";
      break;
    }
    case rdcspv::Op::Image:
    {
      OpImage decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "Image(" + ParamToStr(idName, decoded.sampledImage) + ")";
      break;
    }
    case rdcspv::Op::ImageQueryFormat:
    {
      OpImageQueryFormat decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "ImageQueryFormat(" + ParamToStr(idName, decoded.image) + ")";
      break;
    }
    case rdcspv::Op::ImageQueryOrder:
    {
      OpImageQueryOrder decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "ImageQueryOrder(" + ParamToStr(idName, decoded.image) + ")";
      break;
    }
    case rdcspv::Op::ImageQuerySizeLod:
    {
      OpImageQuerySizeLod decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "ImageQuerySizeLod(" + ParamToStr(idName, decoded.image) + ", " + ParamToStr(idName, decoded.levelofDetail) + ")";
      break;
    }
    case rdcspv::Op::ImageQuerySize:
    {
      OpImageQuerySize decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "ImageQuerySize(" + ParamToStr(idName, decoded.image) + ")";
      break;
    }
    case rdcspv::Op::ImageQueryLod:
    {
      OpImageQueryLod decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "ImageQueryLod(" + ParamToStr(idName, decoded.sampledImage) + ", " + ParamToStr(idName, decoded.coordinate) + ")";
      break;
    }
    case rdcspv::Op::ImageQueryLevels:
    {
      OpImageQueryLevels decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "ImageQueryLevels(" + ParamToStr(idName, decoded.image) + ")";
      break;
    }
    case rdcspv::Op::ImageQuerySamples:
    {
      OpImageQuerySamples decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "ImageQuerySamples(" + ParamToStr(idName, decoded.image) + ")";
      break;
    }
    case rdcspv::Op::ConvertFToU:
    {
      OpConvertFToU decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "ConvertFToU(" + ParamToStr(idName, decoded.floatValue) + ")";
      break;
    }
    case rdcspv::Op::ConvertFToS:
    {
      OpConvertFToS decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "ConvertFToS(" + ParamToStr(idName, decoded.floatValue) + ")";
      break;
    }
    case rdcspv::Op::ConvertSToF:
    {
      OpConvertSToF decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "ConvertSToF(" + ParamToStr(idName, decoded.signedValue) + ")";
      break;
    }
    case rdcspv::Op::ConvertUToF:
    {
      OpConvertUToF decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "ConvertUToF(" + ParamToStr(idName, decoded.unsignedValue) + ")";
      break;
    }
    case rdcspv::Op::UConvert:
    {
      OpUConvert decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "UConvert(" + ParamToStr(idName, decoded.unsignedValue) + ")";
      break;
    }
    case rdcspv::Op::SConvert:
    {
      OpSConvert decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "SConvert(" + ParamToStr(idName, decoded.signedValue) + ")";
      break;
    }
    case rdcspv::Op::FConvert:
    {
      OpFConvert decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "FConvert(" + ParamToStr(idName, decoded.floatValue) + ")";
      break;
    }
    case rdcspv::Op::QuantizeToF16:
    {
      OpQuantizeToF16 decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "QuantizeToF16(" + ParamToStr(idName, decoded.value) + ")";
      break;
    }
    case rdcspv::Op::ConvertPtrToU:
    {
      OpConvertPtrToU decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "ConvertPtrToU(" + ParamToStr(idName, decoded.pointer) + ")";
      break;
    }
    case rdcspv::Op::SatConvertSToU:
    {
      OpSatConvertSToU decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "SatConvertSToU(" + ParamToStr(idName, decoded.signedValue) + ")";
      break;
    }
    case rdcspv::Op::SatConvertUToS:
    {
      OpSatConvertUToS decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "SatConvertUToS(" + ParamToStr(idName, decoded.unsignedValue) + ")";
      break;
    }
    case rdcspv::Op::ConvertUToPtr:
    {
      OpConvertUToPtr decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "ConvertUToPtr(" + ParamToStr(idName, decoded.integerValue) + ")";
      break;
    }
    case rdcspv::Op::PtrCastToGeneric:
    {
      OpPtrCastToGeneric decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "PtrCastToGeneric(" + ParamToStr(idName, decoded.pointer) + ")";
      break;
    }
    case rdcspv::Op::GenericCastToPtr:
    {
      OpGenericCastToPtr decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "GenericCastToPtr(" + ParamToStr(idName, decoded.pointer) + ")";
      break;
    }
    case rdcspv::Op::GenericCastToPtrExplicit:
    {
      OpGenericCastToPtrExplicit decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "GenericCastToPtrExplicit(" + ParamToStr(idName, decoded.pointer) + ", " + ParamToStr(idName, decoded.storage) + ")";
      break;
    }
    case rdcspv::Op::Bitcast:
    {
      OpBitcast decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "Bitcast(" + ParamToStr(idName, decoded.operand) + ")";
      break;
    }
    case rdcspv::Op::SNegate:
    {
      OpSNegate decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "SNegate(" + ParamToStr(idName, decoded.operand) + ")";
      break;
    }
    case rdcspv::Op::FNegate:
    {
      OpFNegate decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "FNegate(" + ParamToStr(idName, decoded.operand) + ")";
      break;
    }
    case rdcspv::Op::IAdd:
    {
      OpIAdd decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "IAdd(" + ParamToStr(idName, decoded.operand1) + ", " + ParamToStr(idName, decoded.operand2) + ")";
      break;
    }
    case rdcspv::Op::FAdd:
    {
      OpFAdd decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "FAdd(" + ParamToStr(idName, decoded.operand1) + ", " + ParamToStr(idName, decoded.operand2) + ")";
      break;
    }
    case rdcspv::Op::ISub:
    {
      OpISub decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "ISub(" + ParamToStr(idName, decoded.operand1) + ", " + ParamToStr(idName, decoded.operand2) + ")";
      break;
    }
    case rdcspv::Op::FSub:
    {
      OpFSub decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "FSub(" + ParamToStr(idName, decoded.operand1) + ", " + ParamToStr(idName, decoded.operand2) + ")";
      break;
    }
    case rdcspv::Op::IMul:
    {
      OpIMul decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "IMul(" + ParamToStr(idName, decoded.operand1) + ", " + ParamToStr(idName, decoded.operand2) + ")";
      break;
    }
    case rdcspv::Op::FMul:
    {
      OpFMul decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "FMul(" + ParamToStr(idName, decoded.operand1) + ", " + ParamToStr(idName, decoded.operand2) + ")";
      break;
    }
    case rdcspv::Op::UDiv:
    {
      OpUDiv decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "UDiv(" + ParamToStr(idName, decoded.operand1) + ", " + ParamToStr(idName, decoded.operand2) + ")";
      break;
    }
    case rdcspv::Op::SDiv:
    {
      OpSDiv decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "SDiv(" + ParamToStr(idName, decoded.operand1) + ", " + ParamToStr(idName, decoded.operand2) + ")";
      break;
    }
    case rdcspv::Op::FDiv:
    {
      OpFDiv decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "FDiv(" + ParamToStr(idName, decoded.operand1) + ", " + ParamToStr(idName, decoded.operand2) + ")";
      break;
    }
    case rdcspv::Op::UMod:
    {
      OpUMod decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "UMod(" + ParamToStr(idName, decoded.operand1) + ", " + ParamToStr(idName, decoded.operand2) + ")";
      break;
    }
    case rdcspv::Op::SRem:
    {
      OpSRem decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "SRem(" + ParamToStr(idName, decoded.operand1) + ", " + ParamToStr(idName, decoded.operand2) + ")";
      break;
    }
    case rdcspv::Op::SMod:
    {
      OpSMod decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "SMod(" + ParamToStr(idName, decoded.operand1) + ", " + ParamToStr(idName, decoded.operand2) + ")";
      break;
    }
    case rdcspv::Op::FRem:
    {
      OpFRem decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "FRem(" + ParamToStr(idName, decoded.operand1) + ", " + ParamToStr(idName, decoded.operand2) + ")";
      break;
    }
    case rdcspv::Op::FMod:
    {
      OpFMod decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "FMod(" + ParamToStr(idName, decoded.operand1) + ", " + ParamToStr(idName, decoded.operand2) + ")";
      break;
    }
    case rdcspv::Op::VectorTimesScalar:
    {
      OpVectorTimesScalar decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "VectorTimesScalar(" + ParamToStr(idName, decoded.vector) + ", " + ParamToStr(idName, decoded.scalar) + ")";
      break;
    }
    case rdcspv::Op::MatrixTimesScalar:
    {
      OpMatrixTimesScalar decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "MatrixTimesScalar(" + ParamToStr(idName, decoded.matrix) + ", " + ParamToStr(idName, decoded.scalar) + ")";
      break;
    }
    case rdcspv::Op::VectorTimesMatrix:
    {
      OpVectorTimesMatrix decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "VectorTimesMatrix(" + ParamToStr(idName, decoded.vector) + ", " + ParamToStr(idName, decoded.matrix) + ")";
      break;
    }
    case rdcspv::Op::MatrixTimesVector:
    {
      OpMatrixTimesVector decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "MatrixTimesVector(" + ParamToStr(idName, decoded.matrix) + ", " + ParamToStr(idName, decoded.vector) + ")";
      break;
    }
    case rdcspv::Op::MatrixTimesMatrix:
    {
      OpMatrixTimesMatrix decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "MatrixTimesMatrix(" + ParamToStr(idName, decoded.leftMatrix) + ", " + ParamToStr(idName, decoded.rightMatrix) + ")";
      break;
    }
    case rdcspv::Op::OuterProduct:
    {
      OpOuterProduct decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "OuterProduct(" + ParamToStr(idName, decoded.vector1) + ", " + ParamToStr(idName, decoded.vector2) + ")";
      break;
    }
    case rdcspv::Op::Dot:
    {
      OpDot decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "Dot(" + ParamToStr(idName, decoded.vector1) + ", " + ParamToStr(idName, decoded.vector2) + ")";
      break;
    }
    case rdcspv::Op::IAddCarry:
    {
      OpIAddCarry decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "IAddCarry(" + ParamToStr(idName, decoded.operand1) + ", " + ParamToStr(idName, decoded.operand2) + ")";
      break;
    }
    case rdcspv::Op::ISubBorrow:
    {
      OpISubBorrow decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "ISubBorrow(" + ParamToStr(idName, decoded.operand1) + ", " + ParamToStr(idName, decoded.operand2) + ")";
      break;
    }
    case rdcspv::Op::UMulExtended:
    {
      OpUMulExtended decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "UMulExtended(" + ParamToStr(idName, decoded.operand1) + ", " + ParamToStr(idName, decoded.operand2) + ")";
      break;
    }
    case rdcspv::Op::SMulExtended:
    {
      OpSMulExtended decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "SMulExtended(" + ParamToStr(idName, decoded.operand1) + ", " + ParamToStr(idName, decoded.operand2) + ")";
      break;
    }
    case rdcspv::Op::Any:
    {
      OpAny decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "Any(" + ParamToStr(idName, decoded.vector) + ")";
      break;
    }
    case rdcspv::Op::All:
    {
      OpAll decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "All(" + ParamToStr(idName, decoded.vector) + ")";
      break;
    }
    case rdcspv::Op::IsNan:
    {
      OpIsNan decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "IsNan(" + ParamToStr(idName, decoded.x) + ")";
      break;
    }
    case rdcspv::Op::IsInf:
    {
      OpIsInf decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "IsInf(" + ParamToStr(idName, decoded.x) + ")";
      break;
    }
    case rdcspv::Op::IsFinite:
    {
      OpIsFinite decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "IsFinite(" + ParamToStr(idName, decoded.x) + ")";
      break;
    }
    case rdcspv::Op::IsNormal:
    {
      OpIsNormal decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "IsNormal(" + ParamToStr(idName, decoded.x) + ")";
      break;
    }
    case rdcspv::Op::SignBitSet:
    {
      OpSignBitSet decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "SignBitSet(" + ParamToStr(idName, decoded.x) + ")";
      break;
    }
    case rdcspv::Op::LessOrGreater:
    {
      OpLessOrGreater decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "LessOrGreater(" + ParamToStr(idName, decoded.x) + ", " + ParamToStr(idName, decoded.y) + ")";
      break;
    }
    case rdcspv::Op::Ordered:
    {
      OpOrdered decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "Ordered(" + ParamToStr(idName, decoded.x) + ", " + ParamToStr(idName, decoded.y) + ")";
      break;
    }
    case rdcspv::Op::Unordered:
    {
      OpUnordered decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "Unordered(" + ParamToStr(idName, decoded.x) + ", " + ParamToStr(idName, decoded.y) + ")";
      break;
    }
    case rdcspv::Op::LogicalEqual:
    {
      OpLogicalEqual decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "LogicalEqual(" + ParamToStr(idName, decoded.operand1) + ", " + ParamToStr(idName, decoded.operand2) + ")";
      break;
    }
    case rdcspv::Op::LogicalNotEqual:
    {
      OpLogicalNotEqual decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "LogicalNotEqual(" + ParamToStr(idName, decoded.operand1) + ", " + ParamToStr(idName, decoded.operand2) + ")";
      break;
    }
    case rdcspv::Op::LogicalOr:
    {
      OpLogicalOr decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "LogicalOr(" + ParamToStr(idName, decoded.operand1) + ", " + ParamToStr(idName, decoded.operand2) + ")";
      break;
    }
    case rdcspv::Op::LogicalAnd:
    {
      OpLogicalAnd decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "LogicalAnd(" + ParamToStr(idName, decoded.operand1) + ", " + ParamToStr(idName, decoded.operand2) + ")";
      break;
    }
    case rdcspv::Op::LogicalNot:
    {
      OpLogicalNot decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "LogicalNot(" + ParamToStr(idName, decoded.operand) + ")";
      break;
    }
    case rdcspv::Op::Select:
    {
      OpSelect decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "Select(" + ParamToStr(idName, decoded.condition) + ", " + ParamToStr(idName, decoded.object1) + ", " + ParamToStr(idName, decoded.object2) + ")";
      break;
    }
    case rdcspv::Op::IEqual:
    {
      OpIEqual decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "IEqual(" + ParamToStr(idName, decoded.operand1) + ", " + ParamToStr(idName, decoded.operand2) + ")";
      break;
    }
    case rdcspv::Op::INotEqual:
    {
      OpINotEqual decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "INotEqual(" + ParamToStr(idName, decoded.operand1) + ", " + ParamToStr(idName, decoded.operand2) + ")";
      break;
    }
    case rdcspv::Op::UGreaterThan:
    {
      OpUGreaterThan decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "UGreaterThan(" + ParamToStr(idName, decoded.operand1) + ", " + ParamToStr(idName, decoded.operand2) + ")";
      break;
    }
    case rdcspv::Op::SGreaterThan:
    {
      OpSGreaterThan decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "SGreaterThan(" + ParamToStr(idName, decoded.operand1) + ", " + ParamToStr(idName, decoded.operand2) + ")";
      break;
    }
    case rdcspv::Op::UGreaterThanEqual:
    {
      OpUGreaterThanEqual decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "UGreaterThanEqual(" + ParamToStr(idName, decoded.operand1) + ", " + ParamToStr(idName, decoded.operand2) + ")";
      break;
    }
    case rdcspv::Op::SGreaterThanEqual:
    {
      OpSGreaterThanEqual decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "SGreaterThanEqual(" + ParamToStr(idName, decoded.operand1) + ", " + ParamToStr(idName, decoded.operand2) + ")";
      break;
    }
    case rdcspv::Op::ULessThan:
    {
      OpULessThan decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "ULessThan(" + ParamToStr(idName, decoded.operand1) + ", " + ParamToStr(idName, decoded.operand2) + ")";
      break;
    }
    case rdcspv::Op::SLessThan:
    {
      OpSLessThan decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "SLessThan(" + ParamToStr(idName, decoded.operand1) + ", " + ParamToStr(idName, decoded.operand2) + ")";
      break;
    }
    case rdcspv::Op::ULessThanEqual:
    {
      OpULessThanEqual decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "ULessThanEqual(" + ParamToStr(idName, decoded.operand1) + ", " + ParamToStr(idName, decoded.operand2) + ")";
      break;
    }
    case rdcspv::Op::SLessThanEqual:
    {
      OpSLessThanEqual decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "SLessThanEqual(" + ParamToStr(idName, decoded.operand1) + ", " + ParamToStr(idName, decoded.operand2) + ")";
      break;
    }
    case rdcspv::Op::FOrdEqual:
    {
      OpFOrdEqual decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "FOrdEqual(" + ParamToStr(idName, decoded.operand1) + ", " + ParamToStr(idName, decoded.operand2) + ")";
      break;
    }
    case rdcspv::Op::FUnordEqual:
    {
      OpFUnordEqual decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "FUnordEqual(" + ParamToStr(idName, decoded.operand1) + ", " + ParamToStr(idName, decoded.operand2) + ")";
      break;
    }
    case rdcspv::Op::FOrdNotEqual:
    {
      OpFOrdNotEqual decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "FOrdNotEqual(" + ParamToStr(idName, decoded.operand1) + ", " + ParamToStr(idName, decoded.operand2) + ")";
      break;
    }
    case rdcspv::Op::FUnordNotEqual:
    {
      OpFUnordNotEqual decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "FUnordNotEqual(" + ParamToStr(idName, decoded.operand1) + ", " + ParamToStr(idName, decoded.operand2) + ")";
      break;
    }
    case rdcspv::Op::FOrdLessThan:
    {
      OpFOrdLessThan decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "FOrdLessThan(" + ParamToStr(idName, decoded.operand1) + ", " + ParamToStr(idName, decoded.operand2) + ")";
      break;
    }
    case rdcspv::Op::FUnordLessThan:
    {
      OpFUnordLessThan decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "FUnordLessThan(" + ParamToStr(idName, decoded.operand1) + ", " + ParamToStr(idName, decoded.operand2) + ")";
      break;
    }
    case rdcspv::Op::FOrdGreaterThan:
    {
      OpFOrdGreaterThan decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "FOrdGreaterThan(" + ParamToStr(idName, decoded.operand1) + ", " + ParamToStr(idName, decoded.operand2) + ")";
      break;
    }
    case rdcspv::Op::FUnordGreaterThan:
    {
      OpFUnordGreaterThan decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "FUnordGreaterThan(" + ParamToStr(idName, decoded.operand1) + ", " + ParamToStr(idName, decoded.operand2) + ")";
      break;
    }
    case rdcspv::Op::FOrdLessThanEqual:
    {
      OpFOrdLessThanEqual decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "FOrdLessThanEqual(" + ParamToStr(idName, decoded.operand1) + ", " + ParamToStr(idName, decoded.operand2) + ")";
      break;
    }
    case rdcspv::Op::FUnordLessThanEqual:
    {
      OpFUnordLessThanEqual decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "FUnordLessThanEqual(" + ParamToStr(idName, decoded.operand1) + ", " + ParamToStr(idName, decoded.operand2) + ")";
      break;
    }
    case rdcspv::Op::FOrdGreaterThanEqual:
    {
      OpFOrdGreaterThanEqual decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "FOrdGreaterThanEqual(" + ParamToStr(idName, decoded.operand1) + ", " + ParamToStr(idName, decoded.operand2) + ")";
      break;
    }
    case rdcspv::Op::FUnordGreaterThanEqual:
    {
      OpFUnordGreaterThanEqual decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "FUnordGreaterThanEqual(" + ParamToStr(idName, decoded.operand1) + ", " + ParamToStr(idName, decoded.operand2) + ")";
      break;
    }
    case rdcspv::Op::ShiftRightLogical:
    {
      OpShiftRightLogical decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "ShiftRightLogical(" + ParamToStr(idName, decoded.base) + ", " + ParamToStr(idName, decoded.shift) + ")";
      break;
    }
    case rdcspv::Op::ShiftRightArithmetic:
    {
      OpShiftRightArithmetic decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "ShiftRightArithmetic(" + ParamToStr(idName, decoded.base) + ", " + ParamToStr(idName, decoded.shift) + ")";
      break;
    }
    case rdcspv::Op::ShiftLeftLogical:
    {
      OpShiftLeftLogical decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "ShiftLeftLogical(" + ParamToStr(idName, decoded.base) + ", " + ParamToStr(idName, decoded.shift) + ")";
      break;
    }
    case rdcspv::Op::BitwiseOr:
    {
      OpBitwiseOr decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "BitwiseOr(" + ParamToStr(idName, decoded.operand1) + ", " + ParamToStr(idName, decoded.operand2) + ")";
      break;
    }
    case rdcspv::Op::BitwiseXor:
    {
      OpBitwiseXor decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "BitwiseXor(" + ParamToStr(idName, decoded.operand1) + ", " + ParamToStr(idName, decoded.operand2) + ")";
      break;
    }
    case rdcspv::Op::BitwiseAnd:
    {
      OpBitwiseAnd decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "BitwiseAnd(" + ParamToStr(idName, decoded.operand1) + ", " + ParamToStr(idName, decoded.operand2) + ")";
      break;
    }
    case rdcspv::Op::Not:
    {
      OpNot decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "Not(" + ParamToStr(idName, decoded.operand) + ")";
      break;
    }
    case rdcspv::Op::BitFieldInsert:
    {
      OpBitFieldInsert decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "BitFieldInsert(" + ParamToStr(idName, decoded.base) + ", " + ParamToStr(idName, decoded.insert) + ", " + ParamToStr(idName, decoded.offset) + ", " + ParamToStr(idName, decoded.count) + ")";
      break;
    }
    case rdcspv::Op::BitFieldSExtract:
    {
      OpBitFieldSExtract decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "BitFieldSExtract(" + ParamToStr(idName, decoded.base) + ", " + ParamToStr(idName, decoded.offset) + ", " + ParamToStr(idName, decoded.count) + ")";
      break;
    }
    case rdcspv::Op::BitFieldUExtract:
    {
      OpBitFieldUExtract decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "BitFieldUExtract(" + ParamToStr(idName, decoded.base) + ", " + ParamToStr(idName, decoded.offset) + ", " + ParamToStr(idName, decoded.count) + ")";
      break;
    }
    case rdcspv::Op::BitReverse:
    {
      OpBitReverse decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "BitReverse(" + ParamToStr(idName, decoded.base) + ")";
      break;
    }
    case rdcspv::Op::BitCount:
    {
      OpBitCount decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "BitCount(" + ParamToStr(idName, decoded.base) + ")";
      break;
    }
    case rdcspv::Op::DPdx:
    {
      OpDPdx decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "DPdx(" + ParamToStr(idName, decoded.p) + ")";
      break;
    }
    case rdcspv::Op::DPdy:
    {
      OpDPdy decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "DPdy(" + ParamToStr(idName, decoded.p) + ")";
      break;
    }
    case rdcspv::Op::Fwidth:
    {
      OpFwidth decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "Fwidth(" + ParamToStr(idName, decoded.p) + ")";
      break;
    }
    case rdcspv::Op::DPdxFine:
    {
      OpDPdxFine decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "DPdxFine(" + ParamToStr(idName, decoded.p) + ")";
      break;
    }
    case rdcspv::Op::DPdyFine:
    {
      OpDPdyFine decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "DPdyFine(" + ParamToStr(idName, decoded.p) + ")";
      break;
    }
    case rdcspv::Op::FwidthFine:
    {
      OpFwidthFine decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "FwidthFine(" + ParamToStr(idName, decoded.p) + ")";
      break;
    }
    case rdcspv::Op::DPdxCoarse:
    {
      OpDPdxCoarse decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "DPdxCoarse(" + ParamToStr(idName, decoded.p) + ")";
      break;
    }
    case rdcspv::Op::DPdyCoarse:
    {
      OpDPdyCoarse decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "DPdyCoarse(" + ParamToStr(idName, decoded.p) + ")";
      break;
    }
    case rdcspv::Op::FwidthCoarse:
    {
      OpFwidthCoarse decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "FwidthCoarse(" + ParamToStr(idName, decoded.p) + ")";
      break;
    }
    case rdcspv::Op::EmitVertex:
    {
      OpEmitVertex decoded(it);
      ret += "EmitVertex(" ")";
      break;
    }
    case rdcspv::Op::EndPrimitive:
    {
      OpEndPrimitive decoded(it);
      ret += "EndPrimitive(" ")";
      break;
    }
    case rdcspv::Op::EmitStreamVertex:
    {
      OpEmitStreamVertex decoded(it);
      ret += "EmitStreamVertex(" + ParamToStr(idName, decoded.stream) + ")";
      break;
    }
    case rdcspv::Op::EndStreamPrimitive:
    {
      OpEndStreamPrimitive decoded(it);
      ret += "EndStreamPrimitive(" + ParamToStr(idName, decoded.stream) + ")";
      break;
    }
    case rdcspv::Op::ControlBarrier:
    {
      OpControlBarrier decoded(it);
      ret += "ControlBarrier(" + ToStr(Scope(constIntVal(decoded.execution))) + ", " + ToStr(Scope(constIntVal(decoded.memory))) + ", " + ToStr(MemorySemantics(constIntVal(decoded.semantics))) + ")";
      break;
    }
    case rdcspv::Op::MemoryBarrier:
    {
      OpMemoryBarrier decoded(it);
      ret += "MemoryBarrier(" + ToStr(Scope(constIntVal(decoded.memory))) + ", " + ToStr(MemorySemantics(constIntVal(decoded.semantics))) + ")";
      break;
    }
    case rdcspv::Op::AtomicLoad:
    {
      OpAtomicLoad decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "AtomicLoad(" + ParamToStr(idName, decoded.pointer) + ", " + ToStr(Scope(constIntVal(decoded.memory))) + ", " + ToStr(MemorySemantics(constIntVal(decoded.semantics))) + ")";
      break;
    }
    case rdcspv::Op::AtomicStore:
    {
      OpAtomicStore decoded(it);
      ret += "AtomicStore(" + ParamToStr(idName, decoded.pointer) + ", " + ToStr(Scope(constIntVal(decoded.memory))) + ", " + ToStr(MemorySemantics(constIntVal(decoded.semantics))) + ", " + ParamToStr(idName, decoded.value) + ")";
      break;
    }
    case rdcspv::Op::AtomicExchange:
    {
      OpAtomicExchange decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "AtomicExchange(" + ParamToStr(idName, decoded.pointer) + ", " + ToStr(Scope(constIntVal(decoded.memory))) + ", " + ToStr(MemorySemantics(constIntVal(decoded.semantics))) + ", " + ParamToStr(idName, decoded.value) + ")";
      break;
    }
    case rdcspv::Op::AtomicCompareExchange:
    {
      OpAtomicCompareExchange decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "AtomicCompareExchange(" + ParamToStr(idName, decoded.pointer) + ", " + ToStr(Scope(constIntVal(decoded.memory))) + ", " + ToStr(MemorySemantics(constIntVal(decoded.equal))) + ", " + ToStr(MemorySemantics(constIntVal(decoded.unequal))) + ", " + ParamToStr(idName, decoded.value) + ", " + ParamToStr(idName, decoded.comparator) + ")";
      break;
    }
    case rdcspv::Op::AtomicCompareExchangeWeak:
    {
      OpAtomicCompareExchangeWeak decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "AtomicCompareExchangeWeak(" + ParamToStr(idName, decoded.pointer) + ", " + ToStr(Scope(constIntVal(decoded.memory))) + ", " + ToStr(MemorySemantics(constIntVal(decoded.equal))) + ", " + ToStr(MemorySemantics(constIntVal(decoded.unequal))) + ", " + ParamToStr(idName, decoded.value) + ", " + ParamToStr(idName, decoded.comparator) + ")";
      break;
    }
    case rdcspv::Op::AtomicIIncrement:
    {
      OpAtomicIIncrement decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "AtomicIIncrement(" + ParamToStr(idName, decoded.pointer) + ", " + ToStr(Scope(constIntVal(decoded.memory))) + ", " + ToStr(MemorySemantics(constIntVal(decoded.semantics))) + ")";
      break;
    }
    case rdcspv::Op::AtomicIDecrement:
    {
      OpAtomicIDecrement decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "AtomicIDecrement(" + ParamToStr(idName, decoded.pointer) + ", " + ToStr(Scope(constIntVal(decoded.memory))) + ", " + ToStr(MemorySemantics(constIntVal(decoded.semantics))) + ")";
      break;
    }
    case rdcspv::Op::AtomicIAdd:
    {
      OpAtomicIAdd decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "AtomicIAdd(" + ParamToStr(idName, decoded.pointer) + ", " + ToStr(Scope(constIntVal(decoded.memory))) + ", " + ToStr(MemorySemantics(constIntVal(decoded.semantics))) + ", " + ParamToStr(idName, decoded.value) + ")";
      break;
    }
    case rdcspv::Op::AtomicISub:
    {
      OpAtomicISub decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "AtomicISub(" + ParamToStr(idName, decoded.pointer) + ", " + ToStr(Scope(constIntVal(decoded.memory))) + ", " + ToStr(MemorySemantics(constIntVal(decoded.semantics))) + ", " + ParamToStr(idName, decoded.value) + ")";
      break;
    }
    case rdcspv::Op::AtomicSMin:
    {
      OpAtomicSMin decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "AtomicSMin(" + ParamToStr(idName, decoded.pointer) + ", " + ToStr(Scope(constIntVal(decoded.memory))) + ", " + ToStr(MemorySemantics(constIntVal(decoded.semantics))) + ", " + ParamToStr(idName, decoded.value) + ")";
      break;
    }
    case rdcspv::Op::AtomicUMin:
    {
      OpAtomicUMin decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "AtomicUMin(" + ParamToStr(idName, decoded.pointer) + ", " + ToStr(Scope(constIntVal(decoded.memory))) + ", " + ToStr(MemorySemantics(constIntVal(decoded.semantics))) + ", " + ParamToStr(idName, decoded.value) + ")";
      break;
    }
    case rdcspv::Op::AtomicSMax:
    {
      OpAtomicSMax decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "AtomicSMax(" + ParamToStr(idName, decoded.pointer) + ", " + ToStr(Scope(constIntVal(decoded.memory))) + ", " + ToStr(MemorySemantics(constIntVal(decoded.semantics))) + ", " + ParamToStr(idName, decoded.value) + ")";
      break;
    }
    case rdcspv::Op::AtomicUMax:
    {
      OpAtomicUMax decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "AtomicUMax(" + ParamToStr(idName, decoded.pointer) + ", " + ToStr(Scope(constIntVal(decoded.memory))) + ", " + ToStr(MemorySemantics(constIntVal(decoded.semantics))) + ", " + ParamToStr(idName, decoded.value) + ")";
      break;
    }
    case rdcspv::Op::AtomicAnd:
    {
      OpAtomicAnd decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "AtomicAnd(" + ParamToStr(idName, decoded.pointer) + ", " + ToStr(Scope(constIntVal(decoded.memory))) + ", " + ToStr(MemorySemantics(constIntVal(decoded.semantics))) + ", " + ParamToStr(idName, decoded.value) + ")";
      break;
    }
    case rdcspv::Op::AtomicOr:
    {
      OpAtomicOr decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "AtomicOr(" + ParamToStr(idName, decoded.pointer) + ", " + ToStr(Scope(constIntVal(decoded.memory))) + ", " + ToStr(MemorySemantics(constIntVal(decoded.semantics))) + ", " + ParamToStr(idName, decoded.value) + ")";
      break;
    }
    case rdcspv::Op::AtomicXor:
    {
      OpAtomicXor decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "AtomicXor(" + ParamToStr(idName, decoded.pointer) + ", " + ToStr(Scope(constIntVal(decoded.memory))) + ", " + ToStr(MemorySemantics(constIntVal(decoded.semantics))) + ", " + ParamToStr(idName, decoded.value) + ")";
      break;
    }
    case rdcspv::Op::Phi:
    {
      OpPhi decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "Phi(" + ParamsToStr(idName, decoded.parents) + ")";
      break;
    }
    case rdcspv::Op::LoopMerge:
    {
      OpLoopMerge decoded(it);
      ret += "LoopMerge(" + ParamToStr(idName, decoded.mergeBlock) + ", " + ParamToStr(idName, decoded.continueTarget) + ", " + ParamToStr(idName, decoded.loopControl) + ")";
      break;
    }
    case rdcspv::Op::SelectionMerge:
    {
      OpSelectionMerge decoded(it);
      ret += "SelectionMerge(" + ParamToStr(idName, decoded.mergeBlock) + ", " + ParamToStr(idName, decoded.selectionControl) + ")";
      break;
    }
    case rdcspv::Op::Label:
    {
      OpLabel decoded(it);
      ret += idName(decoded.result) + " = ";
      ret += "Label(" ")";
      break;
    }
    case rdcspv::Op::Branch:
    {
      OpBranch decoded(it);
      ret += "Branch(" + ParamToStr(idName, decoded.targetLabel) + ")";
      break;
    }
    case rdcspv::Op::BranchConditional:
    {
      OpBranchConditional decoded(it);
      ret += "BranchConditional(" + ParamToStr(idName, decoded.condition) + ", " + ParamToStr(idName, decoded.trueLabel) + ", " + ParamToStr(idName, decoded.falseLabel) + ", " + ParamsToStr(idName, decoded.branchweights) + ")";
      break;
    }
    case rdcspv::Op::Switch:
    {
      OpSwitch decoded(it);
      ret += "Switch(" + ParamToStr(idName, decoded.selector) + ", " + ParamToStr(idName, decoded.def) + ", " + ParamsToStr(idName, decoded.target) + ")";
      break;
    }
    case rdcspv::Op::Kill:
    {
      OpKill decoded(it);
      ret += "Kill(" ")";
      break;
    }
    case rdcspv::Op::Return:
    {
      OpReturn decoded(it);
      ret += "Return(" ")";
      break;
    }
    case rdcspv::Op::ReturnValue:
    {
      OpReturnValue decoded(it);
      ret += "ReturnValue(" + ParamToStr(idName, decoded.value) + ")";
      break;
    }
    case rdcspv::Op::Unreachable:
    {
      OpUnreachable decoded(it);
      ret += "Unreachable(" ")";
      break;
    }
    case rdcspv::Op::LifetimeStart:
    {
      OpLifetimeStart decoded(it);
      ret += "LifetimeStart(" + ParamToStr(idName, decoded.pointer) + ", " + ParamToStr(idName, decoded.size) + ")";
      break;
    }
    case rdcspv::Op::LifetimeStop:
    {
      OpLifetimeStop decoded(it);
      ret += "LifetimeStop(" + ParamToStr(idName, decoded.pointer) + ", " + ParamToStr(idName, decoded.size) + ")";
      break;
    }
    case rdcspv::Op::GroupAsyncCopy:
    {
      OpGroupAsyncCopy decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "GroupAsyncCopy(" + ToStr(Scope(constIntVal(decoded.execution))) + ", " + ParamToStr(idName, decoded.destination) + ", " + ParamToStr(idName, decoded.source) + ", " + ParamToStr(idName, decoded.numElements) + ", " + ParamToStr(idName, decoded.stride) + ", " + ParamToStr(idName, decoded.event) + ")";
      break;
    }
    case rdcspv::Op::GroupWaitEvents:
    {
      OpGroupWaitEvents decoded(it);
      ret += "GroupWaitEvents(" + ToStr(Scope(constIntVal(decoded.execution))) + ", " + ParamToStr(idName, decoded.numEvents) + ", " + ParamToStr(idName, decoded.eventsList) + ")";
      break;
    }
    case rdcspv::Op::GroupAll:
    {
      OpGroupAll decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "GroupAll(" + ToStr(Scope(constIntVal(decoded.execution))) + ", " + ParamToStr(idName, decoded.predicate) + ")";
      break;
    }
    case rdcspv::Op::GroupAny:
    {
      OpGroupAny decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "GroupAny(" + ToStr(Scope(constIntVal(decoded.execution))) + ", " + ParamToStr(idName, decoded.predicate) + ")";
      break;
    }
    case rdcspv::Op::GroupBroadcast:
    {
      OpGroupBroadcast decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "GroupBroadcast(" + ToStr(Scope(constIntVal(decoded.execution))) + ", " + ParamToStr(idName, decoded.value) + ", " + ParamToStr(idName, decoded.localId) + ")";
      break;
    }
    case rdcspv::Op::GroupIAdd:
    {
      OpGroupIAdd decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "GroupIAdd(" + ToStr(Scope(constIntVal(decoded.execution))) + ", " + ParamToStr(idName, decoded.operation) + ", " + ParamToStr(idName, decoded.x) + ")";
      break;
    }
    case rdcspv::Op::GroupFAdd:
    {
      OpGroupFAdd decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "GroupFAdd(" + ToStr(Scope(constIntVal(decoded.execution))) + ", " + ParamToStr(idName, decoded.operation) + ", " + ParamToStr(idName, decoded.x) + ")";
      break;
    }
    case rdcspv::Op::GroupFMin:
    {
      OpGroupFMin decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "GroupFMin(" + ToStr(Scope(constIntVal(decoded.execution))) + ", " + ParamToStr(idName, decoded.operation) + ", " + ParamToStr(idName, decoded.x) + ")";
      break;
    }
    case rdcspv::Op::GroupUMin:
    {
      OpGroupUMin decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "GroupUMin(" + ToStr(Scope(constIntVal(decoded.execution))) + ", " + ParamToStr(idName, decoded.operation) + ", " + ParamToStr(idName, decoded.x) + ")";
      break;
    }
    case rdcspv::Op::GroupSMin:
    {
      OpGroupSMin decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "GroupSMin(" + ToStr(Scope(constIntVal(decoded.execution))) + ", " + ParamToStr(idName, decoded.operation) + ", " + ParamToStr(idName, decoded.x) + ")";
      break;
    }
    case rdcspv::Op::GroupFMax:
    {
      OpGroupFMax decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "GroupFMax(" + ToStr(Scope(constIntVal(decoded.execution))) + ", " + ParamToStr(idName, decoded.operation) + ", " + ParamToStr(idName, decoded.x) + ")";
      break;
    }
    case rdcspv::Op::GroupUMax:
    {
      OpGroupUMax decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "GroupUMax(" + ToStr(Scope(constIntVal(decoded.execution))) + ", " + ParamToStr(idName, decoded.operation) + ", " + ParamToStr(idName, decoded.x) + ")";
      break;
    }
    case rdcspv::Op::GroupSMax:
    {
      OpGroupSMax decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "GroupSMax(" + ToStr(Scope(constIntVal(decoded.execution))) + ", " + ParamToStr(idName, decoded.operation) + ", " + ParamToStr(idName, decoded.x) + ")";
      break;
    }
    case rdcspv::Op::ReadPipe:
    {
      OpReadPipe decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "ReadPipe(" + ParamToStr(idName, decoded.pipe) + ", " + ParamToStr(idName, decoded.pointer) + ", " + ParamToStr(idName, decoded.packetSize) + ", " + ParamToStr(idName, decoded.packetAlignment) + ")";
      break;
    }
    case rdcspv::Op::WritePipe:
    {
      OpWritePipe decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "WritePipe(" + ParamToStr(idName, decoded.pipe) + ", " + ParamToStr(idName, decoded.pointer) + ", " + ParamToStr(idName, decoded.packetSize) + ", " + ParamToStr(idName, decoded.packetAlignment) + ")";
      break;
    }
    case rdcspv::Op::ReservedReadPipe:
    {
      OpReservedReadPipe decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "ReservedReadPipe(" + ParamToStr(idName, decoded.pipe) + ", " + ParamToStr(idName, decoded.reserveId) + ", " + ParamToStr(idName, decoded.index) + ", " + ParamToStr(idName, decoded.pointer) + ", " + ParamToStr(idName, decoded.packetSize) + ", " + ParamToStr(idName, decoded.packetAlignment) + ")";
      break;
    }
    case rdcspv::Op::ReservedWritePipe:
    {
      OpReservedWritePipe decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "ReservedWritePipe(" + ParamToStr(idName, decoded.pipe) + ", " + ParamToStr(idName, decoded.reserveId) + ", " + ParamToStr(idName, decoded.index) + ", " + ParamToStr(idName, decoded.pointer) + ", " + ParamToStr(idName, decoded.packetSize) + ", " + ParamToStr(idName, decoded.packetAlignment) + ")";
      break;
    }
    case rdcspv::Op::ReserveReadPipePackets:
    {
      OpReserveReadPipePackets decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "ReserveReadPipePackets(" + ParamToStr(idName, decoded.pipe) + ", " + ParamToStr(idName, decoded.numPackets) + ", " + ParamToStr(idName, decoded.packetSize) + ", " + ParamToStr(idName, decoded.packetAlignment) + ")";
      break;
    }
    case rdcspv::Op::ReserveWritePipePackets:
    {
      OpReserveWritePipePackets decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "ReserveWritePipePackets(" + ParamToStr(idName, decoded.pipe) + ", " + ParamToStr(idName, decoded.numPackets) + ", " + ParamToStr(idName, decoded.packetSize) + ", " + ParamToStr(idName, decoded.packetAlignment) + ")";
      break;
    }
    case rdcspv::Op::CommitReadPipe:
    {
      OpCommitReadPipe decoded(it);
      ret += "CommitReadPipe(" + ParamToStr(idName, decoded.pipe) + ", " + ParamToStr(idName, decoded.reserveId) + ", " + ParamToStr(idName, decoded.packetSize) + ", " + ParamToStr(idName, decoded.packetAlignment) + ")";
      break;
    }
    case rdcspv::Op::CommitWritePipe:
    {
      OpCommitWritePipe decoded(it);
      ret += "CommitWritePipe(" + ParamToStr(idName, decoded.pipe) + ", " + ParamToStr(idName, decoded.reserveId) + ", " + ParamToStr(idName, decoded.packetSize) + ", " + ParamToStr(idName, decoded.packetAlignment) + ")";
      break;
    }
    case rdcspv::Op::IsValidReserveId:
    {
      OpIsValidReserveId decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "IsValidReserveId(" + ParamToStr(idName, decoded.reserveId) + ")";
      break;
    }
    case rdcspv::Op::GetNumPipePackets:
    {
      OpGetNumPipePackets decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "GetNumPipePackets(" + ParamToStr(idName, decoded.pipe) + ", " + ParamToStr(idName, decoded.packetSize) + ", " + ParamToStr(idName, decoded.packetAlignment) + ")";
      break;
    }
    case rdcspv::Op::GetMaxPipePackets:
    {
      OpGetMaxPipePackets decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "GetMaxPipePackets(" + ParamToStr(idName, decoded.pipe) + ", " + ParamToStr(idName, decoded.packetSize) + ", " + ParamToStr(idName, decoded.packetAlignment) + ")";
      break;
    }
    case rdcspv::Op::GroupReserveReadPipePackets:
    {
      OpGroupReserveReadPipePackets decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "GroupReserveReadPipePackets(" + ToStr(Scope(constIntVal(decoded.execution))) + ", " + ParamToStr(idName, decoded.pipe) + ", " + ParamToStr(idName, decoded.numPackets) + ", " + ParamToStr(idName, decoded.packetSize) + ", " + ParamToStr(idName, decoded.packetAlignment) + ")";
      break;
    }
    case rdcspv::Op::GroupReserveWritePipePackets:
    {
      OpGroupReserveWritePipePackets decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "GroupReserveWritePipePackets(" + ToStr(Scope(constIntVal(decoded.execution))) + ", " + ParamToStr(idName, decoded.pipe) + ", " + ParamToStr(idName, decoded.numPackets) + ", " + ParamToStr(idName, decoded.packetSize) + ", " + ParamToStr(idName, decoded.packetAlignment) + ")";
      break;
    }
    case rdcspv::Op::GroupCommitReadPipe:
    {
      OpGroupCommitReadPipe decoded(it);
      ret += "GroupCommitReadPipe(" + ToStr(Scope(constIntVal(decoded.execution))) + ", " + ParamToStr(idName, decoded.pipe) + ", " + ParamToStr(idName, decoded.reserveId) + ", " + ParamToStr(idName, decoded.packetSize) + ", " + ParamToStr(idName, decoded.packetAlignment) + ")";
      break;
    }
    case rdcspv::Op::GroupCommitWritePipe:
    {
      OpGroupCommitWritePipe decoded(it);
      ret += "GroupCommitWritePipe(" + ToStr(Scope(constIntVal(decoded.execution))) + ", " + ParamToStr(idName, decoded.pipe) + ", " + ParamToStr(idName, decoded.reserveId) + ", " + ParamToStr(idName, decoded.packetSize) + ", " + ParamToStr(idName, decoded.packetAlignment) + ")";
      break;
    }
    case rdcspv::Op::EnqueueMarker:
    {
      OpEnqueueMarker decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "EnqueueMarker(" + ParamToStr(idName, decoded.queue) + ", " + ParamToStr(idName, decoded.numEvents) + ", " + ParamToStr(idName, decoded.waitEvents) + ", " + ParamToStr(idName, decoded.retEvent) + ")";
      break;
    }
    case rdcspv::Op::EnqueueKernel:
    {
      OpEnqueueKernel decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "EnqueueKernel(" + ParamToStr(idName, decoded.queue) + ", " + ParamToStr(idName, decoded.flags) + ", " + ParamToStr(idName, decoded.nDRange) + ", " + ParamToStr(idName, decoded.numEvents) + ", " + ParamToStr(idName, decoded.waitEvents) + ", " + ParamToStr(idName, decoded.retEvent) + ", " + ParamToStr(idName, decoded.invoke) + ", " + ParamToStr(idName, decoded.param) + ", " + ParamToStr(idName, decoded.paramSize) + ", " + ParamToStr(idName, decoded.paramAlign) + ", " + ParamsToStr(idName, decoded.localSize) + ")";
      break;
    }
    case rdcspv::Op::GetKernelNDrangeSubGroupCount:
    {
      OpGetKernelNDrangeSubGroupCount decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "GetKernelNDrangeSubGroupCount(" + ParamToStr(idName, decoded.nDRange) + ", " + ParamToStr(idName, decoded.invoke) + ", " + ParamToStr(idName, decoded.param) + ", " + ParamToStr(idName, decoded.paramSize) + ", " + ParamToStr(idName, decoded.paramAlign) + ")";
      break;
    }
    case rdcspv::Op::GetKernelNDrangeMaxSubGroupSize:
    {
      OpGetKernelNDrangeMaxSubGroupSize decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "GetKernelNDrangeMaxSubGroupSize(" + ParamToStr(idName, decoded.nDRange) + ", " + ParamToStr(idName, decoded.invoke) + ", " + ParamToStr(idName, decoded.param) + ", " + ParamToStr(idName, decoded.paramSize) + ", " + ParamToStr(idName, decoded.paramAlign) + ")";
      break;
    }
    case rdcspv::Op::GetKernelWorkGroupSize:
    {
      OpGetKernelWorkGroupSize decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "GetKernelWorkGroupSize(" + ParamToStr(idName, decoded.invoke) + ", " + ParamToStr(idName, decoded.param) + ", " + ParamToStr(idName, decoded.paramSize) + ", " + ParamToStr(idName, decoded.paramAlign) + ")";
      break;
    }
    case rdcspv::Op::GetKernelPreferredWorkGroupSizeMultiple:
    {
      OpGetKernelPreferredWorkGroupSizeMultiple decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "GetKernelPreferredWorkGroupSizeMultiple(" + ParamToStr(idName, decoded.invoke) + ", " + ParamToStr(idName, decoded.param) + ", " + ParamToStr(idName, decoded.paramSize) + ", " + ParamToStr(idName, decoded.paramAlign) + ")";
      break;
    }
    case rdcspv::Op::RetainEvent:
    {
      OpRetainEvent decoded(it);
      ret += "RetainEvent(" + ParamToStr(idName, decoded.event) + ")";
      break;
    }
    case rdcspv::Op::ReleaseEvent:
    {
      OpReleaseEvent decoded(it);
      ret += "ReleaseEvent(" + ParamToStr(idName, decoded.event) + ")";
      break;
    }
    case rdcspv::Op::CreateUserEvent:
    {
      OpCreateUserEvent decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "CreateUserEvent(" ")";
      break;
    }
    case rdcspv::Op::IsValidEvent:
    {
      OpIsValidEvent decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "IsValidEvent(" + ParamToStr(idName, decoded.event) + ")";
      break;
    }
    case rdcspv::Op::SetUserEventStatus:
    {
      OpSetUserEventStatus decoded(it);
      ret += "SetUserEventStatus(" + ParamToStr(idName, decoded.event) + ", " + ParamToStr(idName, decoded.status) + ")";
      break;
    }
    case rdcspv::Op::CaptureEventProfilingInfo:
    {
      OpCaptureEventProfilingInfo decoded(it);
      ret += "CaptureEventProfilingInfo(" + ParamToStr(idName, decoded.event) + ", " + ParamToStr(idName, decoded.profilingInfo) + ", " + ParamToStr(idName, decoded.value) + ")";
      break;
    }
    case rdcspv::Op::GetDefaultQueue:
    {
      OpGetDefaultQueue decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "GetDefaultQueue(" ")";
      break;
    }
    case rdcspv::Op::BuildNDRange:
    {
      OpBuildNDRange decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "BuildNDRange(" + ParamToStr(idName, decoded.globalWorkSize) + ", " + ParamToStr(idName, decoded.localWorkSize) + ", " + ParamToStr(idName, decoded.globalWorkOffset) + ")";
      break;
    }
    case rdcspv::Op::ImageSparseSampleImplicitLod:
    {
      OpImageSparseSampleImplicitLod decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "ImageSparseSampleImplicitLod(" + ParamToStr(idName, decoded.sampledImage) + ", " + ParamToStr(idName, decoded.coordinate) + ", " + ParamToStr(idName, decoded.imageOperands) + ")";
      break;
    }
    case rdcspv::Op::ImageSparseSampleExplicitLod:
    {
      OpImageSparseSampleExplicitLod decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "ImageSparseSampleExplicitLod(" + ParamToStr(idName, decoded.sampledImage) + ", " + ParamToStr(idName, decoded.coordinate) + ", " + ParamToStr(idName, decoded.imageOperands) + ")";
      break;
    }
    case rdcspv::Op::ImageSparseSampleDrefImplicitLod:
    {
      OpImageSparseSampleDrefImplicitLod decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "ImageSparseSampleDrefImplicitLod(" + ParamToStr(idName, decoded.sampledImage) + ", " + ParamToStr(idName, decoded.coordinate) + ", " + ParamToStr(idName, decoded.dref) + ", " + ParamToStr(idName, decoded.imageOperands) + ")";
      break;
    }
    case rdcspv::Op::ImageSparseSampleDrefExplicitLod:
    {
      OpImageSparseSampleDrefExplicitLod decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "ImageSparseSampleDrefExplicitLod(" + ParamToStr(idName, decoded.sampledImage) + ", " + ParamToStr(idName, decoded.coordinate) + ", " + ParamToStr(idName, decoded.dref) + ", " + ParamToStr(idName, decoded.imageOperands) + ")";
      break;
    }
    case rdcspv::Op::ImageSparseSampleProjImplicitLod:
    {
      OpImageSparseSampleProjImplicitLod decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "ImageSparseSampleProjImplicitLod(" + ParamToStr(idName, decoded.sampledImage) + ", " + ParamToStr(idName, decoded.coordinate) + ", " + ParamToStr(idName, decoded.imageOperands) + ")";
      break;
    }
    case rdcspv::Op::ImageSparseSampleProjExplicitLod:
    {
      OpImageSparseSampleProjExplicitLod decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "ImageSparseSampleProjExplicitLod(" + ParamToStr(idName, decoded.sampledImage) + ", " + ParamToStr(idName, decoded.coordinate) + ", " + ParamToStr(idName, decoded.imageOperands) + ")";
      break;
    }
    case rdcspv::Op::ImageSparseSampleProjDrefImplicitLod:
    {
      OpImageSparseSampleProjDrefImplicitLod decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "ImageSparseSampleProjDrefImplicitLod(" + ParamToStr(idName, decoded.sampledImage) + ", " + ParamToStr(idName, decoded.coordinate) + ", " + ParamToStr(idName, decoded.dref) + ", " + ParamToStr(idName, decoded.imageOperands) + ")";
      break;
    }
    case rdcspv::Op::ImageSparseSampleProjDrefExplicitLod:
    {
      OpImageSparseSampleProjDrefExplicitLod decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "ImageSparseSampleProjDrefExplicitLod(" + ParamToStr(idName, decoded.sampledImage) + ", " + ParamToStr(idName, decoded.coordinate) + ", " + ParamToStr(idName, decoded.dref) + ", " + ParamToStr(idName, decoded.imageOperands) + ")";
      break;
    }
    case rdcspv::Op::ImageSparseFetch:
    {
      OpImageSparseFetch decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "ImageSparseFetch(" + ParamToStr(idName, decoded.image) + ", " + ParamToStr(idName, decoded.coordinate) + ", " + ParamToStr(idName, decoded.imageOperands) + ")";
      break;
    }
    case rdcspv::Op::ImageSparseGather:
    {
      OpImageSparseGather decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "ImageSparseGather(" + ParamToStr(idName, decoded.sampledImage) + ", " + ParamToStr(idName, decoded.coordinate) + ", " + ParamToStr(idName, decoded.component) + ", " + ParamToStr(idName, decoded.imageOperands) + ")";
      break;
    }
    case rdcspv::Op::ImageSparseDrefGather:
    {
      OpImageSparseDrefGather decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "ImageSparseDrefGather(" + ParamToStr(idName, decoded.sampledImage) + ", " + ParamToStr(idName, decoded.coordinate) + ", " + ParamToStr(idName, decoded.dref) + ", " + ParamToStr(idName, decoded.imageOperands) + ")";
      break;
    }
    case rdcspv::Op::ImageSparseTexelsResident:
    {
      OpImageSparseTexelsResident decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "ImageSparseTexelsResident(" + ParamToStr(idName, decoded.residentCode) + ")";
      break;
    }
    case rdcspv::Op::NoLine:
    {
      OpNoLine decoded(it);
      ret += "NoLine(" ")";
      break;
    }
    case rdcspv::Op::AtomicFlagTestAndSet:
    {
      OpAtomicFlagTestAndSet decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "AtomicFlagTestAndSet(" + ParamToStr(idName, decoded.pointer) + ", " + ToStr(Scope(constIntVal(decoded.memory))) + ", " + ToStr(MemorySemantics(constIntVal(decoded.semantics))) + ")";
      break;
    }
    case rdcspv::Op::AtomicFlagClear:
    {
      OpAtomicFlagClear decoded(it);
      ret += "AtomicFlagClear(" + ParamToStr(idName, decoded.pointer) + ", " + ToStr(Scope(constIntVal(decoded.memory))) + ", " + ToStr(MemorySemantics(constIntVal(decoded.semantics))) + ")";
      break;
    }
    case rdcspv::Op::ImageSparseRead:
    {
      OpImageSparseRead decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "ImageSparseRead(" + ParamToStr(idName, decoded.image) + ", " + ParamToStr(idName, decoded.coordinate) + ", " + ParamToStr(idName, decoded.imageOperands) + ")";
      break;
    }
    case rdcspv::Op::SizeOf:
    {
      OpSizeOf decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "SizeOf(" + ParamToStr(idName, decoded.pointer) + ")";
      break;
    }
    case rdcspv::Op::TypePipeStorage:
    {
      OpTypePipeStorage decoded(it);
      ret += idName(decoded.result) + " = ";
      ret += "TypePipeStorage(" ")";
      break;
    }
    case rdcspv::Op::ConstantPipeStorage:
    {
      OpConstantPipeStorage decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "ConstantPipeStorage(" + ParamToStr(idName, decoded.packetSize) + ", " + ParamToStr(idName, decoded.packetAlignment) + ", " + ParamToStr(idName, decoded.capacity) + ")";
      break;
    }
    case rdcspv::Op::CreatePipeFromPipeStorage:
    {
      OpCreatePipeFromPipeStorage decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "CreatePipeFromPipeStorage(" + ParamToStr(idName, decoded.pipeStorage) + ")";
      break;
    }
    case rdcspv::Op::GetKernelLocalSizeForSubgroupCount:
    {
      OpGetKernelLocalSizeForSubgroupCount decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "GetKernelLocalSizeForSubgroupCount(" + ParamToStr(idName, decoded.subgroupCount) + ", " + ParamToStr(idName, decoded.invoke) + ", " + ParamToStr(idName, decoded.param) + ", " + ParamToStr(idName, decoded.paramSize) + ", " + ParamToStr(idName, decoded.paramAlign) + ")";
      break;
    }
    case rdcspv::Op::GetKernelMaxNumSubgroups:
    {
      OpGetKernelMaxNumSubgroups decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "GetKernelMaxNumSubgroups(" + ParamToStr(idName, decoded.invoke) + ", " + ParamToStr(idName, decoded.param) + ", " + ParamToStr(idName, decoded.paramSize) + ", " + ParamToStr(idName, decoded.paramAlign) + ")";
      break;
    }
    case rdcspv::Op::TypeNamedBarrier:
    {
      OpTypeNamedBarrier decoded(it);
      ret += idName(decoded.result) + " = ";
      ret += "TypeNamedBarrier(" ")";
      break;
    }
    case rdcspv::Op::NamedBarrierInitialize:
    {
      OpNamedBarrierInitialize decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "NamedBarrierInitialize(" + ParamToStr(idName, decoded.subgroupCount) + ")";
      break;
    }
    case rdcspv::Op::MemoryNamedBarrier:
    {
      OpMemoryNamedBarrier decoded(it);
      ret += "MemoryNamedBarrier(" + ParamToStr(idName, decoded.namedBarrier) + ", " + ToStr(Scope(constIntVal(decoded.memory))) + ", " + ToStr(MemorySemantics(constIntVal(decoded.semantics))) + ")";
      break;
    }
    case rdcspv::Op::ModuleProcessed:
    {
      OpModuleProcessed decoded(it);
      ret += "ModuleProcessed(" + ParamToStr(idName, decoded.process) + ")";
      break;
    }
    case rdcspv::Op::ExecutionModeId:
    {
      OpExecutionModeId decoded(it);
      ret += "ExecutionModeId(" + ParamToStr(idName, decoded.entryPoint) + ", " + ParamToStr(idName, decoded.mode) + ")";
      break;
    }
    case rdcspv::Op::DecorateId:
    {
      OpDecorateId decoded(it);
      ret += "DecorateId(" + ParamToStr(idName, decoded.target) + ", " + ParamToStr(idName, decoded.decoration) + ")";
      break;
    }
    case rdcspv::Op::GroupNonUniformElect:
    {
      OpGroupNonUniformElect decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "GroupNonUniformElect(" + ToStr(Scope(constIntVal(decoded.execution))) + ")";
      break;
    }
    case rdcspv::Op::GroupNonUniformAll:
    {
      OpGroupNonUniformAll decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "GroupNonUniformAll(" + ToStr(Scope(constIntVal(decoded.execution))) + ", " + ParamToStr(idName, decoded.predicate) + ")";
      break;
    }
    case rdcspv::Op::GroupNonUniformAny:
    {
      OpGroupNonUniformAny decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "GroupNonUniformAny(" + ToStr(Scope(constIntVal(decoded.execution))) + ", " + ParamToStr(idName, decoded.predicate) + ")";
      break;
    }
    case rdcspv::Op::GroupNonUniformAllEqual:
    {
      OpGroupNonUniformAllEqual decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "GroupNonUniformAllEqual(" + ToStr(Scope(constIntVal(decoded.execution))) + ", " + ParamToStr(idName, decoded.value) + ")";
      break;
    }
    case rdcspv::Op::GroupNonUniformBroadcast:
    {
      OpGroupNonUniformBroadcast decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "GroupNonUniformBroadcast(" + ToStr(Scope(constIntVal(decoded.execution))) + ", " + ParamToStr(idName, decoded.value) + ", " + ParamToStr(idName, decoded.id) + ")";
      break;
    }
    case rdcspv::Op::GroupNonUniformBroadcastFirst:
    {
      OpGroupNonUniformBroadcastFirst decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "GroupNonUniformBroadcastFirst(" + ToStr(Scope(constIntVal(decoded.execution))) + ", " + ParamToStr(idName, decoded.value) + ")";
      break;
    }
    case rdcspv::Op::GroupNonUniformBallot:
    {
      OpGroupNonUniformBallot decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "GroupNonUniformBallot(" + ToStr(Scope(constIntVal(decoded.execution))) + ", " + ParamToStr(idName, decoded.predicate) + ")";
      break;
    }
    case rdcspv::Op::GroupNonUniformInverseBallot:
    {
      OpGroupNonUniformInverseBallot decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "GroupNonUniformInverseBallot(" + ToStr(Scope(constIntVal(decoded.execution))) + ", " + ParamToStr(idName, decoded.value) + ")";
      break;
    }
    case rdcspv::Op::GroupNonUniformBallotBitExtract:
    {
      OpGroupNonUniformBallotBitExtract decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "GroupNonUniformBallotBitExtract(" + ToStr(Scope(constIntVal(decoded.execution))) + ", " + ParamToStr(idName, decoded.value) + ", " + ParamToStr(idName, decoded.index) + ")";
      break;
    }
    case rdcspv::Op::GroupNonUniformBallotBitCount:
    {
      OpGroupNonUniformBallotBitCount decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "GroupNonUniformBallotBitCount(" + ToStr(Scope(constIntVal(decoded.execution))) + ", " + ParamToStr(idName, decoded.operation) + ", " + ParamToStr(idName, decoded.value) + ")";
      break;
    }
    case rdcspv::Op::GroupNonUniformBallotFindLSB:
    {
      OpGroupNonUniformBallotFindLSB decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "GroupNonUniformBallotFindLSB(" + ToStr(Scope(constIntVal(decoded.execution))) + ", " + ParamToStr(idName, decoded.value) + ")";
      break;
    }
    case rdcspv::Op::GroupNonUniformBallotFindMSB:
    {
      OpGroupNonUniformBallotFindMSB decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "GroupNonUniformBallotFindMSB(" + ToStr(Scope(constIntVal(decoded.execution))) + ", " + ParamToStr(idName, decoded.value) + ")";
      break;
    }
    case rdcspv::Op::GroupNonUniformShuffle:
    {
      OpGroupNonUniformShuffle decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "GroupNonUniformShuffle(" + ToStr(Scope(constIntVal(decoded.execution))) + ", " + ParamToStr(idName, decoded.value) + ", " + ParamToStr(idName, decoded.id) + ")";
      break;
    }
    case rdcspv::Op::GroupNonUniformShuffleXor:
    {
      OpGroupNonUniformShuffleXor decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "GroupNonUniformShuffleXor(" + ToStr(Scope(constIntVal(decoded.execution))) + ", " + ParamToStr(idName, decoded.value) + ", " + ParamToStr(idName, decoded.mask) + ")";
      break;
    }
    case rdcspv::Op::GroupNonUniformShuffleUp:
    {
      OpGroupNonUniformShuffleUp decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "GroupNonUniformShuffleUp(" + ToStr(Scope(constIntVal(decoded.execution))) + ", " + ParamToStr(idName, decoded.value) + ", " + ParamToStr(idName, decoded.delta) + ")";
      break;
    }
    case rdcspv::Op::GroupNonUniformShuffleDown:
    {
      OpGroupNonUniformShuffleDown decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "GroupNonUniformShuffleDown(" + ToStr(Scope(constIntVal(decoded.execution))) + ", " + ParamToStr(idName, decoded.value) + ", " + ParamToStr(idName, decoded.delta) + ")";
      break;
    }
    case rdcspv::Op::GroupNonUniformIAdd:
    {
      OpGroupNonUniformIAdd decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "GroupNonUniformIAdd(" + ToStr(Scope(constIntVal(decoded.execution))) + ", " + ParamToStr(idName, decoded.operation) + ", " + ParamToStr(idName, decoded.value) + ", " + ParamToStr(idName, decoded.clusterSize) + ")";
      break;
    }
    case rdcspv::Op::GroupNonUniformFAdd:
    {
      OpGroupNonUniformFAdd decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "GroupNonUniformFAdd(" + ToStr(Scope(constIntVal(decoded.execution))) + ", " + ParamToStr(idName, decoded.operation) + ", " + ParamToStr(idName, decoded.value) + ", " + ParamToStr(idName, decoded.clusterSize) + ")";
      break;
    }
    case rdcspv::Op::GroupNonUniformIMul:
    {
      OpGroupNonUniformIMul decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "GroupNonUniformIMul(" + ToStr(Scope(constIntVal(decoded.execution))) + ", " + ParamToStr(idName, decoded.operation) + ", " + ParamToStr(idName, decoded.value) + ", " + ParamToStr(idName, decoded.clusterSize) + ")";
      break;
    }
    case rdcspv::Op::GroupNonUniformFMul:
    {
      OpGroupNonUniformFMul decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "GroupNonUniformFMul(" + ToStr(Scope(constIntVal(decoded.execution))) + ", " + ParamToStr(idName, decoded.operation) + ", " + ParamToStr(idName, decoded.value) + ", " + ParamToStr(idName, decoded.clusterSize) + ")";
      break;
    }
    case rdcspv::Op::GroupNonUniformSMin:
    {
      OpGroupNonUniformSMin decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "GroupNonUniformSMin(" + ToStr(Scope(constIntVal(decoded.execution))) + ", " + ParamToStr(idName, decoded.operation) + ", " + ParamToStr(idName, decoded.value) + ", " + ParamToStr(idName, decoded.clusterSize) + ")";
      break;
    }
    case rdcspv::Op::GroupNonUniformUMin:
    {
      OpGroupNonUniformUMin decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "GroupNonUniformUMin(" + ToStr(Scope(constIntVal(decoded.execution))) + ", " + ParamToStr(idName, decoded.operation) + ", " + ParamToStr(idName, decoded.value) + ", " + ParamToStr(idName, decoded.clusterSize) + ")";
      break;
    }
    case rdcspv::Op::GroupNonUniformFMin:
    {
      OpGroupNonUniformFMin decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "GroupNonUniformFMin(" + ToStr(Scope(constIntVal(decoded.execution))) + ", " + ParamToStr(idName, decoded.operation) + ", " + ParamToStr(idName, decoded.value) + ", " + ParamToStr(idName, decoded.clusterSize) + ")";
      break;
    }
    case rdcspv::Op::GroupNonUniformSMax:
    {
      OpGroupNonUniformSMax decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "GroupNonUniformSMax(" + ToStr(Scope(constIntVal(decoded.execution))) + ", " + ParamToStr(idName, decoded.operation) + ", " + ParamToStr(idName, decoded.value) + ", " + ParamToStr(idName, decoded.clusterSize) + ")";
      break;
    }
    case rdcspv::Op::GroupNonUniformUMax:
    {
      OpGroupNonUniformUMax decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "GroupNonUniformUMax(" + ToStr(Scope(constIntVal(decoded.execution))) + ", " + ParamToStr(idName, decoded.operation) + ", " + ParamToStr(idName, decoded.value) + ", " + ParamToStr(idName, decoded.clusterSize) + ")";
      break;
    }
    case rdcspv::Op::GroupNonUniformFMax:
    {
      OpGroupNonUniformFMax decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "GroupNonUniformFMax(" + ToStr(Scope(constIntVal(decoded.execution))) + ", " + ParamToStr(idName, decoded.operation) + ", " + ParamToStr(idName, decoded.value) + ", " + ParamToStr(idName, decoded.clusterSize) + ")";
      break;
    }
    case rdcspv::Op::GroupNonUniformBitwiseAnd:
    {
      OpGroupNonUniformBitwiseAnd decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "GroupNonUniformBitwiseAnd(" + ToStr(Scope(constIntVal(decoded.execution))) + ", " + ParamToStr(idName, decoded.operation) + ", " + ParamToStr(idName, decoded.value) + ", " + ParamToStr(idName, decoded.clusterSize) + ")";
      break;
    }
    case rdcspv::Op::GroupNonUniformBitwiseOr:
    {
      OpGroupNonUniformBitwiseOr decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "GroupNonUniformBitwiseOr(" + ToStr(Scope(constIntVal(decoded.execution))) + ", " + ParamToStr(idName, decoded.operation) + ", " + ParamToStr(idName, decoded.value) + ", " + ParamToStr(idName, decoded.clusterSize) + ")";
      break;
    }
    case rdcspv::Op::GroupNonUniformBitwiseXor:
    {
      OpGroupNonUniformBitwiseXor decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "GroupNonUniformBitwiseXor(" + ToStr(Scope(constIntVal(decoded.execution))) + ", " + ParamToStr(idName, decoded.operation) + ", " + ParamToStr(idName, decoded.value) + ", " + ParamToStr(idName, decoded.clusterSize) + ")";
      break;
    }
    case rdcspv::Op::GroupNonUniformLogicalAnd:
    {
      OpGroupNonUniformLogicalAnd decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "GroupNonUniformLogicalAnd(" + ToStr(Scope(constIntVal(decoded.execution))) + ", " + ParamToStr(idName, decoded.operation) + ", " + ParamToStr(idName, decoded.value) + ", " + ParamToStr(idName, decoded.clusterSize) + ")";
      break;
    }
    case rdcspv::Op::GroupNonUniformLogicalOr:
    {
      OpGroupNonUniformLogicalOr decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "GroupNonUniformLogicalOr(" + ToStr(Scope(constIntVal(decoded.execution))) + ", " + ParamToStr(idName, decoded.operation) + ", " + ParamToStr(idName, decoded.value) + ", " + ParamToStr(idName, decoded.clusterSize) + ")";
      break;
    }
    case rdcspv::Op::GroupNonUniformLogicalXor:
    {
      OpGroupNonUniformLogicalXor decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "GroupNonUniformLogicalXor(" + ToStr(Scope(constIntVal(decoded.execution))) + ", " + ParamToStr(idName, decoded.operation) + ", " + ParamToStr(idName, decoded.value) + ", " + ParamToStr(idName, decoded.clusterSize) + ")";
      break;
    }
    case rdcspv::Op::GroupNonUniformQuadBroadcast:
    {
      OpGroupNonUniformQuadBroadcast decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "GroupNonUniformQuadBroadcast(" + ToStr(Scope(constIntVal(decoded.execution))) + ", " + ParamToStr(idName, decoded.value) + ", " + ParamToStr(idName, decoded.index) + ")";
      break;
    }
    case rdcspv::Op::GroupNonUniformQuadSwap:
    {
      OpGroupNonUniformQuadSwap decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "GroupNonUniformQuadSwap(" + ToStr(Scope(constIntVal(decoded.execution))) + ", " + ParamToStr(idName, decoded.value) + ", " + ParamToStr(idName, decoded.direction) + ")";
      break;
    }
    case rdcspv::Op::CopyLogical:
    {
      OpCopyLogical decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "CopyLogical(" + ParamToStr(idName, decoded.operand) + ")";
      break;
    }
    case rdcspv::Op::PtrEqual:
    {
      OpPtrEqual decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "PtrEqual(" + ParamToStr(idName, decoded.operand1) + ", " + ParamToStr(idName, decoded.operand2) + ")";
      break;
    }
    case rdcspv::Op::PtrNotEqual:
    {
      OpPtrNotEqual decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "PtrNotEqual(" + ParamToStr(idName, decoded.operand1) + ", " + ParamToStr(idName, decoded.operand2) + ")";
      break;
    }
    case rdcspv::Op::PtrDiff:
    {
      OpPtrDiff decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "PtrDiff(" + ParamToStr(idName, decoded.operand1) + ", " + ParamToStr(idName, decoded.operand2) + ")";
      break;
    }
    case rdcspv::Op::TerminateInvocation:
    {
      OpTerminateInvocation decoded(it);
      ret += "TerminateInvocation(" ")";
      break;
    }
    case rdcspv::Op::SubgroupBallotKHR:
    {
      OpSubgroupBallotKHR decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "SubgroupBallotKHR(" + ParamToStr(idName, decoded.predicate) + ")";
      break;
    }
    case rdcspv::Op::SubgroupFirstInvocationKHR:
    {
      OpSubgroupFirstInvocationKHR decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "SubgroupFirstInvocationKHR(" + ParamToStr(idName, decoded.value) + ")";
      break;
    }
    case rdcspv::Op::SubgroupAllKHR:
    {
      OpSubgroupAllKHR decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "SubgroupAllKHR(" + ParamToStr(idName, decoded.predicate) + ")";
      break;
    }
    case rdcspv::Op::SubgroupAnyKHR:
    {
      OpSubgroupAnyKHR decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "SubgroupAnyKHR(" + ParamToStr(idName, decoded.predicate) + ")";
      break;
    }
    case rdcspv::Op::SubgroupAllEqualKHR:
    {
      OpSubgroupAllEqualKHR decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "SubgroupAllEqualKHR(" + ParamToStr(idName, decoded.predicate) + ")";
      break;
    }
    case rdcspv::Op::SubgroupReadInvocationKHR:
    {
      OpSubgroupReadInvocationKHR decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "SubgroupReadInvocationKHR(" + ParamToStr(idName, decoded.value) + ", " + ParamToStr(idName, decoded.index) + ")";
      break;
    }
    case rdcspv::Op::TraceRayKHR:
    {
      OpTraceRayKHR decoded(it);
      ret += "TraceRayKHR(" + ParamToStr(idName, decoded.accel) + ", " + ParamToStr(idName, decoded.rayFlags) + ", " + ParamToStr(idName, decoded.cullMask) + ", " + ParamToStr(idName, decoded.sBTOffset) + ", " + ParamToStr(idName, decoded.sBTStride) + ", " + ParamToStr(idName, decoded.missIndex) + ", " + ParamToStr(idName, decoded.rayOrigin) + ", " + ParamToStr(idName, decoded.rayTmin) + ", " + ParamToStr(idName, decoded.rayDirection) + ", " + ParamToStr(idName, decoded.rayTmax) + ", " + ParamToStr(idName, decoded.payload) + ")";
      break;
    }
    case rdcspv::Op::ExecuteCallableKHR:
    {
      OpExecuteCallableKHR decoded(it);
      ret += "ExecuteCallableKHR(" + ParamToStr(idName, decoded.sBTIndex) + ", " + ParamToStr(idName, decoded.callableData) + ")";
      break;
    }
    case rdcspv::Op::ConvertUToAccelerationStructureKHR:
    {
      OpConvertUToAccelerationStructureKHR decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "ConvertUToAccelerationStructureKHR(" + ParamToStr(idName, decoded.accel) + ")";
      break;
    }
    case rdcspv::Op::IgnoreIntersectionKHR:
    {
      OpIgnoreIntersectionKHR decoded(it);
      ret += "IgnoreIntersectionKHR(" ")";
      break;
    }
    case rdcspv::Op::TerminateRayKHR:
    {
      OpTerminateRayKHR decoded(it);
      ret += "TerminateRayKHR(" ")";
      break;
    }
    case rdcspv::Op::TypeRayQueryKHR:
    {
      OpTypeRayQueryKHR decoded(it);
      ret += idName(decoded.result) + " = ";
      ret += "TypeRayQueryKHR(" ")";
      break;
    }
    case rdcspv::Op::RayQueryInitializeKHR:
    {
      OpRayQueryInitializeKHR decoded(it);
      ret += "RayQueryInitializeKHR(" + ParamToStr(idName, decoded.rayQuery) + ", " + ParamToStr(idName, decoded.accel) + ", " + ParamToStr(idName, decoded.rayFlags) + ", " + ParamToStr(idName, decoded.cullMask) + ", " + ParamToStr(idName, decoded.rayOrigin) + ", " + ParamToStr(idName, decoded.rayTMin) + ", " + ParamToStr(idName, decoded.rayDirection) + ", " + ParamToStr(idName, decoded.rayTMax) + ")";
      break;
    }
    case rdcspv::Op::RayQueryTerminateKHR:
    {
      OpRayQueryTerminateKHR decoded(it);
      ret += "RayQueryTerminateKHR(" + ParamToStr(idName, decoded.rayQuery) + ")";
      break;
    }
    case rdcspv::Op::RayQueryGenerateIntersectionKHR:
    {
      OpRayQueryGenerateIntersectionKHR decoded(it);
      ret += "RayQueryGenerateIntersectionKHR(" + ParamToStr(idName, decoded.rayQuery) + ", " + ParamToStr(idName, decoded.hitT) + ")";
      break;
    }
    case rdcspv::Op::RayQueryConfirmIntersectionKHR:
    {
      OpRayQueryConfirmIntersectionKHR decoded(it);
      ret += "RayQueryConfirmIntersectionKHR(" + ParamToStr(idName, decoded.rayQuery) + ")";
      break;
    }
    case rdcspv::Op::RayQueryProceedKHR:
    {
      OpRayQueryProceedKHR decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "RayQueryProceedKHR(" + ParamToStr(idName, decoded.rayQuery) + ")";
      break;
    }
    case rdcspv::Op::RayQueryGetIntersectionTypeKHR:
    {
      OpRayQueryGetIntersectionTypeKHR decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "RayQueryGetIntersectionTypeKHR(" + ParamToStr(idName, decoded.rayQuery) + ", " + ParamToStr(idName, decoded.intersection) + ")";
      break;
    }
    case rdcspv::Op::GroupIAddNonUniformAMD:
    {
      OpGroupIAddNonUniformAMD decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "GroupIAddNonUniformAMD(" + ToStr(Scope(constIntVal(decoded.execution))) + ", " + ParamToStr(idName, decoded.operation) + ", " + ParamToStr(idName, decoded.x) + ")";
      break;
    }
    case rdcspv::Op::GroupFAddNonUniformAMD:
    {
      OpGroupFAddNonUniformAMD decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "GroupFAddNonUniformAMD(" + ToStr(Scope(constIntVal(decoded.execution))) + ", " + ParamToStr(idName, decoded.operation) + ", " + ParamToStr(idName, decoded.x) + ")";
      break;
    }
    case rdcspv::Op::GroupFMinNonUniformAMD:
    {
      OpGroupFMinNonUniformAMD decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "GroupFMinNonUniformAMD(" + ToStr(Scope(constIntVal(decoded.execution))) + ", " + ParamToStr(idName, decoded.operation) + ", " + ParamToStr(idName, decoded.x) + ")";
      break;
    }
    case rdcspv::Op::GroupUMinNonUniformAMD:
    {
      OpGroupUMinNonUniformAMD decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "GroupUMinNonUniformAMD(" + ToStr(Scope(constIntVal(decoded.execution))) + ", " + ParamToStr(idName, decoded.operation) + ", " + ParamToStr(idName, decoded.x) + ")";
      break;
    }
    case rdcspv::Op::GroupSMinNonUniformAMD:
    {
      OpGroupSMinNonUniformAMD decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "GroupSMinNonUniformAMD(" + ToStr(Scope(constIntVal(decoded.execution))) + ", " + ParamToStr(idName, decoded.operation) + ", " + ParamToStr(idName, decoded.x) + ")";
      break;
    }
    case rdcspv::Op::GroupFMaxNonUniformAMD:
    {
      OpGroupFMaxNonUniformAMD decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "GroupFMaxNonUniformAMD(" + ToStr(Scope(constIntVal(decoded.execution))) + ", " + ParamToStr(idName, decoded.operation) + ", " + ParamToStr(idName, decoded.x) + ")";
      break;
    }
    case rdcspv::Op::GroupUMaxNonUniformAMD:
    {
      OpGroupUMaxNonUniformAMD decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "GroupUMaxNonUniformAMD(" + ToStr(Scope(constIntVal(decoded.execution))) + ", " + ParamToStr(idName, decoded.operation) + ", " + ParamToStr(idName, decoded.x) + ")";
      break;
    }
    case rdcspv::Op::GroupSMaxNonUniformAMD:
    {
      OpGroupSMaxNonUniformAMD decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "GroupSMaxNonUniformAMD(" + ToStr(Scope(constIntVal(decoded.execution))) + ", " + ParamToStr(idName, decoded.operation) + ", " + ParamToStr(idName, decoded.x) + ")";
      break;
    }
    case rdcspv::Op::FragmentMaskFetchAMD:
    {
      OpFragmentMaskFetchAMD decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "FragmentMaskFetchAMD(" + ParamToStr(idName, decoded.image) + ", " + ParamToStr(idName, decoded.coordinate) + ")";
      break;
    }
    case rdcspv::Op::FragmentFetchAMD:
    {
      OpFragmentFetchAMD decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "FragmentFetchAMD(" + ParamToStr(idName, decoded.image) + ", " + ParamToStr(idName, decoded.coordinate) + ", " + ParamToStr(idName, decoded.fragmentIndex) + ")";
      break;
    }
    case rdcspv::Op::ReadClockKHR:
    {
      OpReadClockKHR decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "ReadClockKHR(" + ToStr(Scope(constIntVal(decoded.execution))) + ")";
      break;
    }
    case rdcspv::Op::ImageSampleFootprintNV:
    {
      OpImageSampleFootprintNV decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "ImageSampleFootprintNV(" + ParamToStr(idName, decoded.sampledImage) + ", " + ParamToStr(idName, decoded.coordinate) + ", " + ParamToStr(idName, decoded.granularity) + ", " + ParamToStr(idName, decoded.coarse) + ", " + ParamToStr(idName, decoded.imageOperands) + ")";
      break;
    }
    case rdcspv::Op::GroupNonUniformPartitionNV:
    {
      OpGroupNonUniformPartitionNV decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "GroupNonUniformPartitionNV(" + ParamToStr(idName, decoded.value) + ")";
      break;
    }
    case rdcspv::Op::WritePackedPrimitiveIndices4x8NV:
    {
      OpWritePackedPrimitiveIndices4x8NV decoded(it);
      ret += "WritePackedPrimitiveIndices4x8NV(" + ParamToStr(idName, decoded.indexOffset) + ", " + ParamToStr(idName, decoded.packedIndices) + ")";
      break;
    }
    case rdcspv::Op::ReportIntersectionNV:
    {
      OpReportIntersectionNV decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "ReportIntersectionNV(" + ParamToStr(idName, decoded.hit) + ", " + ParamToStr(idName, decoded.hitKind) + ")";
      break;
    }
    case rdcspv::Op::IgnoreIntersectionNV:
    {
      OpIgnoreIntersectionNV decoded(it);
      ret += "IgnoreIntersectionNV(" ")";
      break;
    }
    case rdcspv::Op::TerminateRayNV:
    {
      OpTerminateRayNV decoded(it);
      ret += "TerminateRayNV(" ")";
      break;
    }
    case rdcspv::Op::TraceNV:
    {
      OpTraceNV decoded(it);
      ret += "TraceNV(" + ParamToStr(idName, decoded.accel) + ", " + ParamToStr(idName, decoded.rayFlags) + ", " + ParamToStr(idName, decoded.cullMask) + ", " + ParamToStr(idName, decoded.sBTOffset) + ", " + ParamToStr(idName, decoded.sBTStride) + ", " + ParamToStr(idName, decoded.missIndex) + ", " + ParamToStr(idName, decoded.rayOrigin) + ", " + ParamToStr(idName, decoded.rayTmin) + ", " + ParamToStr(idName, decoded.rayDirection) + ", " + ParamToStr(idName, decoded.rayTmax) + ", " + ParamToStr(idName, decoded.payloadId) + ")";
      break;
    }
    case rdcspv::Op::TypeAccelerationStructureNV:
    {
      OpTypeAccelerationStructureNV decoded(it);
      ret += idName(decoded.result) + " = ";
      ret += "TypeAccelerationStructureNV(" ")";
      break;
    }
    case rdcspv::Op::ExecuteCallableNV:
    {
      OpExecuteCallableNV decoded(it);
      ret += "ExecuteCallableNV(" + ParamToStr(idName, decoded.sBTIndex) + ", " + ParamToStr(idName, decoded.callableDataId) + ")";
      break;
    }
    case rdcspv::Op::TypeCooperativeMatrixNV:
    {
      OpTypeCooperativeMatrixNV decoded(it);
      ret += idName(decoded.result) + " = ";
      ret += "TypeCooperativeMatrixNV(" + ParamToStr(idName, decoded.componentType) + ", " + ToStr(Scope(constIntVal(decoded.execution))) + ", " + ParamToStr(idName, decoded.rows) + ", " + ParamToStr(idName, decoded.columns) + ")";
      break;
    }
    case rdcspv::Op::CooperativeMatrixLoadNV:
    {
      OpCooperativeMatrixLoadNV decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "CooperativeMatrixLoadNV(" + ParamToStr(idName, decoded.pointer) + ", " + ParamToStr(idName, decoded.stride) + ", " + ParamToStr(idName, decoded.columnMajor) + ", " + ParamToStr(idName, decoded.memoryAccess) + ")";
      break;
    }
    case rdcspv::Op::CooperativeMatrixStoreNV:
    {
      OpCooperativeMatrixStoreNV decoded(it);
      ret += "CooperativeMatrixStoreNV(" + ParamToStr(idName, decoded.pointer) + ", " + ParamToStr(idName, decoded.object) + ", " + ParamToStr(idName, decoded.stride) + ", " + ParamToStr(idName, decoded.columnMajor) + ", " + ParamToStr(idName, decoded.memoryAccess) + ")";
      break;
    }
    case rdcspv::Op::CooperativeMatrixMulAddNV:
    {
      OpCooperativeMatrixMulAddNV decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "CooperativeMatrixMulAddNV(" + ParamToStr(idName, decoded.a) + ", " + ParamToStr(idName, decoded.b) + ", " + ParamToStr(idName, decoded.c) + ")";
      break;
    }
    case rdcspv::Op::CooperativeMatrixLengthNV:
    {
      OpCooperativeMatrixLengthNV decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "CooperativeMatrixLengthNV(" + ParamToStr(idName, decoded.type) + ")";
      break;
    }
    case rdcspv::Op::BeginInvocationInterlockEXT:
    {
      OpBeginInvocationInterlockEXT decoded(it);
      ret += "BeginInvocationInterlockEXT(" ")";
      break;
    }
    case rdcspv::Op::EndInvocationInterlockEXT:
    {
      OpEndInvocationInterlockEXT decoded(it);
      ret += "EndInvocationInterlockEXT(" ")";
      break;
    }
    case rdcspv::Op::DemoteToHelperInvocationEXT:
    {
      OpDemoteToHelperInvocationEXT decoded(it);
      ret += "DemoteToHelperInvocationEXT(" ")";
      break;
    }
    case rdcspv::Op::IsHelperInvocationEXT:
    {
      OpIsHelperInvocationEXT decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "IsHelperInvocationEXT(" ")";
      break;
    }
    case rdcspv::Op::SubgroupShuffleINTEL:
    {
      OpSubgroupShuffleINTEL decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "SubgroupShuffleINTEL(" + ParamToStr(idName, decoded.data) + ", " + ParamToStr(idName, decoded.invocationId) + ")";
      break;
    }
    case rdcspv::Op::SubgroupShuffleDownINTEL:
    {
      OpSubgroupShuffleDownINTEL decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "SubgroupShuffleDownINTEL(" + ParamToStr(idName, decoded.current) + ", " + ParamToStr(idName, decoded.next) + ", " + ParamToStr(idName, decoded.delta) + ")";
      break;
    }
    case rdcspv::Op::SubgroupShuffleUpINTEL:
    {
      OpSubgroupShuffleUpINTEL decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "SubgroupShuffleUpINTEL(" + ParamToStr(idName, decoded.previous) + ", " + ParamToStr(idName, decoded.current) + ", " + ParamToStr(idName, decoded.delta) + ")";
      break;
    }
    case rdcspv::Op::SubgroupShuffleXorINTEL:
    {
      OpSubgroupShuffleXorINTEL decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "SubgroupShuffleXorINTEL(" + ParamToStr(idName, decoded.data) + ", " + ParamToStr(idName, decoded.value) + ")";
      break;
    }
    case rdcspv::Op::SubgroupBlockReadINTEL:
    {
      OpSubgroupBlockReadINTEL decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "SubgroupBlockReadINTEL(" + ParamToStr(idName, decoded.ptr) + ")";
      break;
    }
    case rdcspv::Op::SubgroupBlockWriteINTEL:
    {
      OpSubgroupBlockWriteINTEL decoded(it);
      ret += "SubgroupBlockWriteINTEL(" + ParamToStr(idName, decoded.ptr) + ", " + ParamToStr(idName, decoded.data) + ")";
      break;
    }
    case rdcspv::Op::SubgroupImageBlockReadINTEL:
    {
      OpSubgroupImageBlockReadINTEL decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "SubgroupImageBlockReadINTEL(" + ParamToStr(idName, decoded.image) + ", " + ParamToStr(idName, decoded.coordinate) + ")";
      break;
    }
    case rdcspv::Op::SubgroupImageBlockWriteINTEL:
    {
      OpSubgroupImageBlockWriteINTEL decoded(it);
      ret += "SubgroupImageBlockWriteINTEL(" + ParamToStr(idName, decoded.image) + ", " + ParamToStr(idName, decoded.coordinate) + ", " + ParamToStr(idName, decoded.data) + ")";
      break;
    }
    case rdcspv::Op::SubgroupImageMediaBlockReadINTEL:
    {
      OpSubgroupImageMediaBlockReadINTEL decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "SubgroupImageMediaBlockReadINTEL(" + ParamToStr(idName, decoded.image) + ", " + ParamToStr(idName, decoded.coordinate) + ", " + ParamToStr(idName, decoded.width) + ", " + ParamToStr(idName, decoded.height) + ")";
      break;
    }
    case rdcspv::Op::SubgroupImageMediaBlockWriteINTEL:
    {
      OpSubgroupImageMediaBlockWriteINTEL decoded(it);
      ret += "SubgroupImageMediaBlockWriteINTEL(" + ParamToStr(idName, decoded.image) + ", " + ParamToStr(idName, decoded.coordinate) + ", " + ParamToStr(idName, decoded.width) + ", " + ParamToStr(idName, decoded.height) + ", " + ParamToStr(idName, decoded.data) + ")";
      break;
    }
    case rdcspv::Op::UCountLeadingZerosINTEL:
    {
      OpUCountLeadingZerosINTEL decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "UCountLeadingZerosINTEL(" + ParamToStr(idName, decoded.operand) + ")";
      break;
    }
    case rdcspv::Op::UCountTrailingZerosINTEL:
    {
      OpUCountTrailingZerosINTEL decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "UCountTrailingZerosINTEL(" + ParamToStr(idName, decoded.operand) + ")";
      break;
    }
    case rdcspv::Op::AbsISubINTEL:
    {
      OpAbsISubINTEL decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "AbsISubINTEL(" + ParamToStr(idName, decoded.operand1) + ", " + ParamToStr(idName, decoded.operand2) + ")";
      break;
    }
    case rdcspv::Op::AbsUSubINTEL:
    {
      OpAbsUSubINTEL decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "AbsUSubINTEL(" + ParamToStr(idName, decoded.operand1) + ", " + ParamToStr(idName, decoded.operand2) + ")";
      break;
    }
    case rdcspv::Op::IAddSatINTEL:
    {
      OpIAddSatINTEL decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "IAddSatINTEL(" + ParamToStr(idName, decoded.operand1) + ", " + ParamToStr(idName, decoded.operand2) + ")";
      break;
    }
    case rdcspv::Op::UAddSatINTEL:
    {
      OpUAddSatINTEL decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "UAddSatINTEL(" + ParamToStr(idName, decoded.operand1) + ", " + ParamToStr(idName, decoded.operand2) + ")";
      break;
    }
    case rdcspv::Op::IAverageINTEL:
    {
      OpIAverageINTEL decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "IAverageINTEL(" + ParamToStr(idName, decoded.operand1) + ", " + ParamToStr(idName, decoded.operand2) + ")";
      break;
    }
    case rdcspv::Op::UAverageINTEL:
    {
      OpUAverageINTEL decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "UAverageINTEL(" + ParamToStr(idName, decoded.operand1) + ", " + ParamToStr(idName, decoded.operand2) + ")";
      break;
    }
    case rdcspv::Op::IAverageRoundedINTEL:
    {
      OpIAverageRoundedINTEL decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "IAverageRoundedINTEL(" + ParamToStr(idName, decoded.operand1) + ", " + ParamToStr(idName, decoded.operand2) + ")";
      break;
    }
    case rdcspv::Op::UAverageRoundedINTEL:
    {
      OpUAverageRoundedINTEL decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "UAverageRoundedINTEL(" + ParamToStr(idName, decoded.operand1) + ", " + ParamToStr(idName, decoded.operand2) + ")";
      break;
    }
    case rdcspv::Op::ISubSatINTEL:
    {
      OpISubSatINTEL decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "ISubSatINTEL(" + ParamToStr(idName, decoded.operand1) + ", " + ParamToStr(idName, decoded.operand2) + ")";
      break;
    }
    case rdcspv::Op::USubSatINTEL:
    {
      OpUSubSatINTEL decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "USubSatINTEL(" + ParamToStr(idName, decoded.operand1) + ", " + ParamToStr(idName, decoded.operand2) + ")";
      break;
    }
    case rdcspv::Op::IMul32x16INTEL:
    {
      OpIMul32x16INTEL decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "IMul32x16INTEL(" + ParamToStr(idName, decoded.operand1) + ", " + ParamToStr(idName, decoded.operand2) + ")";
      break;
    }
    case rdcspv::Op::UMul32x16INTEL:
    {
      OpUMul32x16INTEL decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "UMul32x16INTEL(" + ParamToStr(idName, decoded.operand1) + ", " + ParamToStr(idName, decoded.operand2) + ")";
      break;
    }
    case rdcspv::Op::FunctionPointerINTEL:
    {
      OpFunctionPointerINTEL decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "FunctionPointerINTEL(" + ParamToStr(idName, decoded.function) + ")";
      break;
    }
    case rdcspv::Op::FunctionPointerCallINTEL:
    {
      OpFunctionPointerCallINTEL decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "FunctionPointerCallINTEL(" + ParamsToStr(idName, decoded.operand1) + ")";
      break;
    }
    case rdcspv::Op::DecorateString:
    {
      OpDecorateString decoded(it);
      ret += "DecorateString(" + ParamToStr(idName, decoded.target) + ", " + ParamToStr(idName, decoded.decoration) + ")";
      break;
    }
    case rdcspv::Op::MemberDecorateString:
    {
      OpMemberDecorateString decoded(it);
      ret += "MemberDecorateString(" + ParamToStr(idName, decoded.structType) + ", " + ParamToStr(idName, decoded.member) + ", " + ParamToStr(idName, decoded.decoration) + ")";
      break;
    }
    case rdcspv::Op::VmeImageINTEL:
    {
      OpVmeImageINTEL decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "VmeImageINTEL(" + ParamToStr(idName, decoded.imageType) + ", " + ParamToStr(idName, decoded.sampler) + ")";
      break;
    }
    case rdcspv::Op::TypeVmeImageINTEL:
    {
      OpTypeVmeImageINTEL decoded(it);
      ret += idName(decoded.result) + " = ";
      ret += "TypeVmeImageINTEL(" + ParamToStr(idName, decoded.imageType) + ")";
      break;
    }
    case rdcspv::Op::TypeAvcImePayloadINTEL:
    {
      OpTypeAvcImePayloadINTEL decoded(it);
      ret += idName(decoded.result) + " = ";
      ret += "TypeAvcImePayloadINTEL(" ")";
      break;
    }
    case rdcspv::Op::TypeAvcRefPayloadINTEL:
    {
      OpTypeAvcRefPayloadINTEL decoded(it);
      ret += idName(decoded.result) + " = ";
      ret += "TypeAvcRefPayloadINTEL(" ")";
      break;
    }
    case rdcspv::Op::TypeAvcSicPayloadINTEL:
    {
      OpTypeAvcSicPayloadINTEL decoded(it);
      ret += idName(decoded.result) + " = ";
      ret += "TypeAvcSicPayloadINTEL(" ")";
      break;
    }
    case rdcspv::Op::TypeAvcMcePayloadINTEL:
    {
      OpTypeAvcMcePayloadINTEL decoded(it);
      ret += idName(decoded.result) + " = ";
      ret += "TypeAvcMcePayloadINTEL(" ")";
      break;
    }
    case rdcspv::Op::TypeAvcMceResultINTEL:
    {
      OpTypeAvcMceResultINTEL decoded(it);
      ret += idName(decoded.result) + " = ";
      ret += "TypeAvcMceResultINTEL(" ")";
      break;
    }
    case rdcspv::Op::TypeAvcImeResultINTEL:
    {
      OpTypeAvcImeResultINTEL decoded(it);
      ret += idName(decoded.result) + " = ";
      ret += "TypeAvcImeResultINTEL(" ")";
      break;
    }
    case rdcspv::Op::TypeAvcImeResultSingleReferenceStreamoutINTEL:
    {
      OpTypeAvcImeResultSingleReferenceStreamoutINTEL decoded(it);
      ret += idName(decoded.result) + " = ";
      ret += "TypeAvcImeResultSingleReferenceStreamoutINTEL(" ")";
      break;
    }
    case rdcspv::Op::TypeAvcImeResultDualReferenceStreamoutINTEL:
    {
      OpTypeAvcImeResultDualReferenceStreamoutINTEL decoded(it);
      ret += idName(decoded.result) + " = ";
      ret += "TypeAvcImeResultDualReferenceStreamoutINTEL(" ")";
      break;
    }
    case rdcspv::Op::TypeAvcImeSingleReferenceStreaminINTEL:
    {
      OpTypeAvcImeSingleReferenceStreaminINTEL decoded(it);
      ret += idName(decoded.result) + " = ";
      ret += "TypeAvcImeSingleReferenceStreaminINTEL(" ")";
      break;
    }
    case rdcspv::Op::TypeAvcImeDualReferenceStreaminINTEL:
    {
      OpTypeAvcImeDualReferenceStreaminINTEL decoded(it);
      ret += idName(decoded.result) + " = ";
      ret += "TypeAvcImeDualReferenceStreaminINTEL(" ")";
      break;
    }
    case rdcspv::Op::TypeAvcRefResultINTEL:
    {
      OpTypeAvcRefResultINTEL decoded(it);
      ret += idName(decoded.result) + " = ";
      ret += "TypeAvcRefResultINTEL(" ")";
      break;
    }
    case rdcspv::Op::TypeAvcSicResultINTEL:
    {
      OpTypeAvcSicResultINTEL decoded(it);
      ret += idName(decoded.result) + " = ";
      ret += "TypeAvcSicResultINTEL(" ")";
      break;
    }
    case rdcspv::Op::SubgroupAvcMceGetDefaultInterBaseMultiReferencePenaltyINTEL:
    {
      OpSubgroupAvcMceGetDefaultInterBaseMultiReferencePenaltyINTEL decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "SubgroupAvcMceGetDefaultInterBaseMultiReferencePenaltyINTEL(" + ParamToStr(idName, decoded.sliceType) + ", " + ParamToStr(idName, decoded.qp) + ")";
      break;
    }
    case rdcspv::Op::SubgroupAvcMceSetInterBaseMultiReferencePenaltyINTEL:
    {
      OpSubgroupAvcMceSetInterBaseMultiReferencePenaltyINTEL decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "SubgroupAvcMceSetInterBaseMultiReferencePenaltyINTEL(" + ParamToStr(idName, decoded.referenceBasePenalty) + ", " + ParamToStr(idName, decoded.payload) + ")";
      break;
    }
    case rdcspv::Op::SubgroupAvcMceGetDefaultInterShapePenaltyINTEL:
    {
      OpSubgroupAvcMceGetDefaultInterShapePenaltyINTEL decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "SubgroupAvcMceGetDefaultInterShapePenaltyINTEL(" + ParamToStr(idName, decoded.sliceType) + ", " + ParamToStr(idName, decoded.qp) + ")";
      break;
    }
    case rdcspv::Op::SubgroupAvcMceSetInterShapePenaltyINTEL:
    {
      OpSubgroupAvcMceSetInterShapePenaltyINTEL decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "SubgroupAvcMceSetInterShapePenaltyINTEL(" + ParamToStr(idName, decoded.packedShapePenalty) + ", " + ParamToStr(idName, decoded.payload) + ")";
      break;
    }
    case rdcspv::Op::SubgroupAvcMceGetDefaultInterDirectionPenaltyINTEL:
    {
      OpSubgroupAvcMceGetDefaultInterDirectionPenaltyINTEL decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "SubgroupAvcMceGetDefaultInterDirectionPenaltyINTEL(" + ParamToStr(idName, decoded.sliceType) + ", " + ParamToStr(idName, decoded.qp) + ")";
      break;
    }
    case rdcspv::Op::SubgroupAvcMceSetInterDirectionPenaltyINTEL:
    {
      OpSubgroupAvcMceSetInterDirectionPenaltyINTEL decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "SubgroupAvcMceSetInterDirectionPenaltyINTEL(" + ParamToStr(idName, decoded.directionCost) + ", " + ParamToStr(idName, decoded.payload) + ")";
      break;
    }
    case rdcspv::Op::SubgroupAvcMceGetDefaultIntraLumaShapePenaltyINTEL:
    {
      OpSubgroupAvcMceGetDefaultIntraLumaShapePenaltyINTEL decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "SubgroupAvcMceGetDefaultIntraLumaShapePenaltyINTEL(" + ParamToStr(idName, decoded.sliceType) + ", " + ParamToStr(idName, decoded.qp) + ")";
      break;
    }
    case rdcspv::Op::SubgroupAvcMceGetDefaultInterMotionVectorCostTableINTEL:
    {
      OpSubgroupAvcMceGetDefaultInterMotionVectorCostTableINTEL decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "SubgroupAvcMceGetDefaultInterMotionVectorCostTableINTEL(" + ParamToStr(idName, decoded.sliceType) + ", " + ParamToStr(idName, decoded.qp) + ")";
      break;
    }
    case rdcspv::Op::SubgroupAvcMceGetDefaultHighPenaltyCostTableINTEL:
    {
      OpSubgroupAvcMceGetDefaultHighPenaltyCostTableINTEL decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "SubgroupAvcMceGetDefaultHighPenaltyCostTableINTEL(" ")";
      break;
    }
    case rdcspv::Op::SubgroupAvcMceGetDefaultMediumPenaltyCostTableINTEL:
    {
      OpSubgroupAvcMceGetDefaultMediumPenaltyCostTableINTEL decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "SubgroupAvcMceGetDefaultMediumPenaltyCostTableINTEL(" ")";
      break;
    }
    case rdcspv::Op::SubgroupAvcMceGetDefaultLowPenaltyCostTableINTEL:
    {
      OpSubgroupAvcMceGetDefaultLowPenaltyCostTableINTEL decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "SubgroupAvcMceGetDefaultLowPenaltyCostTableINTEL(" ")";
      break;
    }
    case rdcspv::Op::SubgroupAvcMceSetMotionVectorCostFunctionINTEL:
    {
      OpSubgroupAvcMceSetMotionVectorCostFunctionINTEL decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "SubgroupAvcMceSetMotionVectorCostFunctionINTEL(" + ParamToStr(idName, decoded.packedCostCenterDelta) + ", " + ParamToStr(idName, decoded.packedCostTable) + ", " + ParamToStr(idName, decoded.costPrecision) + ", " + ParamToStr(idName, decoded.payload) + ")";
      break;
    }
    case rdcspv::Op::SubgroupAvcMceGetDefaultIntraLumaModePenaltyINTEL:
    {
      OpSubgroupAvcMceGetDefaultIntraLumaModePenaltyINTEL decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "SubgroupAvcMceGetDefaultIntraLumaModePenaltyINTEL(" + ParamToStr(idName, decoded.sliceType) + ", " + ParamToStr(idName, decoded.qp) + ")";
      break;
    }
    case rdcspv::Op::SubgroupAvcMceGetDefaultNonDcLumaIntraPenaltyINTEL:
    {
      OpSubgroupAvcMceGetDefaultNonDcLumaIntraPenaltyINTEL decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "SubgroupAvcMceGetDefaultNonDcLumaIntraPenaltyINTEL(" ")";
      break;
    }
    case rdcspv::Op::SubgroupAvcMceGetDefaultIntraChromaModeBasePenaltyINTEL:
    {
      OpSubgroupAvcMceGetDefaultIntraChromaModeBasePenaltyINTEL decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "SubgroupAvcMceGetDefaultIntraChromaModeBasePenaltyINTEL(" ")";
      break;
    }
    case rdcspv::Op::SubgroupAvcMceSetAcOnlyHaarINTEL:
    {
      OpSubgroupAvcMceSetAcOnlyHaarINTEL decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "SubgroupAvcMceSetAcOnlyHaarINTEL(" + ParamToStr(idName, decoded.payload) + ")";
      break;
    }
    case rdcspv::Op::SubgroupAvcMceSetSourceInterlacedFieldPolarityINTEL:
    {
      OpSubgroupAvcMceSetSourceInterlacedFieldPolarityINTEL decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "SubgroupAvcMceSetSourceInterlacedFieldPolarityINTEL(" + ParamToStr(idName, decoded.sourceFieldPolarity) + ", " + ParamToStr(idName, decoded.payload) + ")";
      break;
    }
    case rdcspv::Op::SubgroupAvcMceSetSingleReferenceInterlacedFieldPolarityINTEL:
    {
      OpSubgroupAvcMceSetSingleReferenceInterlacedFieldPolarityINTEL decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "SubgroupAvcMceSetSingleReferenceInterlacedFieldPolarityINTEL(" + ParamToStr(idName, decoded.referenceFieldPolarity) + ", " + ParamToStr(idName, decoded.payload) + ")";
      break;
    }
    case rdcspv::Op::SubgroupAvcMceSetDualReferenceInterlacedFieldPolaritiesINTEL:
    {
      OpSubgroupAvcMceSetDualReferenceInterlacedFieldPolaritiesINTEL decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "SubgroupAvcMceSetDualReferenceInterlacedFieldPolaritiesINTEL(" + ParamToStr(idName, decoded.forwardReferenceFieldPolarity) + ", " + ParamToStr(idName, decoded.backwardReferenceFieldPolarity) + ", " + ParamToStr(idName, decoded.payload) + ")";
      break;
    }
    case rdcspv::Op::SubgroupAvcMceConvertToImePayloadINTEL:
    {
      OpSubgroupAvcMceConvertToImePayloadINTEL decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "SubgroupAvcMceConvertToImePayloadINTEL(" + ParamToStr(idName, decoded.payload) + ")";
      break;
    }
    case rdcspv::Op::SubgroupAvcMceConvertToImeResultINTEL:
    {
      OpSubgroupAvcMceConvertToImeResultINTEL decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "SubgroupAvcMceConvertToImeResultINTEL(" + ParamToStr(idName, decoded.payload) + ")";
      break;
    }
    case rdcspv::Op::SubgroupAvcMceConvertToRefPayloadINTEL:
    {
      OpSubgroupAvcMceConvertToRefPayloadINTEL decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "SubgroupAvcMceConvertToRefPayloadINTEL(" + ParamToStr(idName, decoded.payload) + ")";
      break;
    }
    case rdcspv::Op::SubgroupAvcMceConvertToRefResultINTEL:
    {
      OpSubgroupAvcMceConvertToRefResultINTEL decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "SubgroupAvcMceConvertToRefResultINTEL(" + ParamToStr(idName, decoded.payload) + ")";
      break;
    }
    case rdcspv::Op::SubgroupAvcMceConvertToSicPayloadINTEL:
    {
      OpSubgroupAvcMceConvertToSicPayloadINTEL decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "SubgroupAvcMceConvertToSicPayloadINTEL(" + ParamToStr(idName, decoded.payload) + ")";
      break;
    }
    case rdcspv::Op::SubgroupAvcMceConvertToSicResultINTEL:
    {
      OpSubgroupAvcMceConvertToSicResultINTEL decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "SubgroupAvcMceConvertToSicResultINTEL(" + ParamToStr(idName, decoded.payload) + ")";
      break;
    }
    case rdcspv::Op::SubgroupAvcMceGetMotionVectorsINTEL:
    {
      OpSubgroupAvcMceGetMotionVectorsINTEL decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "SubgroupAvcMceGetMotionVectorsINTEL(" + ParamToStr(idName, decoded.payload) + ")";
      break;
    }
    case rdcspv::Op::SubgroupAvcMceGetInterDistortionsINTEL:
    {
      OpSubgroupAvcMceGetInterDistortionsINTEL decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "SubgroupAvcMceGetInterDistortionsINTEL(" + ParamToStr(idName, decoded.payload) + ")";
      break;
    }
    case rdcspv::Op::SubgroupAvcMceGetBestInterDistortionsINTEL:
    {
      OpSubgroupAvcMceGetBestInterDistortionsINTEL decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "SubgroupAvcMceGetBestInterDistortionsINTEL(" + ParamToStr(idName, decoded.payload) + ")";
      break;
    }
    case rdcspv::Op::SubgroupAvcMceGetInterMajorShapeINTEL:
    {
      OpSubgroupAvcMceGetInterMajorShapeINTEL decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "SubgroupAvcMceGetInterMajorShapeINTEL(" + ParamToStr(idName, decoded.payload) + ")";
      break;
    }
    case rdcspv::Op::SubgroupAvcMceGetInterMinorShapeINTEL:
    {
      OpSubgroupAvcMceGetInterMinorShapeINTEL decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "SubgroupAvcMceGetInterMinorShapeINTEL(" + ParamToStr(idName, decoded.payload) + ")";
      break;
    }
    case rdcspv::Op::SubgroupAvcMceGetInterDirectionsINTEL:
    {
      OpSubgroupAvcMceGetInterDirectionsINTEL decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "SubgroupAvcMceGetInterDirectionsINTEL(" + ParamToStr(idName, decoded.payload) + ")";
      break;
    }
    case rdcspv::Op::SubgroupAvcMceGetInterMotionVectorCountINTEL:
    {
      OpSubgroupAvcMceGetInterMotionVectorCountINTEL decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "SubgroupAvcMceGetInterMotionVectorCountINTEL(" + ParamToStr(idName, decoded.payload) + ")";
      break;
    }
    case rdcspv::Op::SubgroupAvcMceGetInterReferenceIdsINTEL:
    {
      OpSubgroupAvcMceGetInterReferenceIdsINTEL decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "SubgroupAvcMceGetInterReferenceIdsINTEL(" + ParamToStr(idName, decoded.payload) + ")";
      break;
    }
    case rdcspv::Op::SubgroupAvcMceGetInterReferenceInterlacedFieldPolaritiesINTEL:
    {
      OpSubgroupAvcMceGetInterReferenceInterlacedFieldPolaritiesINTEL decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "SubgroupAvcMceGetInterReferenceInterlacedFieldPolaritiesINTEL(" + ParamToStr(idName, decoded.packedReferenceIds) + ", " + ParamToStr(idName, decoded.packedReferenceParameterFieldPolarities) + ", " + ParamToStr(idName, decoded.payload) + ")";
      break;
    }
    case rdcspv::Op::SubgroupAvcImeInitializeINTEL:
    {
      OpSubgroupAvcImeInitializeINTEL decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "SubgroupAvcImeInitializeINTEL(" + ParamToStr(idName, decoded.srcCoord) + ", " + ParamToStr(idName, decoded.partitionMask) + ", " + ParamToStr(idName, decoded.sADAdjustment) + ")";
      break;
    }
    case rdcspv::Op::SubgroupAvcImeSetSingleReferenceINTEL:
    {
      OpSubgroupAvcImeSetSingleReferenceINTEL decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "SubgroupAvcImeSetSingleReferenceINTEL(" + ParamToStr(idName, decoded.refOffset) + ", " + ParamToStr(idName, decoded.searchWindowConfig) + ", " + ParamToStr(idName, decoded.payload) + ")";
      break;
    }
    case rdcspv::Op::SubgroupAvcImeSetDualReferenceINTEL:
    {
      OpSubgroupAvcImeSetDualReferenceINTEL decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "SubgroupAvcImeSetDualReferenceINTEL(" + ParamToStr(idName, decoded.fwdRefOffset) + ", " + ParamToStr(idName, decoded.bwdRefOffset) + ", " + ParamToStr(idName, decoded.idSearchWindowConfig) + ", " + ParamToStr(idName, decoded.payload) + ")";
      break;
    }
    case rdcspv::Op::SubgroupAvcImeRefWindowSizeINTEL:
    {
      OpSubgroupAvcImeRefWindowSizeINTEL decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "SubgroupAvcImeRefWindowSizeINTEL(" + ParamToStr(idName, decoded.searchWindowConfig) + ", " + ParamToStr(idName, decoded.dualRef) + ")";
      break;
    }
    case rdcspv::Op::SubgroupAvcImeAdjustRefOffsetINTEL:
    {
      OpSubgroupAvcImeAdjustRefOffsetINTEL decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "SubgroupAvcImeAdjustRefOffsetINTEL(" + ParamToStr(idName, decoded.refOffset) + ", " + ParamToStr(idName, decoded.srcCoord) + ", " + ParamToStr(idName, decoded.refWindowSize) + ", " + ParamToStr(idName, decoded.imageSize) + ")";
      break;
    }
    case rdcspv::Op::SubgroupAvcImeConvertToMcePayloadINTEL:
    {
      OpSubgroupAvcImeConvertToMcePayloadINTEL decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "SubgroupAvcImeConvertToMcePayloadINTEL(" + ParamToStr(idName, decoded.payload) + ")";
      break;
    }
    case rdcspv::Op::SubgroupAvcImeSetMaxMotionVectorCountINTEL:
    {
      OpSubgroupAvcImeSetMaxMotionVectorCountINTEL decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "SubgroupAvcImeSetMaxMotionVectorCountINTEL(" + ParamToStr(idName, decoded.maxMotionVectorCount) + ", " + ParamToStr(idName, decoded.payload) + ")";
      break;
    }
    case rdcspv::Op::SubgroupAvcImeSetUnidirectionalMixDisableINTEL:
    {
      OpSubgroupAvcImeSetUnidirectionalMixDisableINTEL decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "SubgroupAvcImeSetUnidirectionalMixDisableINTEL(" + ParamToStr(idName, decoded.payload) + ")";
      break;
    }
    case rdcspv::Op::SubgroupAvcImeSetEarlySearchTerminationThresholdINTEL:
    {
      OpSubgroupAvcImeSetEarlySearchTerminationThresholdINTEL decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "SubgroupAvcImeSetEarlySearchTerminationThresholdINTEL(" + ParamToStr(idName, decoded.threshold) + ", " + ParamToStr(idName, decoded.payload) + ")";
      break;
    }
    case rdcspv::Op::SubgroupAvcImeSetWeightedSadINTEL:
    {
      OpSubgroupAvcImeSetWeightedSadINTEL decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "SubgroupAvcImeSetWeightedSadINTEL(" + ParamToStr(idName, decoded.packedSadWeights) + ", " + ParamToStr(idName, decoded.payload) + ")";
      break;
    }
    case rdcspv::Op::SubgroupAvcImeEvaluateWithSingleReferenceINTEL:
    {
      OpSubgroupAvcImeEvaluateWithSingleReferenceINTEL decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "SubgroupAvcImeEvaluateWithSingleReferenceINTEL(" + ParamToStr(idName, decoded.srcImage) + ", " + ParamToStr(idName, decoded.refImage) + ", " + ParamToStr(idName, decoded.payload) + ")";
      break;
    }
    case rdcspv::Op::SubgroupAvcImeEvaluateWithDualReferenceINTEL:
    {
      OpSubgroupAvcImeEvaluateWithDualReferenceINTEL decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "SubgroupAvcImeEvaluateWithDualReferenceINTEL(" + ParamToStr(idName, decoded.srcImage) + ", " + ParamToStr(idName, decoded.fwdRefImage) + ", " + ParamToStr(idName, decoded.bwdRefImage) + ", " + ParamToStr(idName, decoded.payload) + ")";
      break;
    }
    case rdcspv::Op::SubgroupAvcImeEvaluateWithSingleReferenceStreaminINTEL:
    {
      OpSubgroupAvcImeEvaluateWithSingleReferenceStreaminINTEL decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "SubgroupAvcImeEvaluateWithSingleReferenceStreaminINTEL(" + ParamToStr(idName, decoded.srcImage) + ", " + ParamToStr(idName, decoded.refImage) + ", " + ParamToStr(idName, decoded.payload) + ", " + ParamToStr(idName, decoded.streaminComponents) + ")";
      break;
    }
    case rdcspv::Op::SubgroupAvcImeEvaluateWithDualReferenceStreaminINTEL:
    {
      OpSubgroupAvcImeEvaluateWithDualReferenceStreaminINTEL decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "SubgroupAvcImeEvaluateWithDualReferenceStreaminINTEL(" + ParamToStr(idName, decoded.srcImage) + ", " + ParamToStr(idName, decoded.fwdRefImage) + ", " + ParamToStr(idName, decoded.bwdRefImage) + ", " + ParamToStr(idName, decoded.payload) + ", " + ParamToStr(idName, decoded.streaminComponents) + ")";
      break;
    }
    case rdcspv::Op::SubgroupAvcImeEvaluateWithSingleReferenceStreamoutINTEL:
    {
      OpSubgroupAvcImeEvaluateWithSingleReferenceStreamoutINTEL decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "SubgroupAvcImeEvaluateWithSingleReferenceStreamoutINTEL(" + ParamToStr(idName, decoded.srcImage) + ", " + ParamToStr(idName, decoded.refImage) + ", " + ParamToStr(idName, decoded.payload) + ")";
      break;
    }
    case rdcspv::Op::SubgroupAvcImeEvaluateWithDualReferenceStreamoutINTEL:
    {
      OpSubgroupAvcImeEvaluateWithDualReferenceStreamoutINTEL decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "SubgroupAvcImeEvaluateWithDualReferenceStreamoutINTEL(" + ParamToStr(idName, decoded.srcImage) + ", " + ParamToStr(idName, decoded.fwdRefImage) + ", " + ParamToStr(idName, decoded.bwdRefImage) + ", " + ParamToStr(idName, decoded.payload) + ")";
      break;
    }
    case rdcspv::Op::SubgroupAvcImeEvaluateWithSingleReferenceStreaminoutINTEL:
    {
      OpSubgroupAvcImeEvaluateWithSingleReferenceStreaminoutINTEL decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "SubgroupAvcImeEvaluateWithSingleReferenceStreaminoutINTEL(" + ParamToStr(idName, decoded.srcImage) + ", " + ParamToStr(idName, decoded.refImage) + ", " + ParamToStr(idName, decoded.payload) + ", " + ParamToStr(idName, decoded.streaminComponents) + ")";
      break;
    }
    case rdcspv::Op::SubgroupAvcImeEvaluateWithDualReferenceStreaminoutINTEL:
    {
      OpSubgroupAvcImeEvaluateWithDualReferenceStreaminoutINTEL decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "SubgroupAvcImeEvaluateWithDualReferenceStreaminoutINTEL(" + ParamToStr(idName, decoded.srcImage) + ", " + ParamToStr(idName, decoded.fwdRefImage) + ", " + ParamToStr(idName, decoded.bwdRefImage) + ", " + ParamToStr(idName, decoded.payload) + ", " + ParamToStr(idName, decoded.streaminComponents) + ")";
      break;
    }
    case rdcspv::Op::SubgroupAvcImeConvertToMceResultINTEL:
    {
      OpSubgroupAvcImeConvertToMceResultINTEL decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "SubgroupAvcImeConvertToMceResultINTEL(" + ParamToStr(idName, decoded.payload) + ")";
      break;
    }
    case rdcspv::Op::SubgroupAvcImeGetSingleReferenceStreaminINTEL:
    {
      OpSubgroupAvcImeGetSingleReferenceStreaminINTEL decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "SubgroupAvcImeGetSingleReferenceStreaminINTEL(" + ParamToStr(idName, decoded.payload) + ")";
      break;
    }
    case rdcspv::Op::SubgroupAvcImeGetDualReferenceStreaminINTEL:
    {
      OpSubgroupAvcImeGetDualReferenceStreaminINTEL decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "SubgroupAvcImeGetDualReferenceStreaminINTEL(" + ParamToStr(idName, decoded.payload) + ")";
      break;
    }
    case rdcspv::Op::SubgroupAvcImeStripSingleReferenceStreamoutINTEL:
    {
      OpSubgroupAvcImeStripSingleReferenceStreamoutINTEL decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "SubgroupAvcImeStripSingleReferenceStreamoutINTEL(" + ParamToStr(idName, decoded.payload) + ")";
      break;
    }
    case rdcspv::Op::SubgroupAvcImeStripDualReferenceStreamoutINTEL:
    {
      OpSubgroupAvcImeStripDualReferenceStreamoutINTEL decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "SubgroupAvcImeStripDualReferenceStreamoutINTEL(" + ParamToStr(idName, decoded.payload) + ")";
      break;
    }
    case rdcspv::Op::SubgroupAvcImeGetStreamoutSingleReferenceMajorShapeMotionVectorsINTEL:
    {
      OpSubgroupAvcImeGetStreamoutSingleReferenceMajorShapeMotionVectorsINTEL decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "SubgroupAvcImeGetStreamoutSingleReferenceMajorShapeMotionVectorsINTEL(" + ParamToStr(idName, decoded.payload) + ", " + ParamToStr(idName, decoded.majorShape) + ")";
      break;
    }
    case rdcspv::Op::SubgroupAvcImeGetStreamoutSingleReferenceMajorShapeDistortionsINTEL:
    {
      OpSubgroupAvcImeGetStreamoutSingleReferenceMajorShapeDistortionsINTEL decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "SubgroupAvcImeGetStreamoutSingleReferenceMajorShapeDistortionsINTEL(" + ParamToStr(idName, decoded.payload) + ", " + ParamToStr(idName, decoded.majorShape) + ")";
      break;
    }
    case rdcspv::Op::SubgroupAvcImeGetStreamoutSingleReferenceMajorShapeReferenceIdsINTEL:
    {
      OpSubgroupAvcImeGetStreamoutSingleReferenceMajorShapeReferenceIdsINTEL decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "SubgroupAvcImeGetStreamoutSingleReferenceMajorShapeReferenceIdsINTEL(" + ParamToStr(idName, decoded.payload) + ", " + ParamToStr(idName, decoded.majorShape) + ")";
      break;
    }
    case rdcspv::Op::SubgroupAvcImeGetStreamoutDualReferenceMajorShapeMotionVectorsINTEL:
    {
      OpSubgroupAvcImeGetStreamoutDualReferenceMajorShapeMotionVectorsINTEL decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "SubgroupAvcImeGetStreamoutDualReferenceMajorShapeMotionVectorsINTEL(" + ParamToStr(idName, decoded.payload) + ", " + ParamToStr(idName, decoded.majorShape) + ", " + ParamToStr(idName, decoded.direction) + ")";
      break;
    }
    case rdcspv::Op::SubgroupAvcImeGetStreamoutDualReferenceMajorShapeDistortionsINTEL:
    {
      OpSubgroupAvcImeGetStreamoutDualReferenceMajorShapeDistortionsINTEL decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "SubgroupAvcImeGetStreamoutDualReferenceMajorShapeDistortionsINTEL(" + ParamToStr(idName, decoded.payload) + ", " + ParamToStr(idName, decoded.majorShape) + ", " + ParamToStr(idName, decoded.direction) + ")";
      break;
    }
    case rdcspv::Op::SubgroupAvcImeGetStreamoutDualReferenceMajorShapeReferenceIdsINTEL:
    {
      OpSubgroupAvcImeGetStreamoutDualReferenceMajorShapeReferenceIdsINTEL decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "SubgroupAvcImeGetStreamoutDualReferenceMajorShapeReferenceIdsINTEL(" + ParamToStr(idName, decoded.payload) + ", " + ParamToStr(idName, decoded.majorShape) + ", " + ParamToStr(idName, decoded.direction) + ")";
      break;
    }
    case rdcspv::Op::SubgroupAvcImeGetBorderReachedINTEL:
    {
      OpSubgroupAvcImeGetBorderReachedINTEL decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "SubgroupAvcImeGetBorderReachedINTEL(" + ParamToStr(idName, decoded.imageSelect) + ", " + ParamToStr(idName, decoded.payload) + ")";
      break;
    }
    case rdcspv::Op::SubgroupAvcImeGetTruncatedSearchIndicationINTEL:
    {
      OpSubgroupAvcImeGetTruncatedSearchIndicationINTEL decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "SubgroupAvcImeGetTruncatedSearchIndicationINTEL(" + ParamToStr(idName, decoded.payload) + ")";
      break;
    }
    case rdcspv::Op::SubgroupAvcImeGetUnidirectionalEarlySearchTerminationINTEL:
    {
      OpSubgroupAvcImeGetUnidirectionalEarlySearchTerminationINTEL decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "SubgroupAvcImeGetUnidirectionalEarlySearchTerminationINTEL(" + ParamToStr(idName, decoded.payload) + ")";
      break;
    }
    case rdcspv::Op::SubgroupAvcImeGetWeightingPatternMinimumMotionVectorINTEL:
    {
      OpSubgroupAvcImeGetWeightingPatternMinimumMotionVectorINTEL decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "SubgroupAvcImeGetWeightingPatternMinimumMotionVectorINTEL(" + ParamToStr(idName, decoded.payload) + ")";
      break;
    }
    case rdcspv::Op::SubgroupAvcImeGetWeightingPatternMinimumDistortionINTEL:
    {
      OpSubgroupAvcImeGetWeightingPatternMinimumDistortionINTEL decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "SubgroupAvcImeGetWeightingPatternMinimumDistortionINTEL(" + ParamToStr(idName, decoded.payload) + ")";
      break;
    }
    case rdcspv::Op::SubgroupAvcFmeInitializeINTEL:
    {
      OpSubgroupAvcFmeInitializeINTEL decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "SubgroupAvcFmeInitializeINTEL(" + ParamToStr(idName, decoded.srcCoord) + ", " + ParamToStr(idName, decoded.motionVectors) + ", " + ParamToStr(idName, decoded.majorShapes) + ", " + ParamToStr(idName, decoded.minorShapes) + ", " + ParamToStr(idName, decoded.direction) + ", " + ParamToStr(idName, decoded.pixelResolution) + ", " + ParamToStr(idName, decoded.sadAdjustment) + ")";
      break;
    }
    case rdcspv::Op::SubgroupAvcBmeInitializeINTEL:
    {
      OpSubgroupAvcBmeInitializeINTEL decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "SubgroupAvcBmeInitializeINTEL(" + ParamToStr(idName, decoded.srcCoord) + ", " + ParamToStr(idName, decoded.motionVectors) + ", " + ParamToStr(idName, decoded.majorShapes) + ", " + ParamToStr(idName, decoded.minorShapes) + ", " + ParamToStr(idName, decoded.direction) + ", " + ParamToStr(idName, decoded.pixelResolution) + ", " + ParamToStr(idName, decoded.bidirectionalWeight) + ", " + ParamToStr(idName, decoded.sadAdjustment) + ")";
      break;
    }
    case rdcspv::Op::SubgroupAvcRefConvertToMcePayloadINTEL:
    {
      OpSubgroupAvcRefConvertToMcePayloadINTEL decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "SubgroupAvcRefConvertToMcePayloadINTEL(" + ParamToStr(idName, decoded.payload) + ")";
      break;
    }
    case rdcspv::Op::SubgroupAvcRefSetBidirectionalMixDisableINTEL:
    {
      OpSubgroupAvcRefSetBidirectionalMixDisableINTEL decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "SubgroupAvcRefSetBidirectionalMixDisableINTEL(" + ParamToStr(idName, decoded.payload) + ")";
      break;
    }
    case rdcspv::Op::SubgroupAvcRefSetBilinearFilterEnableINTEL:
    {
      OpSubgroupAvcRefSetBilinearFilterEnableINTEL decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "SubgroupAvcRefSetBilinearFilterEnableINTEL(" + ParamToStr(idName, decoded.payload) + ")";
      break;
    }
    case rdcspv::Op::SubgroupAvcRefEvaluateWithSingleReferenceINTEL:
    {
      OpSubgroupAvcRefEvaluateWithSingleReferenceINTEL decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "SubgroupAvcRefEvaluateWithSingleReferenceINTEL(" + ParamToStr(idName, decoded.srcImage) + ", " + ParamToStr(idName, decoded.refImage) + ", " + ParamToStr(idName, decoded.payload) + ")";
      break;
    }
    case rdcspv::Op::SubgroupAvcRefEvaluateWithDualReferenceINTEL:
    {
      OpSubgroupAvcRefEvaluateWithDualReferenceINTEL decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "SubgroupAvcRefEvaluateWithDualReferenceINTEL(" + ParamToStr(idName, decoded.srcImage) + ", " + ParamToStr(idName, decoded.fwdRefImage) + ", " + ParamToStr(idName, decoded.bwdRefImage) + ", " + ParamToStr(idName, decoded.payload) + ")";
      break;
    }
    case rdcspv::Op::SubgroupAvcRefEvaluateWithMultiReferenceINTEL:
    {
      OpSubgroupAvcRefEvaluateWithMultiReferenceINTEL decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "SubgroupAvcRefEvaluateWithMultiReferenceINTEL(" + ParamToStr(idName, decoded.srcImage) + ", " + ParamToStr(idName, decoded.packedReferenceIds) + ", " + ParamToStr(idName, decoded.payload) + ")";
      break;
    }
    case rdcspv::Op::SubgroupAvcRefEvaluateWithMultiReferenceInterlacedINTEL:
    {
      OpSubgroupAvcRefEvaluateWithMultiReferenceInterlacedINTEL decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "SubgroupAvcRefEvaluateWithMultiReferenceInterlacedINTEL(" + ParamToStr(idName, decoded.srcImage) + ", " + ParamToStr(idName, decoded.packedReferenceIds) + ", " + ParamToStr(idName, decoded.packedReferenceFieldPolarities) + ", " + ParamToStr(idName, decoded.payload) + ")";
      break;
    }
    case rdcspv::Op::SubgroupAvcRefConvertToMceResultINTEL:
    {
      OpSubgroupAvcRefConvertToMceResultINTEL decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "SubgroupAvcRefConvertToMceResultINTEL(" + ParamToStr(idName, decoded.payload) + ")";
      break;
    }
    case rdcspv::Op::SubgroupAvcSicInitializeINTEL:
    {
      OpSubgroupAvcSicInitializeINTEL decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "SubgroupAvcSicInitializeINTEL(" + ParamToStr(idName, decoded.srcCoord) + ")";
      break;
    }
    case rdcspv::Op::SubgroupAvcSicConfigureSkcINTEL:
    {
      OpSubgroupAvcSicConfigureSkcINTEL decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "SubgroupAvcSicConfigureSkcINTEL(" + ParamToStr(idName, decoded.skipBlockPartitionType) + ", " + ParamToStr(idName, decoded.skipMotionVectorMask) + ", " + ParamToStr(idName, decoded.motionVectors) + ", " + ParamToStr(idName, decoded.bidirectionalWeight) + ", " + ParamToStr(idName, decoded.sadAdjustment) + ", " + ParamToStr(idName, decoded.payload) + ")";
      break;
    }
    case rdcspv::Op::SubgroupAvcSicConfigureIpeLumaINTEL:
    {
      OpSubgroupAvcSicConfigureIpeLumaINTEL decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "SubgroupAvcSicConfigureIpeLumaINTEL(" + ParamToStr(idName, decoded.lumaIntraPartitionMask) + ", " + ParamToStr(idName, decoded.intraNeighbourAvailabilty) + ", " + ParamToStr(idName, decoded.leftEdgeLumaPixels) + ", " + ParamToStr(idName, decoded.upperLeftCornerLumaPixel) + ", " + ParamToStr(idName, decoded.upperEdgeLumaPixels) + ", " + ParamToStr(idName, decoded.upperRightEdgeLumaPixels) + ", " + ParamToStr(idName, decoded.sadAdjustment) + ", " + ParamToStr(idName, decoded.payload) + ")";
      break;
    }
    case rdcspv::Op::SubgroupAvcSicConfigureIpeLumaChromaINTEL:
    {
      OpSubgroupAvcSicConfigureIpeLumaChromaINTEL decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "SubgroupAvcSicConfigureIpeLumaChromaINTEL(" + ParamToStr(idName, decoded.lumaIntraPartitionMask) + ", " + ParamToStr(idName, decoded.intraNeighbourAvailabilty) + ", " + ParamToStr(idName, decoded.leftEdgeLumaPixels) + ", " + ParamToStr(idName, decoded.upperLeftCornerLumaPixel) + ", " + ParamToStr(idName, decoded.upperEdgeLumaPixels) + ", " + ParamToStr(idName, decoded.upperRightEdgeLumaPixels) + ", " + ParamToStr(idName, decoded.leftEdgeChromaPixels) + ", " + ParamToStr(idName, decoded.upperLeftCornerChromaPixel) + ", " + ParamToStr(idName, decoded.upperEdgeChromaPixels) + ", " + ParamToStr(idName, decoded.sadAdjustment) + ", " + ParamToStr(idName, decoded.payload) + ")";
      break;
    }
    case rdcspv::Op::SubgroupAvcSicGetMotionVectorMaskINTEL:
    {
      OpSubgroupAvcSicGetMotionVectorMaskINTEL decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "SubgroupAvcSicGetMotionVectorMaskINTEL(" + ParamToStr(idName, decoded.skipBlockPartitionType) + ", " + ParamToStr(idName, decoded.direction) + ")";
      break;
    }
    case rdcspv::Op::SubgroupAvcSicConvertToMcePayloadINTEL:
    {
      OpSubgroupAvcSicConvertToMcePayloadINTEL decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "SubgroupAvcSicConvertToMcePayloadINTEL(" + ParamToStr(idName, decoded.payload) + ")";
      break;
    }
    case rdcspv::Op::SubgroupAvcSicSetIntraLumaShapePenaltyINTEL:
    {
      OpSubgroupAvcSicSetIntraLumaShapePenaltyINTEL decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "SubgroupAvcSicSetIntraLumaShapePenaltyINTEL(" + ParamToStr(idName, decoded.packedShapePenalty) + ", " + ParamToStr(idName, decoded.payload) + ")";
      break;
    }
    case rdcspv::Op::SubgroupAvcSicSetIntraLumaModeCostFunctionINTEL:
    {
      OpSubgroupAvcSicSetIntraLumaModeCostFunctionINTEL decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "SubgroupAvcSicSetIntraLumaModeCostFunctionINTEL(" + ParamToStr(idName, decoded.lumaModePenalty) + ", " + ParamToStr(idName, decoded.lumaPackedNeighborModes) + ", " + ParamToStr(idName, decoded.lumaPackedNonDcPenalty) + ", " + ParamToStr(idName, decoded.payload) + ")";
      break;
    }
    case rdcspv::Op::SubgroupAvcSicSetIntraChromaModeCostFunctionINTEL:
    {
      OpSubgroupAvcSicSetIntraChromaModeCostFunctionINTEL decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "SubgroupAvcSicSetIntraChromaModeCostFunctionINTEL(" + ParamToStr(idName, decoded.chromaModeBasePenalty) + ", " + ParamToStr(idName, decoded.payload) + ")";
      break;
    }
    case rdcspv::Op::SubgroupAvcSicSetBilinearFilterEnableINTEL:
    {
      OpSubgroupAvcSicSetBilinearFilterEnableINTEL decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "SubgroupAvcSicSetBilinearFilterEnableINTEL(" + ParamToStr(idName, decoded.payload) + ")";
      break;
    }
    case rdcspv::Op::SubgroupAvcSicSetSkcForwardTransformEnableINTEL:
    {
      OpSubgroupAvcSicSetSkcForwardTransformEnableINTEL decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "SubgroupAvcSicSetSkcForwardTransformEnableINTEL(" + ParamToStr(idName, decoded.packedSadCoefficients) + ", " + ParamToStr(idName, decoded.payload) + ")";
      break;
    }
    case rdcspv::Op::SubgroupAvcSicSetBlockBasedRawSkipSadINTEL:
    {
      OpSubgroupAvcSicSetBlockBasedRawSkipSadINTEL decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "SubgroupAvcSicSetBlockBasedRawSkipSadINTEL(" + ParamToStr(idName, decoded.blockBasedSkipType) + ", " + ParamToStr(idName, decoded.payload) + ")";
      break;
    }
    case rdcspv::Op::SubgroupAvcSicEvaluateIpeINTEL:
    {
      OpSubgroupAvcSicEvaluateIpeINTEL decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "SubgroupAvcSicEvaluateIpeINTEL(" + ParamToStr(idName, decoded.srcImage) + ", " + ParamToStr(idName, decoded.payload) + ")";
      break;
    }
    case rdcspv::Op::SubgroupAvcSicEvaluateWithSingleReferenceINTEL:
    {
      OpSubgroupAvcSicEvaluateWithSingleReferenceINTEL decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "SubgroupAvcSicEvaluateWithSingleReferenceINTEL(" + ParamToStr(idName, decoded.srcImage) + ", " + ParamToStr(idName, decoded.refImage) + ", " + ParamToStr(idName, decoded.payload) + ")";
      break;
    }
    case rdcspv::Op::SubgroupAvcSicEvaluateWithDualReferenceINTEL:
    {
      OpSubgroupAvcSicEvaluateWithDualReferenceINTEL decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "SubgroupAvcSicEvaluateWithDualReferenceINTEL(" + ParamToStr(idName, decoded.srcImage) + ", " + ParamToStr(idName, decoded.fwdRefImage) + ", " + ParamToStr(idName, decoded.bwdRefImage) + ", " + ParamToStr(idName, decoded.payload) + ")";
      break;
    }
    case rdcspv::Op::SubgroupAvcSicEvaluateWithMultiReferenceINTEL:
    {
      OpSubgroupAvcSicEvaluateWithMultiReferenceINTEL decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "SubgroupAvcSicEvaluateWithMultiReferenceINTEL(" + ParamToStr(idName, decoded.srcImage) + ", " + ParamToStr(idName, decoded.packedReferenceIds) + ", " + ParamToStr(idName, decoded.payload) + ")";
      break;
    }
    case rdcspv::Op::SubgroupAvcSicEvaluateWithMultiReferenceInterlacedINTEL:
    {
      OpSubgroupAvcSicEvaluateWithMultiReferenceInterlacedINTEL decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "SubgroupAvcSicEvaluateWithMultiReferenceInterlacedINTEL(" + ParamToStr(idName, decoded.srcImage) + ", " + ParamToStr(idName, decoded.packedReferenceIds) + ", " + ParamToStr(idName, decoded.packedReferenceFieldPolarities) + ", " + ParamToStr(idName, decoded.payload) + ")";
      break;
    }
    case rdcspv::Op::SubgroupAvcSicConvertToMceResultINTEL:
    {
      OpSubgroupAvcSicConvertToMceResultINTEL decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "SubgroupAvcSicConvertToMceResultINTEL(" + ParamToStr(idName, decoded.payload) + ")";
      break;
    }
    case rdcspv::Op::SubgroupAvcSicGetIpeLumaShapeINTEL:
    {
      OpSubgroupAvcSicGetIpeLumaShapeINTEL decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "SubgroupAvcSicGetIpeLumaShapeINTEL(" + ParamToStr(idName, decoded.payload) + ")";
      break;
    }
    case rdcspv::Op::SubgroupAvcSicGetBestIpeLumaDistortionINTEL:
    {
      OpSubgroupAvcSicGetBestIpeLumaDistortionINTEL decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "SubgroupAvcSicGetBestIpeLumaDistortionINTEL(" + ParamToStr(idName, decoded.payload) + ")";
      break;
    }
    case rdcspv::Op::SubgroupAvcSicGetBestIpeChromaDistortionINTEL:
    {
      OpSubgroupAvcSicGetBestIpeChromaDistortionINTEL decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "SubgroupAvcSicGetBestIpeChromaDistortionINTEL(" + ParamToStr(idName, decoded.payload) + ")";
      break;
    }
    case rdcspv::Op::SubgroupAvcSicGetPackedIpeLumaModesINTEL:
    {
      OpSubgroupAvcSicGetPackedIpeLumaModesINTEL decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "SubgroupAvcSicGetPackedIpeLumaModesINTEL(" + ParamToStr(idName, decoded.payload) + ")";
      break;
    }
    case rdcspv::Op::SubgroupAvcSicGetIpeChromaModeINTEL:
    {
      OpSubgroupAvcSicGetIpeChromaModeINTEL decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "SubgroupAvcSicGetIpeChromaModeINTEL(" + ParamToStr(idName, decoded.payload) + ")";
      break;
    }
    case rdcspv::Op::SubgroupAvcSicGetPackedSkcLumaCountThresholdINTEL:
    {
      OpSubgroupAvcSicGetPackedSkcLumaCountThresholdINTEL decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "SubgroupAvcSicGetPackedSkcLumaCountThresholdINTEL(" + ParamToStr(idName, decoded.payload) + ")";
      break;
    }
    case rdcspv::Op::SubgroupAvcSicGetPackedSkcLumaSumThresholdINTEL:
    {
      OpSubgroupAvcSicGetPackedSkcLumaSumThresholdINTEL decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "SubgroupAvcSicGetPackedSkcLumaSumThresholdINTEL(" + ParamToStr(idName, decoded.payload) + ")";
      break;
    }
    case rdcspv::Op::SubgroupAvcSicGetInterRawSadsINTEL:
    {
      OpSubgroupAvcSicGetInterRawSadsINTEL decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "SubgroupAvcSicGetInterRawSadsINTEL(" + ParamToStr(idName, decoded.payload) + ")";
      break;
    }
    case rdcspv::Op::LoopControlINTEL:
    {
      OpLoopControlINTEL decoded(it);
      ret += "LoopControlINTEL(" + ParamsToStr(idName, decoded.loopControlParameters) + ")";
      break;
    }
    case rdcspv::Op::ReadPipeBlockingINTEL:
    {
      OpReadPipeBlockingINTEL decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "ReadPipeBlockingINTEL(" + ParamToStr(idName, decoded.packetSize) + ", " + ParamToStr(idName, decoded.packetAlignment) + ")";
      break;
    }
    case rdcspv::Op::WritePipeBlockingINTEL:
    {
      OpWritePipeBlockingINTEL decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "WritePipeBlockingINTEL(" + ParamToStr(idName, decoded.packetSize) + ", " + ParamToStr(idName, decoded.packetAlignment) + ")";
      break;
    }
    case rdcspv::Op::FPGARegINTEL:
    {
      OpFPGARegINTEL decoded(it);
      ret += declName(decoded.resultType, decoded.result0) + ", " + idName(decoded.result1) + " = ";
      ret += "FPGARegINTEL(" + ParamToStr(idName, decoded.result1) + ", " + ParamToStr(idName, decoded.input) + ")";
      break;
    }
    case rdcspv::Op::RayQueryGetRayTMinKHR:
    {
      OpRayQueryGetRayTMinKHR decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "RayQueryGetRayTMinKHR(" + ParamToStr(idName, decoded.rayQuery) + ")";
      break;
    }
    case rdcspv::Op::RayQueryGetRayFlagsKHR:
    {
      OpRayQueryGetRayFlagsKHR decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "RayQueryGetRayFlagsKHR(" + ParamToStr(idName, decoded.rayQuery) + ")";
      break;
    }
    case rdcspv::Op::RayQueryGetIntersectionTKHR:
    {
      OpRayQueryGetIntersectionTKHR decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "RayQueryGetIntersectionTKHR(" + ParamToStr(idName, decoded.rayQuery) + ", " + ParamToStr(idName, decoded.intersection) + ")";
      break;
    }
    case rdcspv::Op::RayQueryGetIntersectionInstanceCustomIndexKHR:
    {
      OpRayQueryGetIntersectionInstanceCustomIndexKHR decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "RayQueryGetIntersectionInstanceCustomIndexKHR(" + ParamToStr(idName, decoded.rayQuery) + ", " + ParamToStr(idName, decoded.intersection) + ")";
      break;
    }
    case rdcspv::Op::RayQueryGetIntersectionInstanceIdKHR:
    {
      OpRayQueryGetIntersectionInstanceIdKHR decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "RayQueryGetIntersectionInstanceIdKHR(" + ParamToStr(idName, decoded.rayQuery) + ", " + ParamToStr(idName, decoded.intersection) + ")";
      break;
    }
    case rdcspv::Op::RayQueryGetIntersectionInstanceShaderBindingTableRecordOffsetKHR:
    {
      OpRayQueryGetIntersectionInstanceShaderBindingTableRecordOffsetKHR decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "RayQueryGetIntersectionInstanceShaderBindingTableRecordOffsetKHR(" + ParamToStr(idName, decoded.rayQuery) + ", " + ParamToStr(idName, decoded.intersection) + ")";
      break;
    }
    case rdcspv::Op::RayQueryGetIntersectionGeometryIndexKHR:
    {
      OpRayQueryGetIntersectionGeometryIndexKHR decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "RayQueryGetIntersectionGeometryIndexKHR(" + ParamToStr(idName, decoded.rayQuery) + ", " + ParamToStr(idName, decoded.intersection) + ")";
      break;
    }
    case rdcspv::Op::RayQueryGetIntersectionPrimitiveIndexKHR:
    {
      OpRayQueryGetIntersectionPrimitiveIndexKHR decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "RayQueryGetIntersectionPrimitiveIndexKHR(" + ParamToStr(idName, decoded.rayQuery) + ", " + ParamToStr(idName, decoded.intersection) + ")";
      break;
    }
    case rdcspv::Op::RayQueryGetIntersectionBarycentricsKHR:
    {
      OpRayQueryGetIntersectionBarycentricsKHR decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "RayQueryGetIntersectionBarycentricsKHR(" + ParamToStr(idName, decoded.rayQuery) + ", " + ParamToStr(idName, decoded.intersection) + ")";
      break;
    }
    case rdcspv::Op::RayQueryGetIntersectionFrontFaceKHR:
    {
      OpRayQueryGetIntersectionFrontFaceKHR decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "RayQueryGetIntersectionFrontFaceKHR(" + ParamToStr(idName, decoded.rayQuery) + ", " + ParamToStr(idName, decoded.intersection) + ")";
      break;
    }
    case rdcspv::Op::RayQueryGetIntersectionCandidateAABBOpaqueKHR:
    {
      OpRayQueryGetIntersectionCandidateAABBOpaqueKHR decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "RayQueryGetIntersectionCandidateAABBOpaqueKHR(" + ParamToStr(idName, decoded.rayQuery) + ")";
      break;
    }
    case rdcspv::Op::RayQueryGetIntersectionObjectRayDirectionKHR:
    {
      OpRayQueryGetIntersectionObjectRayDirectionKHR decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "RayQueryGetIntersectionObjectRayDirectionKHR(" + ParamToStr(idName, decoded.rayQuery) + ", " + ParamToStr(idName, decoded.intersection) + ")";
      break;
    }
    case rdcspv::Op::RayQueryGetIntersectionObjectRayOriginKHR:
    {
      OpRayQueryGetIntersectionObjectRayOriginKHR decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "RayQueryGetIntersectionObjectRayOriginKHR(" + ParamToStr(idName, decoded.rayQuery) + ", " + ParamToStr(idName, decoded.intersection) + ")";
      break;
    }
    case rdcspv::Op::RayQueryGetWorldRayDirectionKHR:
    {
      OpRayQueryGetWorldRayDirectionKHR decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "RayQueryGetWorldRayDirectionKHR(" + ParamToStr(idName, decoded.rayQuery) + ")";
      break;
    }
    case rdcspv::Op::RayQueryGetWorldRayOriginKHR:
    {
      OpRayQueryGetWorldRayOriginKHR decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "RayQueryGetWorldRayOriginKHR(" + ParamToStr(idName, decoded.rayQuery) + ")";
      break;
    }
    case rdcspv::Op::RayQueryGetIntersectionObjectToWorldKHR:
    {
      OpRayQueryGetIntersectionObjectToWorldKHR decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "RayQueryGetIntersectionObjectToWorldKHR(" + ParamToStr(idName, decoded.rayQuery) + ", " + ParamToStr(idName, decoded.intersection) + ")";
      break;
    }
    case rdcspv::Op::RayQueryGetIntersectionWorldToObjectKHR:
    {
      OpRayQueryGetIntersectionWorldToObjectKHR decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "RayQueryGetIntersectionWorldToObjectKHR(" + ParamToStr(idName, decoded.rayQuery) + ", " + ParamToStr(idName, decoded.intersection) + ")";
      break;
    }
    case rdcspv::Op::AtomicFAddEXT:
    {
      OpAtomicFAddEXT decoded(it);
      ret += declName(decoded.resultType, decoded.result) + " = ";
      ret += "AtomicFAddEXT(" + ParamToStr(idName, decoded.pointer) + ", " + ToStr(Scope(constIntVal(decoded.memory))) + ", " + ToStr(MemorySemantics(constIntVal(decoded.semantics))) + ", " + ParamToStr(idName, decoded.value) + ")";
      break;
    }
    case Op::Max: break;
  }
  return ret;
}
  
OpDecoder::OpDecoder(const ConstIter &it)
{
  op = it.opcode();
  wordCount = (uint16_t)it.size();
  switch(op)
  {
    case rdcspv::Op::Nop: result = Id(); resultType = Id(); break;
    case rdcspv::Op::Undef: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::SourceContinued: result = Id(); resultType = Id(); break;
    case rdcspv::Op::Source: result = Id(); resultType = Id(); break;
    case rdcspv::Op::SourceExtension: result = Id(); resultType = Id(); break;
    case rdcspv::Op::Name: result = Id(); resultType = Id(); break;
    case rdcspv::Op::MemberName: result = Id(); resultType = Id(); break;
    case rdcspv::Op::String: result = Id::fromWord(it.word(1)); resultType = Id(); break;
    case rdcspv::Op::Line: result = Id(); resultType = Id(); break;
    case rdcspv::Op::Extension: result = Id(); resultType = Id(); break;
    case rdcspv::Op::ExtInstImport: result = Id::fromWord(it.word(1)); resultType = Id(); break;
    case rdcspv::Op::ExtInst: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::MemoryModel: result = Id(); resultType = Id(); break;
    case rdcspv::Op::EntryPoint: result = Id(); resultType = Id(); break;
    case rdcspv::Op::ExecutionMode: result = Id(); resultType = Id(); break;
    case rdcspv::Op::Capability: result = Id(); resultType = Id(); break;
    case rdcspv::Op::TypeVoid: result = Id::fromWord(it.word(1)); resultType = Id(); break;
    case rdcspv::Op::TypeBool: result = Id::fromWord(it.word(1)); resultType = Id(); break;
    case rdcspv::Op::TypeInt: result = Id::fromWord(it.word(1)); resultType = Id(); break;
    case rdcspv::Op::TypeFloat: result = Id::fromWord(it.word(1)); resultType = Id(); break;
    case rdcspv::Op::TypeVector: result = Id::fromWord(it.word(1)); resultType = Id(); break;
    case rdcspv::Op::TypeMatrix: result = Id::fromWord(it.word(1)); resultType = Id(); break;
    case rdcspv::Op::TypeImage: result = Id::fromWord(it.word(1)); resultType = Id(); break;
    case rdcspv::Op::TypeSampler: result = Id::fromWord(it.word(1)); resultType = Id(); break;
    case rdcspv::Op::TypeSampledImage: result = Id::fromWord(it.word(1)); resultType = Id(); break;
    case rdcspv::Op::TypeArray: result = Id::fromWord(it.word(1)); resultType = Id(); break;
    case rdcspv::Op::TypeRuntimeArray: result = Id::fromWord(it.word(1)); resultType = Id(); break;
    case rdcspv::Op::TypeStruct: result = Id::fromWord(it.word(1)); resultType = Id(); break;
    case rdcspv::Op::TypeOpaque: result = Id::fromWord(it.word(1)); resultType = Id(); break;
    case rdcspv::Op::TypePointer: result = Id::fromWord(it.word(1)); resultType = Id(); break;
    case rdcspv::Op::TypeFunction: result = Id::fromWord(it.word(1)); resultType = Id(); break;
    case rdcspv::Op::TypeEvent: result = Id::fromWord(it.word(1)); resultType = Id(); break;
    case rdcspv::Op::TypeDeviceEvent: result = Id::fromWord(it.word(1)); resultType = Id(); break;
    case rdcspv::Op::TypeReserveId: result = Id::fromWord(it.word(1)); resultType = Id(); break;
    case rdcspv::Op::TypeQueue: result = Id::fromWord(it.word(1)); resultType = Id(); break;
    case rdcspv::Op::TypePipe: result = Id::fromWord(it.word(1)); resultType = Id(); break;
    case rdcspv::Op::TypeForwardPointer: result = Id(); resultType = Id(); break;
    case rdcspv::Op::ConstantTrue: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::ConstantFalse: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::Constant: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::ConstantComposite: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::ConstantSampler: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::ConstantNull: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::SpecConstantTrue: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::SpecConstantFalse: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::SpecConstant: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::SpecConstantComposite: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::SpecConstantOp: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::Function: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::FunctionParameter: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::FunctionEnd: result = Id(); resultType = Id(); break;
    case rdcspv::Op::FunctionCall: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::Variable: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::ImageTexelPointer: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::Load: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::Store: result = Id(); resultType = Id(); break;
    case rdcspv::Op::CopyMemory: result = Id(); resultType = Id(); break;
    case rdcspv::Op::CopyMemorySized: result = Id(); resultType = Id(); break;
    case rdcspv::Op::AccessChain: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::InBoundsAccessChain: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::PtrAccessChain: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::ArrayLength: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::GenericPtrMemSemantics: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::InBoundsPtrAccessChain: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::Decorate: result = Id(); resultType = Id(); break;
    case rdcspv::Op::MemberDecorate: result = Id(); resultType = Id(); break;
    case rdcspv::Op::DecorationGroup: result = Id::fromWord(it.word(1)); resultType = Id(); break;
    case rdcspv::Op::GroupDecorate: result = Id(); resultType = Id(); break;
    case rdcspv::Op::GroupMemberDecorate: result = Id(); resultType = Id(); break;
    case rdcspv::Op::VectorExtractDynamic: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::VectorInsertDynamic: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::VectorShuffle: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::CompositeConstruct: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::CompositeExtract: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::CompositeInsert: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::CopyObject: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::Transpose: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::SampledImage: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::ImageSampleImplicitLod: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::ImageSampleExplicitLod: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::ImageSampleDrefImplicitLod: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::ImageSampleDrefExplicitLod: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::ImageSampleProjImplicitLod: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::ImageSampleProjExplicitLod: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::ImageSampleProjDrefImplicitLod: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::ImageSampleProjDrefExplicitLod: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::ImageFetch: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::ImageGather: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::ImageDrefGather: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::ImageRead: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::ImageWrite: result = Id(); resultType = Id(); break;
    case rdcspv::Op::Image: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::ImageQueryFormat: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::ImageQueryOrder: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::ImageQuerySizeLod: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::ImageQuerySize: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::ImageQueryLod: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::ImageQueryLevels: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::ImageQuerySamples: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::ConvertFToU: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::ConvertFToS: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::ConvertSToF: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::ConvertUToF: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::UConvert: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::SConvert: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::FConvert: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::QuantizeToF16: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::ConvertPtrToU: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::SatConvertSToU: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::SatConvertUToS: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::ConvertUToPtr: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::PtrCastToGeneric: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::GenericCastToPtr: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::GenericCastToPtrExplicit: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::Bitcast: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::SNegate: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::FNegate: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::IAdd: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::FAdd: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::ISub: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::FSub: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::IMul: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::FMul: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::UDiv: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::SDiv: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::FDiv: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::UMod: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::SRem: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::SMod: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::FRem: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::FMod: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::VectorTimesScalar: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::MatrixTimesScalar: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::VectorTimesMatrix: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::MatrixTimesVector: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::MatrixTimesMatrix: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::OuterProduct: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::Dot: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::IAddCarry: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::ISubBorrow: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::UMulExtended: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::SMulExtended: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::Any: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::All: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::IsNan: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::IsInf: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::IsFinite: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::IsNormal: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::SignBitSet: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::LessOrGreater: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::Ordered: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::Unordered: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::LogicalEqual: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::LogicalNotEqual: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::LogicalOr: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::LogicalAnd: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::LogicalNot: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::Select: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::IEqual: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::INotEqual: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::UGreaterThan: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::SGreaterThan: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::UGreaterThanEqual: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::SGreaterThanEqual: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::ULessThan: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::SLessThan: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::ULessThanEqual: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::SLessThanEqual: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::FOrdEqual: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::FUnordEqual: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::FOrdNotEqual: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::FUnordNotEqual: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::FOrdLessThan: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::FUnordLessThan: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::FOrdGreaterThan: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::FUnordGreaterThan: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::FOrdLessThanEqual: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::FUnordLessThanEqual: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::FOrdGreaterThanEqual: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::FUnordGreaterThanEqual: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::ShiftRightLogical: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::ShiftRightArithmetic: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::ShiftLeftLogical: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::BitwiseOr: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::BitwiseXor: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::BitwiseAnd: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::Not: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::BitFieldInsert: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::BitFieldSExtract: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::BitFieldUExtract: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::BitReverse: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::BitCount: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::DPdx: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::DPdy: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::Fwidth: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::DPdxFine: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::DPdyFine: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::FwidthFine: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::DPdxCoarse: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::DPdyCoarse: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::FwidthCoarse: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::EmitVertex: result = Id(); resultType = Id(); break;
    case rdcspv::Op::EndPrimitive: result = Id(); resultType = Id(); break;
    case rdcspv::Op::EmitStreamVertex: result = Id(); resultType = Id(); break;
    case rdcspv::Op::EndStreamPrimitive: result = Id(); resultType = Id(); break;
    case rdcspv::Op::ControlBarrier: result = Id(); resultType = Id(); break;
    case rdcspv::Op::MemoryBarrier: result = Id(); resultType = Id(); break;
    case rdcspv::Op::AtomicLoad: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::AtomicStore: result = Id(); resultType = Id(); break;
    case rdcspv::Op::AtomicExchange: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::AtomicCompareExchange: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::AtomicCompareExchangeWeak: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::AtomicIIncrement: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::AtomicIDecrement: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::AtomicIAdd: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::AtomicISub: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::AtomicSMin: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::AtomicUMin: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::AtomicSMax: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::AtomicUMax: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::AtomicAnd: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::AtomicOr: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::AtomicXor: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::Phi: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::LoopMerge: result = Id(); resultType = Id(); break;
    case rdcspv::Op::SelectionMerge: result = Id(); resultType = Id(); break;
    case rdcspv::Op::Label: result = Id::fromWord(it.word(1)); resultType = Id(); break;
    case rdcspv::Op::Branch: result = Id(); resultType = Id(); break;
    case rdcspv::Op::BranchConditional: result = Id(); resultType = Id(); break;
    case rdcspv::Op::Switch: result = Id(); resultType = Id(); break;
    case rdcspv::Op::Kill: result = Id(); resultType = Id(); break;
    case rdcspv::Op::Return: result = Id(); resultType = Id(); break;
    case rdcspv::Op::ReturnValue: result = Id(); resultType = Id(); break;
    case rdcspv::Op::Unreachable: result = Id(); resultType = Id(); break;
    case rdcspv::Op::LifetimeStart: result = Id(); resultType = Id(); break;
    case rdcspv::Op::LifetimeStop: result = Id(); resultType = Id(); break;
    case rdcspv::Op::GroupAsyncCopy: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::GroupWaitEvents: result = Id(); resultType = Id(); break;
    case rdcspv::Op::GroupAll: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::GroupAny: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::GroupBroadcast: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::GroupIAdd: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::GroupFAdd: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::GroupFMin: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::GroupUMin: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::GroupSMin: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::GroupFMax: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::GroupUMax: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::GroupSMax: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::ReadPipe: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::WritePipe: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::ReservedReadPipe: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::ReservedWritePipe: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::ReserveReadPipePackets: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::ReserveWritePipePackets: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::CommitReadPipe: result = Id(); resultType = Id(); break;
    case rdcspv::Op::CommitWritePipe: result = Id(); resultType = Id(); break;
    case rdcspv::Op::IsValidReserveId: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::GetNumPipePackets: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::GetMaxPipePackets: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::GroupReserveReadPipePackets: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::GroupReserveWritePipePackets: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::GroupCommitReadPipe: result = Id(); resultType = Id(); break;
    case rdcspv::Op::GroupCommitWritePipe: result = Id(); resultType = Id(); break;
    case rdcspv::Op::EnqueueMarker: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::EnqueueKernel: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::GetKernelNDrangeSubGroupCount: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::GetKernelNDrangeMaxSubGroupSize: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::GetKernelWorkGroupSize: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::GetKernelPreferredWorkGroupSizeMultiple: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::RetainEvent: result = Id(); resultType = Id(); break;
    case rdcspv::Op::ReleaseEvent: result = Id(); resultType = Id(); break;
    case rdcspv::Op::CreateUserEvent: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::IsValidEvent: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::SetUserEventStatus: result = Id(); resultType = Id(); break;
    case rdcspv::Op::CaptureEventProfilingInfo: result = Id(); resultType = Id(); break;
    case rdcspv::Op::GetDefaultQueue: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::BuildNDRange: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::ImageSparseSampleImplicitLod: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::ImageSparseSampleExplicitLod: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::ImageSparseSampleDrefImplicitLod: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::ImageSparseSampleDrefExplicitLod: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::ImageSparseSampleProjImplicitLod: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::ImageSparseSampleProjExplicitLod: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::ImageSparseSampleProjDrefImplicitLod: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::ImageSparseSampleProjDrefExplicitLod: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::ImageSparseFetch: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::ImageSparseGather: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::ImageSparseDrefGather: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::ImageSparseTexelsResident: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::NoLine: result = Id(); resultType = Id(); break;
    case rdcspv::Op::AtomicFlagTestAndSet: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::AtomicFlagClear: result = Id(); resultType = Id(); break;
    case rdcspv::Op::ImageSparseRead: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::SizeOf: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::TypePipeStorage: result = Id::fromWord(it.word(1)); resultType = Id(); break;
    case rdcspv::Op::ConstantPipeStorage: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::CreatePipeFromPipeStorage: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::GetKernelLocalSizeForSubgroupCount: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::GetKernelMaxNumSubgroups: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::TypeNamedBarrier: result = Id::fromWord(it.word(1)); resultType = Id(); break;
    case rdcspv::Op::NamedBarrierInitialize: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::MemoryNamedBarrier: result = Id(); resultType = Id(); break;
    case rdcspv::Op::ModuleProcessed: result = Id(); resultType = Id(); break;
    case rdcspv::Op::ExecutionModeId: result = Id(); resultType = Id(); break;
    case rdcspv::Op::DecorateId: result = Id(); resultType = Id(); break;
    case rdcspv::Op::GroupNonUniformElect: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::GroupNonUniformAll: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::GroupNonUniformAny: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::GroupNonUniformAllEqual: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::GroupNonUniformBroadcast: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::GroupNonUniformBroadcastFirst: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::GroupNonUniformBallot: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::GroupNonUniformInverseBallot: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::GroupNonUniformBallotBitExtract: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::GroupNonUniformBallotBitCount: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::GroupNonUniformBallotFindLSB: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::GroupNonUniformBallotFindMSB: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::GroupNonUniformShuffle: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::GroupNonUniformShuffleXor: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::GroupNonUniformShuffleUp: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::GroupNonUniformShuffleDown: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::GroupNonUniformIAdd: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::GroupNonUniformFAdd: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::GroupNonUniformIMul: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::GroupNonUniformFMul: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::GroupNonUniformSMin: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::GroupNonUniformUMin: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::GroupNonUniformFMin: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::GroupNonUniformSMax: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::GroupNonUniformUMax: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::GroupNonUniformFMax: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::GroupNonUniformBitwiseAnd: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::GroupNonUniformBitwiseOr: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::GroupNonUniformBitwiseXor: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::GroupNonUniformLogicalAnd: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::GroupNonUniformLogicalOr: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::GroupNonUniformLogicalXor: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::GroupNonUniformQuadBroadcast: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::GroupNonUniformQuadSwap: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::CopyLogical: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::PtrEqual: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::PtrNotEqual: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::PtrDiff: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::TerminateInvocation: result = Id(); resultType = Id(); break;
    case rdcspv::Op::SubgroupBallotKHR: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::SubgroupFirstInvocationKHR: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::SubgroupAllKHR: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::SubgroupAnyKHR: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::SubgroupAllEqualKHR: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::SubgroupReadInvocationKHR: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::TraceRayKHR: result = Id(); resultType = Id(); break;
    case rdcspv::Op::ExecuteCallableKHR: result = Id(); resultType = Id(); break;
    case rdcspv::Op::ConvertUToAccelerationStructureKHR: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::IgnoreIntersectionKHR: result = Id(); resultType = Id(); break;
    case rdcspv::Op::TerminateRayKHR: result = Id(); resultType = Id(); break;
    case rdcspv::Op::TypeRayQueryKHR: result = Id::fromWord(it.word(1)); resultType = Id(); break;
    case rdcspv::Op::RayQueryInitializeKHR: result = Id(); resultType = Id(); break;
    case rdcspv::Op::RayQueryTerminateKHR: result = Id(); resultType = Id(); break;
    case rdcspv::Op::RayQueryGenerateIntersectionKHR: result = Id(); resultType = Id(); break;
    case rdcspv::Op::RayQueryConfirmIntersectionKHR: result = Id(); resultType = Id(); break;
    case rdcspv::Op::RayQueryProceedKHR: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::RayQueryGetIntersectionTypeKHR: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::GroupIAddNonUniformAMD: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::GroupFAddNonUniformAMD: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::GroupFMinNonUniformAMD: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::GroupUMinNonUniformAMD: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::GroupSMinNonUniformAMD: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::GroupFMaxNonUniformAMD: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::GroupUMaxNonUniformAMD: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::GroupSMaxNonUniformAMD: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::FragmentMaskFetchAMD: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::FragmentFetchAMD: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::ReadClockKHR: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::ImageSampleFootprintNV: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::GroupNonUniformPartitionNV: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::WritePackedPrimitiveIndices4x8NV: result = Id(); resultType = Id(); break;
    case rdcspv::Op::ReportIntersectionNV: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::IgnoreIntersectionNV: result = Id(); resultType = Id(); break;
    case rdcspv::Op::TerminateRayNV: result = Id(); resultType = Id(); break;
    case rdcspv::Op::TraceNV: result = Id(); resultType = Id(); break;
    case rdcspv::Op::TypeAccelerationStructureNV: result = Id::fromWord(it.word(1)); resultType = Id(); break;
    case rdcspv::Op::ExecuteCallableNV: result = Id(); resultType = Id(); break;
    case rdcspv::Op::TypeCooperativeMatrixNV: result = Id::fromWord(it.word(1)); resultType = Id(); break;
    case rdcspv::Op::CooperativeMatrixLoadNV: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::CooperativeMatrixStoreNV: result = Id(); resultType = Id(); break;
    case rdcspv::Op::CooperativeMatrixMulAddNV: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::CooperativeMatrixLengthNV: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::BeginInvocationInterlockEXT: result = Id(); resultType = Id(); break;
    case rdcspv::Op::EndInvocationInterlockEXT: result = Id(); resultType = Id(); break;
    case rdcspv::Op::DemoteToHelperInvocationEXT: result = Id(); resultType = Id(); break;
    case rdcspv::Op::IsHelperInvocationEXT: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::SubgroupShuffleINTEL: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::SubgroupShuffleDownINTEL: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::SubgroupShuffleUpINTEL: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::SubgroupShuffleXorINTEL: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::SubgroupBlockReadINTEL: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::SubgroupBlockWriteINTEL: result = Id(); resultType = Id(); break;
    case rdcspv::Op::SubgroupImageBlockReadINTEL: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::SubgroupImageBlockWriteINTEL: result = Id(); resultType = Id(); break;
    case rdcspv::Op::SubgroupImageMediaBlockReadINTEL: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::SubgroupImageMediaBlockWriteINTEL: result = Id(); resultType = Id(); break;
    case rdcspv::Op::UCountLeadingZerosINTEL: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::UCountTrailingZerosINTEL: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::AbsISubINTEL: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::AbsUSubINTEL: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::IAddSatINTEL: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::UAddSatINTEL: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::IAverageINTEL: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::UAverageINTEL: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::IAverageRoundedINTEL: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::UAverageRoundedINTEL: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::ISubSatINTEL: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::USubSatINTEL: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::IMul32x16INTEL: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::UMul32x16INTEL: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::FunctionPointerINTEL: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::FunctionPointerCallINTEL: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::DecorateString: result = Id(); resultType = Id(); break;
    case rdcspv::Op::MemberDecorateString: result = Id(); resultType = Id(); break;
    case rdcspv::Op::VmeImageINTEL: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::TypeVmeImageINTEL: result = Id::fromWord(it.word(1)); resultType = Id(); break;
    case rdcspv::Op::TypeAvcImePayloadINTEL: result = Id::fromWord(it.word(1)); resultType = Id(); break;
    case rdcspv::Op::TypeAvcRefPayloadINTEL: result = Id::fromWord(it.word(1)); resultType = Id(); break;
    case rdcspv::Op::TypeAvcSicPayloadINTEL: result = Id::fromWord(it.word(1)); resultType = Id(); break;
    case rdcspv::Op::TypeAvcMcePayloadINTEL: result = Id::fromWord(it.word(1)); resultType = Id(); break;
    case rdcspv::Op::TypeAvcMceResultINTEL: result = Id::fromWord(it.word(1)); resultType = Id(); break;
    case rdcspv::Op::TypeAvcImeResultINTEL: result = Id::fromWord(it.word(1)); resultType = Id(); break;
    case rdcspv::Op::TypeAvcImeResultSingleReferenceStreamoutINTEL: result = Id::fromWord(it.word(1)); resultType = Id(); break;
    case rdcspv::Op::TypeAvcImeResultDualReferenceStreamoutINTEL: result = Id::fromWord(it.word(1)); resultType = Id(); break;
    case rdcspv::Op::TypeAvcImeSingleReferenceStreaminINTEL: result = Id::fromWord(it.word(1)); resultType = Id(); break;
    case rdcspv::Op::TypeAvcImeDualReferenceStreaminINTEL: result = Id::fromWord(it.word(1)); resultType = Id(); break;
    case rdcspv::Op::TypeAvcRefResultINTEL: result = Id::fromWord(it.word(1)); resultType = Id(); break;
    case rdcspv::Op::TypeAvcSicResultINTEL: result = Id::fromWord(it.word(1)); resultType = Id(); break;
    case rdcspv::Op::SubgroupAvcMceGetDefaultInterBaseMultiReferencePenaltyINTEL: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::SubgroupAvcMceSetInterBaseMultiReferencePenaltyINTEL: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::SubgroupAvcMceGetDefaultInterShapePenaltyINTEL: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::SubgroupAvcMceSetInterShapePenaltyINTEL: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::SubgroupAvcMceGetDefaultInterDirectionPenaltyINTEL: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::SubgroupAvcMceSetInterDirectionPenaltyINTEL: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::SubgroupAvcMceGetDefaultIntraLumaShapePenaltyINTEL: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::SubgroupAvcMceGetDefaultInterMotionVectorCostTableINTEL: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::SubgroupAvcMceGetDefaultHighPenaltyCostTableINTEL: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::SubgroupAvcMceGetDefaultMediumPenaltyCostTableINTEL: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::SubgroupAvcMceGetDefaultLowPenaltyCostTableINTEL: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::SubgroupAvcMceSetMotionVectorCostFunctionINTEL: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::SubgroupAvcMceGetDefaultIntraLumaModePenaltyINTEL: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::SubgroupAvcMceGetDefaultNonDcLumaIntraPenaltyINTEL: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::SubgroupAvcMceGetDefaultIntraChromaModeBasePenaltyINTEL: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::SubgroupAvcMceSetAcOnlyHaarINTEL: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::SubgroupAvcMceSetSourceInterlacedFieldPolarityINTEL: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::SubgroupAvcMceSetSingleReferenceInterlacedFieldPolarityINTEL: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::SubgroupAvcMceSetDualReferenceInterlacedFieldPolaritiesINTEL: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::SubgroupAvcMceConvertToImePayloadINTEL: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::SubgroupAvcMceConvertToImeResultINTEL: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::SubgroupAvcMceConvertToRefPayloadINTEL: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::SubgroupAvcMceConvertToRefResultINTEL: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::SubgroupAvcMceConvertToSicPayloadINTEL: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::SubgroupAvcMceConvertToSicResultINTEL: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::SubgroupAvcMceGetMotionVectorsINTEL: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::SubgroupAvcMceGetInterDistortionsINTEL: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::SubgroupAvcMceGetBestInterDistortionsINTEL: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::SubgroupAvcMceGetInterMajorShapeINTEL: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::SubgroupAvcMceGetInterMinorShapeINTEL: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::SubgroupAvcMceGetInterDirectionsINTEL: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::SubgroupAvcMceGetInterMotionVectorCountINTEL: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::SubgroupAvcMceGetInterReferenceIdsINTEL: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::SubgroupAvcMceGetInterReferenceInterlacedFieldPolaritiesINTEL: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::SubgroupAvcImeInitializeINTEL: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::SubgroupAvcImeSetSingleReferenceINTEL: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::SubgroupAvcImeSetDualReferenceINTEL: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::SubgroupAvcImeRefWindowSizeINTEL: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::SubgroupAvcImeAdjustRefOffsetINTEL: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::SubgroupAvcImeConvertToMcePayloadINTEL: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::SubgroupAvcImeSetMaxMotionVectorCountINTEL: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::SubgroupAvcImeSetUnidirectionalMixDisableINTEL: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::SubgroupAvcImeSetEarlySearchTerminationThresholdINTEL: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::SubgroupAvcImeSetWeightedSadINTEL: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::SubgroupAvcImeEvaluateWithSingleReferenceINTEL: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::SubgroupAvcImeEvaluateWithDualReferenceINTEL: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::SubgroupAvcImeEvaluateWithSingleReferenceStreaminINTEL: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::SubgroupAvcImeEvaluateWithDualReferenceStreaminINTEL: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::SubgroupAvcImeEvaluateWithSingleReferenceStreamoutINTEL: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::SubgroupAvcImeEvaluateWithDualReferenceStreamoutINTEL: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::SubgroupAvcImeEvaluateWithSingleReferenceStreaminoutINTEL: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::SubgroupAvcImeEvaluateWithDualReferenceStreaminoutINTEL: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::SubgroupAvcImeConvertToMceResultINTEL: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::SubgroupAvcImeGetSingleReferenceStreaminINTEL: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::SubgroupAvcImeGetDualReferenceStreaminINTEL: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::SubgroupAvcImeStripSingleReferenceStreamoutINTEL: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::SubgroupAvcImeStripDualReferenceStreamoutINTEL: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::SubgroupAvcImeGetStreamoutSingleReferenceMajorShapeMotionVectorsINTEL: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::SubgroupAvcImeGetStreamoutSingleReferenceMajorShapeDistortionsINTEL: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::SubgroupAvcImeGetStreamoutSingleReferenceMajorShapeReferenceIdsINTEL: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::SubgroupAvcImeGetStreamoutDualReferenceMajorShapeMotionVectorsINTEL: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::SubgroupAvcImeGetStreamoutDualReferenceMajorShapeDistortionsINTEL: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::SubgroupAvcImeGetStreamoutDualReferenceMajorShapeReferenceIdsINTEL: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::SubgroupAvcImeGetBorderReachedINTEL: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::SubgroupAvcImeGetTruncatedSearchIndicationINTEL: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::SubgroupAvcImeGetUnidirectionalEarlySearchTerminationINTEL: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::SubgroupAvcImeGetWeightingPatternMinimumMotionVectorINTEL: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::SubgroupAvcImeGetWeightingPatternMinimumDistortionINTEL: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::SubgroupAvcFmeInitializeINTEL: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::SubgroupAvcBmeInitializeINTEL: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::SubgroupAvcRefConvertToMcePayloadINTEL: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::SubgroupAvcRefSetBidirectionalMixDisableINTEL: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::SubgroupAvcRefSetBilinearFilterEnableINTEL: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::SubgroupAvcRefEvaluateWithSingleReferenceINTEL: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::SubgroupAvcRefEvaluateWithDualReferenceINTEL: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::SubgroupAvcRefEvaluateWithMultiReferenceINTEL: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::SubgroupAvcRefEvaluateWithMultiReferenceInterlacedINTEL: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::SubgroupAvcRefConvertToMceResultINTEL: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::SubgroupAvcSicInitializeINTEL: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::SubgroupAvcSicConfigureSkcINTEL: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::SubgroupAvcSicConfigureIpeLumaINTEL: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::SubgroupAvcSicConfigureIpeLumaChromaINTEL: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::SubgroupAvcSicGetMotionVectorMaskINTEL: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::SubgroupAvcSicConvertToMcePayloadINTEL: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::SubgroupAvcSicSetIntraLumaShapePenaltyINTEL: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::SubgroupAvcSicSetIntraLumaModeCostFunctionINTEL: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::SubgroupAvcSicSetIntraChromaModeCostFunctionINTEL: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::SubgroupAvcSicSetBilinearFilterEnableINTEL: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::SubgroupAvcSicSetSkcForwardTransformEnableINTEL: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::SubgroupAvcSicSetBlockBasedRawSkipSadINTEL: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::SubgroupAvcSicEvaluateIpeINTEL: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::SubgroupAvcSicEvaluateWithSingleReferenceINTEL: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::SubgroupAvcSicEvaluateWithDualReferenceINTEL: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::SubgroupAvcSicEvaluateWithMultiReferenceINTEL: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::SubgroupAvcSicEvaluateWithMultiReferenceInterlacedINTEL: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::SubgroupAvcSicConvertToMceResultINTEL: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::SubgroupAvcSicGetIpeLumaShapeINTEL: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::SubgroupAvcSicGetBestIpeLumaDistortionINTEL: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::SubgroupAvcSicGetBestIpeChromaDistortionINTEL: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::SubgroupAvcSicGetPackedIpeLumaModesINTEL: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::SubgroupAvcSicGetIpeChromaModeINTEL: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::SubgroupAvcSicGetPackedSkcLumaCountThresholdINTEL: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::SubgroupAvcSicGetPackedSkcLumaSumThresholdINTEL: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::SubgroupAvcSicGetInterRawSadsINTEL: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::LoopControlINTEL: result = Id(); resultType = Id(); break;
    case rdcspv::Op::ReadPipeBlockingINTEL: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::WritePipeBlockingINTEL: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::FPGARegINTEL: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::RayQueryGetRayTMinKHR: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::RayQueryGetRayFlagsKHR: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::RayQueryGetIntersectionTKHR: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::RayQueryGetIntersectionInstanceCustomIndexKHR: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::RayQueryGetIntersectionInstanceIdKHR: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::RayQueryGetIntersectionInstanceShaderBindingTableRecordOffsetKHR: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::RayQueryGetIntersectionGeometryIndexKHR: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::RayQueryGetIntersectionPrimitiveIndexKHR: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::RayQueryGetIntersectionBarycentricsKHR: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::RayQueryGetIntersectionFrontFaceKHR: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::RayQueryGetIntersectionCandidateAABBOpaqueKHR: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::RayQueryGetIntersectionObjectRayDirectionKHR: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::RayQueryGetIntersectionObjectRayOriginKHR: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::RayQueryGetWorldRayDirectionKHR: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::RayQueryGetWorldRayOriginKHR: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::RayQueryGetIntersectionObjectToWorldKHR: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::RayQueryGetIntersectionWorldToObjectKHR: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case rdcspv::Op::AtomicFAddEXT: result = Id::fromWord(it.word(2)); resultType = Id::fromWord(it.word(1)); break;
    case Op::Max: break;
  }
}

}; // namespace rdcspv

template <>
rdcstr DoStringise(const rdcspv::GLSLstd450 &el)
{
  BEGIN_ENUM_STRINGISE(rdcspv::GLSLstd450);
  {
    STRINGISE_ENUM_CLASS(Round);
    STRINGISE_ENUM_CLASS(RoundEven);
    STRINGISE_ENUM_CLASS(Trunc);
    STRINGISE_ENUM_CLASS(FAbs);
    STRINGISE_ENUM_CLASS(SAbs);
    STRINGISE_ENUM_CLASS(FSign);
    STRINGISE_ENUM_CLASS(SSign);
    STRINGISE_ENUM_CLASS(Floor);
    STRINGISE_ENUM_CLASS(Ceil);
    STRINGISE_ENUM_CLASS(Fract);
    STRINGISE_ENUM_CLASS(Radians);
    STRINGISE_ENUM_CLASS(Degrees);
    STRINGISE_ENUM_CLASS(Sin);
    STRINGISE_ENUM_CLASS(Cos);
    STRINGISE_ENUM_CLASS(Tan);
    STRINGISE_ENUM_CLASS(Asin);
    STRINGISE_ENUM_CLASS(Acos);
    STRINGISE_ENUM_CLASS(Atan);
    STRINGISE_ENUM_CLASS(Sinh);
    STRINGISE_ENUM_CLASS(Cosh);
    STRINGISE_ENUM_CLASS(Tanh);
    STRINGISE_ENUM_CLASS(Asinh);
    STRINGISE_ENUM_CLASS(Acosh);
    STRINGISE_ENUM_CLASS(Atanh);
    STRINGISE_ENUM_CLASS(Atan2);
    STRINGISE_ENUM_CLASS(Pow);
    STRINGISE_ENUM_CLASS(Exp);
    STRINGISE_ENUM_CLASS(Log);
    STRINGISE_ENUM_CLASS(Exp2);
    STRINGISE_ENUM_CLASS(Log2);
    STRINGISE_ENUM_CLASS(Sqrt);
    STRINGISE_ENUM_CLASS(InverseSqrt);
    STRINGISE_ENUM_CLASS(Determinant);
    STRINGISE_ENUM_CLASS(MatrixInverse);
    STRINGISE_ENUM_CLASS(Modf);
    STRINGISE_ENUM_CLASS(ModfStruct);
    STRINGISE_ENUM_CLASS(FMin);
    STRINGISE_ENUM_CLASS(UMin);
    STRINGISE_ENUM_CLASS(SMin);
    STRINGISE_ENUM_CLASS(FMax);
    STRINGISE_ENUM_CLASS(UMax);
    STRINGISE_ENUM_CLASS(SMax);
    STRINGISE_ENUM_CLASS(FClamp);
    STRINGISE_ENUM_CLASS(UClamp);
    STRINGISE_ENUM_CLASS(SClamp);
    STRINGISE_ENUM_CLASS(FMix);
    STRINGISE_ENUM_CLASS(IMix);
    STRINGISE_ENUM_CLASS(Step);
    STRINGISE_ENUM_CLASS(SmoothStep);
    STRINGISE_ENUM_CLASS(Fma);
    STRINGISE_ENUM_CLASS(Frexp);
    STRINGISE_ENUM_CLASS(FrexpStruct);
    STRINGISE_ENUM_CLASS(Ldexp);
    STRINGISE_ENUM_CLASS(PackSnorm4x8);
    STRINGISE_ENUM_CLASS(PackUnorm4x8);
    STRINGISE_ENUM_CLASS(PackSnorm2x16);
    STRINGISE_ENUM_CLASS(PackUnorm2x16);
    STRINGISE_ENUM_CLASS(PackHalf2x16);
    STRINGISE_ENUM_CLASS(PackDouble2x32);
    STRINGISE_ENUM_CLASS(UnpackSnorm2x16);
    STRINGISE_ENUM_CLASS(UnpackUnorm2x16);
    STRINGISE_ENUM_CLASS(UnpackHalf2x16);
    STRINGISE_ENUM_CLASS(UnpackSnorm4x8);
    STRINGISE_ENUM_CLASS(UnpackUnorm4x8);
    STRINGISE_ENUM_CLASS(UnpackDouble2x32);
    STRINGISE_ENUM_CLASS(Length);
    STRINGISE_ENUM_CLASS(Distance);
    STRINGISE_ENUM_CLASS(Cross);
    STRINGISE_ENUM_CLASS(Normalize);
    STRINGISE_ENUM_CLASS(FaceForward);
    STRINGISE_ENUM_CLASS(Reflect);
    STRINGISE_ENUM_CLASS(Refract);
    STRINGISE_ENUM_CLASS(FindILsb);
    STRINGISE_ENUM_CLASS(FindSMsb);
    STRINGISE_ENUM_CLASS(FindUMsb);
    STRINGISE_ENUM_CLASS(InterpolateAtCentroid);
    STRINGISE_ENUM_CLASS(InterpolateAtSample);
    STRINGISE_ENUM_CLASS(InterpolateAtOffset);
    STRINGISE_ENUM_CLASS(NMin);
    STRINGISE_ENUM_CLASS(NMax);
    STRINGISE_ENUM_CLASS(NClamp);
  }
  END_ENUM_STRINGISE();
}

template <>
rdcstr DoStringise(const rdcspv::Generator &el)
{
  BEGIN_ENUM_STRINGISE(rdcspv::Generator);
  {
    STRINGISE_ENUM_CLASS_NAMED(LLVMSPIRVTranslator, "LLVM/SPIR-V Translator from Khronos - Contact Yaxun (Sam) Liu, yaxun.liu@amd.com");
    STRINGISE_ENUM_CLASS_NAMED(SPIRVToolsAssembler, "SPIR-V Tools Assembler from Khronos - Contact David Neto, dneto@google.com");
    STRINGISE_ENUM_CLASS_NAMED(GlslangReferenceFrontEnd, "Glslang Reference Front End from Khronos - Contact John Kessenich, johnkessenich@google.com");
    STRINGISE_ENUM_CLASS_NAMED(ShadercoverGlslang, "Shaderc over Glslang from Google - Contact David Neto, dneto@google.com");
    STRINGISE_ENUM_CLASS_NAMED(spiregg, "spiregg from Google - Contact Lei Zhang, antiagainst@google.com");
    STRINGISE_ENUM_CLASS_NAMED(rspirv, "rspirv from Google - Contact Lei Zhang, antiagainst@gmail.com");
    STRINGISE_ENUM_CLASS_NAMED(MesaIRSPIRVTranslator, "Mesa-IR/SPIR-V Translator from X-LEGEND - Contact Metora Wang, github:metora/MesaGLSLCompiler");
    STRINGISE_ENUM_CLASS_NAMED(SPIRVToolsLinker, "SPIR-V Tools Linker from Khronos - Contact David Neto, dneto@google.com");
    STRINGISE_ENUM_CLASS_NAMED(VKD3DShaderCompiler, "VKD3D Shader Compiler from Wine - Contact wine-devel@winehq.org");
    STRINGISE_ENUM_CLASS_NAMED(ClayShaderCompiler, "Clay Shader Compiler from Clay - Contact info@clayengine.com");
    STRINGISE_ENUM_CLASS_NAMED(WHLSLShaderTranslator, "WHLSL Shader Translator from W3C WebGPU Group - https://github.com/gpuweb/WHLSL");
    STRINGISE_ENUM_CLASS_NAMED(Clspv, "Clspv from Google - Contact David Neto, dneto@google.com");
    STRINGISE_ENUM_CLASS_NAMED(MLIRSPIRVSerializer, "MLIR SPIR-V Serializer from Google - Contact Lei Zhang, antiagainst@google.com");
    STRINGISE_ENUM_CLASS_NAMED(TintCompiler, "Tint Compiler from Google - Contact David Neto, dneto@google.com");
    STRINGISE_ENUM_CLASS_NAMED(ANGLEShaderCompiler, "ANGLE Shader Compiler from Google - Contact Shahbaz Youssefi, syoussefi@google.com");
    STRINGISE_ENUM_CLASS_NAMED(MessiahShaderCompiler, "Messiah Shader Compiler from Netease Games - Contact Yuwen Wu, atyuwen@gmail.com");
    STRINGISE_ENUM_CLASS_NAMED(XeniaEmulatorMicrocodeTranslator, "Xenia Emulator Microcode Translator from Xenia - Contact Vitaliy Kuzmin, triang3l@yandex.ru, https://github.com/xenia-project/xenia");
    STRINGISE_ENUM_CLASS_NAMED(RustGPUCompilerBackend, "Rust GPU Compiler Backend from Embark Studios - https://github.com/embarkstudios/rust-gpu");
  }
  END_ENUM_STRINGISE();
}
